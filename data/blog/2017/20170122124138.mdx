---
title: 'scanf、sscanf中的正则表达式（迁移2011-01-14）'
date: '2017-01-22'
tags: ['C/C++']
draft: false
summary: 介绍 scanf、sscanf 中的正则表达式，包括定制扫描集、读入地址、丢弃空白符等。通过多个实验展示 sscanf 用正则表达式格式化输入后字符串的变化，如不同条件下的拷贝和过滤等，还提到 msdn 中 sscanf 声明及可直接用正则表达式等内容。 
---

1. 定制自己的扫描集 %[abc]、%[a-z]、%[^abc]、%[^a-z]，比isdigit()、isalpha()更加灵活。[]内是匹配的字符,^表示求反集。
```
int i;char str[80], str2[80];// scanf("%d%[abc]%s", &i, str, str2);  // printf("%d %s   %s/n",i,str,str2);// scanf("%[a-zA-Z0-9]", str);// scanf("%[^abce]", str);scanf("%[^a-z]", str);printf("%s/n",str);
```
2. 读入一个地址并显示内存地址的内容
```
int main(void){char ch='c';printf("%p/n", &ch); // print the address of ch.char *p;cout<<"Enter an address: ";scanf("%p", &p);     //input the address displayed aboveprintf("Value at location %p is %c/n",p,*p);return 0;}
```
3. 丢弃不想要的空白符：scanf("%c %c")；
4. 控制字符串中的非空白符：导致scanf()读入并丢弃输入流中的一个匹配字符。"%d，%d"；
5. 压缩输入：在格式码前加上*，则用户就可以告诉scanf()读这个域，但不把它赋予任何变量。
    scanf("%c%*c, &ch); 使用此方法可以在字符处理时吃掉多余的回车。
```
例1：从<sip:tom@172.18.1.133>中提取tom    const char* url = "<sip:tom@172.18.1.133>";    char uri[10] = {0};    sscanf(url, "%*[^:]:%[^@]", uri);    cout << uri << endl;例2：从iios/12DDWDFF@122中提取 12DDWDFF    const char* s = "iios/12DDWDFF@122";    char buf[20];    sscanf(s, "%*[^/]/%[^@]", buf);    cout << buf << endl;
```

看了几篇介绍sscanf函数，真是发现自己好多东西没理解透。  
### 第一篇：  
此文所有的实验都是基于下面的程序： 
``` 
char str[10];  
for (int i = 0; i < 10; i++) str[i] = '!';  
```
> 执行完后str的值为:str = "!!!!!!!!!!"   

我们把str的每个字符都初始化为惊叹号，当str的值发生变化时，使用printf打印str的值，对比先前的惊叹号，这样就可以方便的观察str发生了怎样的变化。下面我们做几个小实验，看看使用sscanf和正则表达式格式化输入后，str有什么变化。  

实验1：  
```
sscanf( "123456" , "%s" , str) ; ---------str的值为 "123456\0!!!"  
```
> 这个实验很简单，把源字符串"123456"拷贝到str的前6个字符，并且把str的第7个字符设为null字符，也就是\0  
实验2：  
```
sscanf( "123456" , "%3s" , str) ; ---------str的值为 "123\0!!!!!!"  
```
> 看到没有，正则表达式的百分号后面多了一个3，这告诉sscanf只拷贝3个字符给str，然后把第4个字符设为null字符。  
实验3：  
```
sscanf( "aaaAAA" , "%[a-z]" , str) ; ---------str的值为 "aaa\0!!!!!!"  
```
> 从这个实验开始我们会使用正则表达式，括号里面的a-z就是一个正则表达式，它可以表示从a到z的任意字符，
在继续讨论之前，我们先来看看百分号表示什么意思，%表示选择 ，%后面的是条件，比如实验1的"%s"，s是一个条件，表示任意字符，"%s"的意思是：只要输入的东西是一个字符，就把它拷贝给str。实验2的"%3s"又多了一个条件：只拷贝3个字符。实验3的“%[a-z]”的条件稍微严格一些，输入的东西不但是字符，还得是一个小写字母的字符，所以实验3只拷贝了小写字母"aaa"给str，别忘了加上null字符。  
实验4：
```
sscanf( "AAAaaaBBB" , "%[^a-z]" , str) ; ---------str的值为 "AAA\0!!!!!!"
```
> 对于所有字符，只要不是小写字母，都满足"^a-z"正则表达式，符号^表示逻辑非。前3个字符都不是小写字符，所以将其拷贝给str，但最后3个字符也不是小写字母，为什么不拷贝给str呢？这是因为当碰到不满足条件的字符后，sscanf就会停止执行，不再扫描之后的字符。  
实验5：  
``` 
sscanf( "AAAaaaBBB" , "%[A-Z]%[a-z]" , str) ; ---------段错误  
```
> 这个实验的本意是：先把大写字母拷贝给str，然后把小写字母拷贝给str，但很不幸，程序运行的时候会发生段错误，因为当sscanf扫描到字符a时，违反了条件"%[A-Z]"，sscanf就停止执行，不再扫描之后的字符，所以第二个条件也就没有任何意义，这个实验说明：不能使用%号两次或两次以上  

实验6：  
```
sscanf( "AAAaaaBBB" , "%*[A-Z]%[a-z]" , str) ; ---------str的值为 "aaa\0!!!!!!"  
```
> 这个实验出现了一个新的符号：%*，与%相反，%*表示过滤 满足条件的字符，在这个实验中，%*[A-Z]过滤了所有大写字母，然后再使用%[a-z]把之后的小写字母拷贝给str。如果只有%*，没有%的话，sscanf不会拷贝任何字符到str，这时sscanf的作用仅仅是过滤字符串。  

实验7：  
```
sscanf( "AAAaaaBBB" , "%[a-z]" , str) ; ---------str的值为 "!!!!!!!!!!"  
```
> 做完前面几个实验后，我们都知道sscanf拷贝完成后，还会在str的后面加上一个null字符，但如果没有一个字符满足条件，sscanf不会在str的后面加null字符，str的值依然是10个惊叹号。这个实验也说明了，如果不使用%*过滤掉前面不需要的字符，你永远别想取得中间的字符。  

实验8：  
```
sscanf( "AAAaaaBC=" , "%*[A-Z]%*[a-z]%[^a-z=]" , str) ; ---------str的值为 "BC\0!!!!!!!"  
```
> 这是一个综合实验，但这个实验的目的不是帮我们复习前面所学的知识，而是展示两个值得注意的地方：
注意1：%只能使用一次，但%*可以使用多次，比如在这个实验里面，先用%*[A-Z]过滤大写字母，然后用%*[a-z]过滤小写字母。  
> 注意2：^后面可以带多个条件，且这些条件都受^的作用，比如^a-z=表示^a-z且^=(既不是小写字母，也不是等于号)。  

实验9：  
```
int k;  
sscanf( "AAA123BBB456" , "%*[^0-9]%i" , &k) ; ---------k的值为123  
```
> 首先，%*[^0-9]过滤前面非数字的字符，然后用%i把数字字符转换成int型的整数，拷贝到变量k，注意参数必须使用k的地址。  

第二篇：  
今天翻google reader的时候看到这样一篇文章，介绍的是sscanf的高级用法。直到今天我才知道sscanf是可以直接用正则表达式的，惭愧。  
在msdn中sscanf的声明如下  
```
int sscanf( const char *buffer, const char *format [, argument ] ... );  
```
双字节版本的是这样的  
```
int swscanf( const wchar_t *buffer, const wchar_t *format [, argument ] ... );  
```
第一个参数是源字符串，这没什么好讲。第三个及以后的参数是可变参数列表，用于接收解析出来之后的值，可变参数列表不是本文的重点，暂且不提。最有玄机的是第二个参数，也就是所谓的format。我们知道  prinft,sprintf,scanf,sscanf这四个函数（以及相应的双字节版本）都接收一个名为format的字符串作为参数，以便对输入输出做格式化，比如  
```
sscanf(“12”, "%d", &in)  
```
可以把字符串"12"（念做一二）格式化成10进制数12（念做十二），并赋值给in，而  
```
sscanf(“12”, "%s", str)  
```
可以把字符串"12"格式化成字符串12，并拷贝到str指向的内存区域。如此种种。如果你仔细看过C语言手册，那么你一定对次非常熟悉，并喜欢在中间夹杂点啊三啊啥的组成诸如%.4ld之类的format赢取初学者（或者老板）的赞扬。但是你可真不一定了解，format里是可以直接用正则表达式的，比如  
```
sscanf("123334abcd123", "%[0-9]*", str);  
```
执行完后str的内容是字符串"123334"。[0-9]*是一个非常简单的正则表达式，意思是匹配数字任意次。关于正则表达式的更多内容请参看这个。  
我们在写程序时经常会碰到需要解析字符串的情况，而正则表达式则是解决此类问题的利器。如果我们能善用c标准库函数就能使用的正则表达式，一定可以做到事半而功倍。  
------------  
附正则表达式完整列表  
字元
描述
```
> 
\  
將下一個字元標記為一個特殊字元、或一個原義字元、或一個向後引用、或一個八進位轉義符。例如，「n」匹配字元「n」。「\n」匹配一個換行符。序列「\\」匹配「\」而「\(」則匹配「(」。
^  
匹配輸入字元串的開始位置。如果設置了RegExp對象的Multiline屬性，^也匹配「\n」或「\r」之後的位置。
$  
匹配輸入字元串的結束位置。如果設置了RegExp對象的Multiline屬性，$也匹配「\n」或「\r」之前的位置。
*  
匹配前面的子表達式零次或多次。例如，zo*能匹配「z」以及「zoo」。*等價于{0,}。
+  
匹配前面的子表達式一次或多次。例如，「zo+」能匹配「zo」以及「zoo」，但不能匹配「z」。+等價于{1,}。
?  
匹配前面的子表達式零次或一次。例如，「do(es)?」可以匹配「do」或「does」中的「do」。?等價于{0,1}。
{n}  
n是一個非負整數。匹配確定的n次。例如，「o{2}」不能匹配「Bob」中的「o」，但是能匹配「food」中的兩個o。  
{n,}  
n是一個非負整數。至少匹配n次。例如，「o{2,}」不能匹配「Bob」中的「o」，但能匹配「foooood」中的所有o。「o{1,}」等價于「o+」。「o{0,}」則等價于「o*」。  
{n,m}  
m和n均為非負整數，其中```n<=m```。最少匹配n次且最多匹配m次。例如，```「o{1,3}」```將匹配「fooooood」中的前三個o。
```「o{0,1}」```等價于「o?」。請注意在逗號和兩個數之間不能有空格。  
?  
當該字元緊跟在任何一個其他限制符(*,+,?,{n},{n,},{n,m})後面時，匹配模式是非貪婪的。非貪婪模式盡可能少的匹配所搜索的字元串，而默認的貪婪模式則盡可能多的匹配所搜索的字元串。例如，對於字元串「oooo」，「o+?」將匹配單個「o」，而「o+」將匹配所有「o」。  
.  
匹配除「\n」之外的任何單個字元。要匹配包括「\n」在內的任何字元，請使用像「[.\n]」的模式。  
(pattern)  
匹配pattern並獲取這一匹配。所獲取的匹配可以從產生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中則使用$0…$9屬性。要匹配圓括號字元，請使用「」或「」。  
(?:pattern)  
匹配pattern但不獲取匹配結果，也就是說這是一個非獲取匹配，不進行存儲供以後使用。這在使用「或」字元(|)來組合一個模式的各個部分是很有用。例如，「industr(?:y|ies)就是一個比」industry|industries'更簡略的表達式。
(?=pattern)  
正向預查，在任何匹配pattern的字元串開始處匹配查找字元串。這是一個非獲取匹配，也就是說，該匹配不需要獲取供以後使用。例如， 「Windows(?=95|98|NT|2000)」能匹配「Windows2000」中的「Windows」，但不能匹配「Windows3.1」中 的「Windows」。預查不消耗字元，也就是說，在一個匹配發生後，在最後一次匹配之後立即開始下一次匹配的搜索，而不是從包含預查的字元之後開始。  
(?!pattern)  
負向預查，在任何不匹配pattern的字元串開始處匹配查找字元串。這是一個非獲取匹配，也就是說，該匹配不需要獲取供以後使用。例如 「Windows(?!95|98|NT|2000)」能匹配「Windows3.1」中的「Windows」，但不能匹配「Windows2000」中 的「Windows」。預查不消耗字元，也就是說，在一個匹配發生後，在最後一次匹配之後立即開始下一次匹配的搜索，而不是從包含預查的字元之後開始  
x|y   
匹配x或y。例如，「z|food」能匹配「z」或「food」。「(z|f)ood」則匹配「zood」或「food」。  
[xyz]  
字符集合。匹配所包含的任意一個字元。例如，「[abc]」可以匹配「plain」中的「a」。  
[^xyz]  
負值字符集合。匹配未包含的任意字元。例如，「[^abc]」可以匹配「plain」中的「p」。  
[a-z]  
字元範圍。匹配指定範圍內的任意字元。例如，「[a-z]」可以匹配「a」到「z」範圍內的任意小寫字母字元。  
[^a-z]  
負值字元範圍。匹配任何不在指定範圍內的任意字元。例如，「[^a-z]」可以匹配任何不在「a」到「z」範圍內的任意字元。  
\b  
匹配一個單詞邊界，也就是指單詞和空格間的位置。例如，「er\b」可以匹配「never」中的「er」，但不能匹配「verb」中的「er」。  
\B  
匹配非單詞邊界。「er\B」能匹配「verb」中的「er」，但不能匹配「never」中的「er」。  
\cx  
匹配由x指明的控制字元。例如，\cM匹配一個Control-M或回車符。x的值必須為A-Z或a-z之一。否則，將c視為一個原義的「c」字元。  
\d  
匹配一個數字字元。等價于[0-9]。  
\D  
匹配一個非數字字元。等價于[^0-9]。  
\f  
匹配一個換頁符。等價于\x0c和\cL。  
\n  
匹配一個換行符。等價于\x0a和\cJ。  
\r  
匹配一個回車符。等價于\x0d和\cM。  
\s  
匹配任何空白字元，包括空格、製表符、換頁符等等。等價于[\f\n\r\t\v]。  
\S  
匹配任何非空白字元。等價于[^\f\n\r\t\v]。  
\t  
匹配一個製表符。等價于\x09和\cI。  
\v  
匹配一個垂直製表符。等價于\x0b和\cK。  
\w  
匹配包括下劃線的任何單詞字元。等價于「[A-Za-z0-9_]」。  
\W  
匹配任何非單詞字元。等價于「[^A-Za-z0-9_]」。  
\xn  
匹配n，其中n為十六進位轉義值。十六進位轉義值必須為確定的兩個數字長。例如，「\x41」匹配「A」。「\x041」則等價于「\x04」&「1」。正則表達式中可以使用ASCII編碼。.  
\num  
匹配num，其中num是一個正整數。對所獲取的匹配的引用。例如，「(.)\1」匹配兩個連續的相同字元。  
\n  
標識一個八進位轉義值或一個向後引用。如果\n之前至少n個獲取的子表達式，則n為向後引用。否則，如果n為八進位數字(0-7)，則n為一個八進位轉義值。  
\nm  
標識一個八進位轉義值或一個向後引用。如果\nm之前至少有nm個獲得子表達式，則nm為向後引用。如果\nm之前至少有n個獲取，則n為一個後跟文字m的向後引用。如果前面的條件都不滿足，若n和m均為八進位數字(0-7)，則\nm將匹配八進位轉義值nm。  
\nml  
如果n為八進位數字(0-3)，且m和l均為八進位數字(0-7)，則匹配八進位轉義值nml。  
\un  
匹配n，其中n是一個用四個十六進位數字表示的Unicode字元。例如，\u00A9匹配版權符號（©）。
```