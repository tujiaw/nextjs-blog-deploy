---
title: 'C++多态的实现原理'
date: '2017-10-24'
tags: ['C/C++']
draft: false
summary: 介绍 C++多态实现原理，用 virtual 申明虚函数，类有虚表和对象虚指针，多态分类和函数多态，虚函数结合动态绑定实现多态，虚表在构造函数中创建初始化，总结类有虚表等内容，还对比了早期绑定和迟绑定，及类和函数多态性差异。 
---

* 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。
* 存在虚函数的类都有一个一维的虚函数表叫做虚表。类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
* 多态性是一个接口多种实现，是面向对象的核心。分为类的多态性和函数的多态性。
* 多态用虚函数来实现，结合动态绑定。
* 纯虚函数是虚函数再加上= 0。
* 抽象类是指包括至少一个纯虚函数的类。

纯虚函数：virtual void breathe()=0；即抽象类！必须在子类实现这个函数!即先有名称，没内容，在派生类实现内容!  

我们先看一个例子：
```
#include <iostream.h>
class animal
{
public:
       void sleep()
       {
              cout<<"animal sleep"<<endl;
       }
       void breathe()
       {
              cout<<"animal breathe"<<endl;
       }
};
class fish:public animal
{
public:
       void breathe()
       {
              cout<<"fish bubble"<<endl;
       }
};
void main()
{
       fish fh;
       animal *pAn=&fh; // 隐式类型转换
       pAn->breathe();
}
```
注意，在例1-1的程序中没有定义虚函数。考虑一下例1-1的程序执行的结果是什么？

答案是输出：animal breathe

我们在main()函数中首先定义了一个fish类的对象fh，接着定义了一个指向animal类的指针变量pAn，将fh的地址赋给了指针变量pAn，然后利用该变量调用pAn->breathe()。许多学员往往将这种情况和C++的多态性搞混淆，认为fh实际上是fish类的对象，应该是调用fish类的breathe()，输出“fish bubble”，然后结果却不是这样。下面我们从两个方面来讲述原因。

# 编译的角度
C++编译器在编译的时候，要确定每个对象调用的函数（要求此函数是非虚函数）的地址，这称为早期绑定（early binding），当我们将fish类的对象fh的地址赋给pAn时，C++编译器进行了类型转换，此时C++编译器认为变量pAn保存的就是animal对象的地址。当在main()函数中执行pAn->breathe()时，调用的当然就是animal对象的breathe函数。

# 内存模型的角度
我们给出了fish对象内存模型，如下图所示：

![内存模型的角度](http://hi.csdn.net/attachment/201109/6/8605981_1315292911UuGl.jpg)

我们构造fish类的对象时，首先要调用animal类的构造函数去构造animal类的对象，然后才调用fish类的构造函数完成自身部分的构造，从而拼接出一个完整的fish对象。当我们将fish类的对象转换为animal类型时，该对象就被认为是原对象整个内存模型的上半部分，也就是图1-1中的“animal的对象所占内存”。那么当我们利用类型转换后的对象指针去调用它的方法时，当然也就是调用它所在的内存中的方法。因此，输出animal breathe，也就顺理成章了。

正如很多学员所想，在例1-1的程序中，我们知道pAn实际指向的是fish类的对象，我们希望输出的结果是鱼的呼吸方法，即调用fish类的breathe方法。这个时候，就该轮到虚函数登场了。

前面输出的结果是因为编译器在编译的时候，就已经确定了对象调用的函数的地址，要解决这个问题就要使用迟绑定（late binding）技术。当编译器使用迟绑定时，就会在运行时再去确定对象的类型以及正确的调用函数。而要让编译器采用迟绑定，就要在基类中声明函数时使用virtual关键字（注意，这是必须的，很多学员就是因为没有使用虚函数而写出很多错误的例子），这样的函数我们称为虚函数。一旦某个函数在基类中声明为virtual，那么在所有的派生类中该函数都是virtual，而不需要再显式地声明为virtual。

下面修改例1-1的代码，将animal类中的breathe()函数声明为virtual，如下：
```
#include <iostream.h>
class animal
{
public:
	void sleep()
	{
		cout<<"animal sleep"<<endl;
	}
	virtual void breathe()
	{
		cout<<"animal breathe"<<endl;
	}
};

class fish:public animal
{
public:
	void breathe()
	{
		cout<<"fish bubble"<<endl;
	}
};
void main()
{
	fish fh;
	animal *pAn=&fh; // 隐式类型转换
	pAn->breathe();
}
```

大家可以再次运行这个程序，你会发现结果是“fish bubble”，也就是根据对象的类型调用了正确的函数。

那么当我们将breathe()声明为virtual时，在背后发生了什么呢？

编译器在编译的时候，发现animal类中有虚函数，此时编译器会为每个包含虚函数的类创建一个虚表（即vtable），该表是一个一维数组，在这个数组中存放每个虚函数的地址。对于例1-2的程序，animal和fish类都包含了一个虚函数breathe()，因此编译器会为这两个类都建立一个虚表，（即使子类里面没有virtual函数，但是其父类里面有，所以子类中也有了）如下图所示:

![http://hi.csdn.net/attachment/201109/6/8605981_1315292914FCu0.jpg](http://hi.csdn.net/attachment/201109/6/8605981_1315292914FCu0.jpg)

那么如何定位虚表呢？编译器另外还为每个类的对象提供了一个虚表指针（即vptr），这个指针指向了对象所属类的虚表。在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向所属类的虚表，从而在调用虚函数时，就能够找到正确的函数。对于例1-2的程序，由于pAn实际指向的对象类型是fish，因此vptr指向的fish类的vtable，当调用pAn->breathe()时，根据虚表中的函数地址找到的就是fish类的breathe()函数。

正是由于每个对象调用的虚函数都是通过虚表指针来索引的，也就决定了虚表指针的正确初始化是非常重要的。换句话说，在虚表指针没有正确初始化之前，我们不能够去调用虚函数。那么虚表指针在什么时候，或者说在什么地方初始化呢？

答案是在构造函数中进行虚表的创建和虚表指针的初始化。还记得构造函数的调用顺序吗，在构造子类对象时，要先调用父类的构造函数，此时编译器只“看到了”父类，并不知道后面是否后还有继承者，它初始化父类对象的虚表指针，该虚表指针指向父类的虚表。当执行子类的构造函数时，子类对象的虚表指针被初始化，指向自身的虚表。对于例2-2的程序来说，当fish类的fh对象构造完毕后，其内部的虚表指针也就被初始化为指向fish类的虚表。在类型转换后，调用pAn->breathe()，由于pAn实际指向的是fish类的对象，该对象内部的虚表指针指向的是fish类的虚表，因此最终调用的是fish类的breathe()函数。

要注意：对于虚函数调用来说，每一个对象内部都有一个虚表指针，该虚表指针被初始化为本类的虚表。所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。

# 总结（基类有虚函数）
* 每一个类都有虚表。
* 虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。如果基类有3个虚函数，那么基类的虚表中就有三项（虚函数地址），派生类也会有虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现。如果派生类有自己的虚函数，那么虚表中就会添加该项
* 派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。

这就是C++中的多态性。当C++编译器在编译的时候，发现animal类的breathe()函数是虚函数，这个时候C++就会采用迟绑定（late binding）技术。也就是编译时并不确定具体调用的函数，而是在运行时，依据对象的类型（在程序中，我们传递的fish类对象的地址）来确认调用的是哪一个函数，这种能力就叫做C++的多态性。我们没有在breathe()函数前加virtual关键字时，C++编译器在编译时就确定了哪个函数被调用，这叫做早期绑定（early binding）。

C++的多态性是通过迟绑定技术来实现的。

C++的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

虚函数是在基类中定义的，目的是不确定它的派生类的具体行为。例：
* 定义一个基类：class Animal//动物。它的函数为breathe()//呼吸。
* 再定义一个类class Fish//鱼 。它的函数也为breathe()
* 再定义一个类class Sheep //羊。它的函数也为breathe()

为了简化代码，将Fish,Sheep定义成基类Animal的派生类。

然而Fish与Sheep的breathe不一样，一个是在水中通过水来呼吸，一个是直接呼吸空气。所以基类不能确定该如何定义breathe，所以在基类中只定义了一个virtual breathe,它是一个空的虚函数。具本的函数在子类中分别定义。程序一般运行时，找到类，如果它有基类，再找它的基类，最后运行的是基类中的函数，这时，它在基类中找到的是virtual标识的函数，它就会再回到子类中找同名函数。派生类也叫子类。基类也叫父类。这就是虚函数的产生，和类的多态性（breathe）的体现。

这里的多态性是指类的多态性。

函数的多态性是指一个函数被定义成多个不同参数的函数，它们一般被存在头文件中，当你调用这个函数，针对不同的参数，就会调用不同的同名函数。例：Rect（）//矩形。它的参数可以是两个坐标点（point，point)也可能是四个坐标(x1,y1,x2,y2)这叫函数的多态性与函数的重载。

类的多态性，是指用虚函数和延迟绑定来实现的。函数的多态性是函数的重载。

一般情况下（没有涉及virtual函数），当我们用一个指针/引用调用一个函数的时候，被调用的函数是取决于这个指针/引用的类型。即如果这个指针/引用是基类对象的指针/引用就调用基类的方法；如果指针/引用是派生类对象的指针/引用就调用派生类的方法，当然如果派生类中没有此方法，就会向上到基类里面去寻找相应的方法。这些调用在编译阶段就确定了。

当设计到多态性的时候，采用了虚函数和动态绑定，此时的调用就不会在编译时候确定而是在运行时确定。不在单独考虑指针/引用的类型而是看指针/引用的对象的类型来判断函数的调用，根据对象中虚指针指向的虚表中的函数的地址来确定调用哪个函数。

from: [http://hi.baidu.com/1021161795/blog/item/0ea7ea2ce518af414fc226ce.html](http://hi.baidu.com/1021161795/blog/item/0ea7ea2ce518af414fc226ce.html)