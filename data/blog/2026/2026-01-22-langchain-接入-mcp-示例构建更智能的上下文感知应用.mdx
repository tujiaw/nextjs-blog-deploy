---
title: "LangChain 接入 MCP 示例：构建更智能的上下文感知应用"
date: 2026-01-22
tags: ["AI", "LangChain", "MCP", "LLM", "Python", "Tutorial"]
summary: "本文详细介绍了如何在 LangChain 框架中集成 Model Context Protocol (MCP)，通过具体的代码示例展示如何构建能够动态获取和使用外部上下文的智能应用。"
draft: false
---

在构建基于大语言模型（LLM）的应用时，一个核心挑战是如何让模型访问和处理超出其训练数据或有限上下文窗口的信息。传统的检索增强生成（RAG）模式虽然有效，但在处理动态、多源或结构化数据时，其上下文管理和更新机制往往显得笨重。Model Context Protocol (MCP) 的出现，为这一问题提供了优雅的解决方案。本文将带你了解 MCP 的核心概念，并手把手教你如何在流行的 LangChain 框架中集成 MCP，构建更强大、更灵活的 AI 应用。

## 什么是 Model Context Protocol (MCP)？

Model Context Protocol (MCP) 是一种开放协议，旨在标准化 LLM 应用与外部数据源和工具之间的交互方式。你可以把它想象成 LLM 世界的“USB 协议”——它定义了一套通用接口，让任何兼容 MCP 的服务器（提供数据或工具）都能轻松地被任何兼容 MCP 的客户端（如 LangChain 应用）发现和使用。

### MCP 的核心优势

1.  **标准化与互操作性**：统一了上下文获取的接口，开发者无需为每个数据源编写特定的集成代码。
2.  **动态上下文管理**：支持按需、实时地从多个源头获取上下文，而非一次性加载所有可能用到的数据。
3.  **工具与数据统一抽象**：无论是查询数据库、调用 API 还是执行计算，在 MCP 中都被抽象为“工具”（Tools），简化了应用逻辑。
4.  **提升应用性能与准确性**：通过精准提供相关上下文，减少了无关信息的干扰，提升了 LLM 响应的质量和效率。

## LangChain 框架简介

LangChain 是一个用于开发由语言模型驱动的应用程序的框架。它通过提供一套模块化的抽象（如链 Chains、代理 Agents、检索器 Retrievers 等）和丰富的集成库，极大地简化了构建复杂 LLM 应用的过程。其核心思想是“组合”，让开发者能够像搭积木一样构建应用流程。

## 在 LangChain 中集成 MCP

LangChain 通过 `langchain-mcp-adapters` 包原生支持 MCP。集成过程主要分为三步：1) 连接 MCP 服务器；2) 将 MCP 工具暴露给 LangChain；3) 在链或代理中使用这些工具。

### 环境准备

首先，确保你已安装必要的 Python 包。

```bash
pip install langchain langchain-mcp-adapters langchain-openai
```

此外，你还需要一个 MCP 服务器。为了演示，我们可以使用一个简单的示例服务器，或者连接到一个现有的公共服务器（如提供天气、股票信息的服务器）。本文假设我们使用一个本地的“文件系统阅读器” MCP 服务器，它允许 LLM 读取指定目录下的文件内容。

### 步骤 1：启动并连接 MCP 服务器

通常，MCP 服务器作为一个独立的进程运行。我们可以通过子进程启动它，或者连接到网络上的一个服务器端点。

```python
import asyncio
from langchain_mcp_adapters.client import MCPClient
from langchain_mcp_adapters.server import MCPServer

# 假设我们有一个本地的 MCP 服务器（例如，一个文件系统工具服务器）
# 这里我们演示如何通过适配器客户端进行连接。
# 在实际场景中，你可能通过 stdio 或 HTTP 连接到服务器。

async def create_mcp_client():
    # 方法A：连接到通过 stdio 通信的本地服务器进程（常见模式）
    # 这通常需要配置服务器的启动命令
    # server = MCPServer(server_command=["python", "path/to/your/mcp_server.py"])
    # client = await server.connect()

    # 方法B：对于本教程，我们使用一个模拟的客户端来演示
    # 真实集成时，请替换为实际的连接逻辑
    from langchain_mcp_adapters.tools import load_tools_from_mcp_server
    # 假设我们有一个运行在 http://localhost:8000 的 MCP 服务器
    tools = await load_tools_from_mcp_server(
        server_type="http",
        url="http://localhost:8000/sse", # 或 /sse 端点用于 Server-Sent Events
        # 如果服务器需要认证，可以添加 headers
        # headers={"Authorization": "Bearer YOUR_TOKEN"}
    )
    return tools

# 注意：上面的 `load_tools_from_mcp_server` 是一个示意函数。
# 在 LangChain 的最新实践中，连接方式可能更简化。
# 一个更直接且常见的模式是通过 `MCPClient` 建立连接：
```

让我们看一个更具体、假设性的连接示例。假设我们使用一个名为 `mcp-server-filesystem` 的第三方服务器。

```python
import subprocess
import time
from langchain_mcp_adapters.client import MCPClient

def start_and_connect_mcp_server():
    # 1. 启动 MCP 服务器进程（例如，一个提供文件读取和搜索的工具）
    # 这里 server_command 需要根据你实际使用的 MCP 服务器来调整
    server_process = subprocess.Popen(
        ["npx", "-y", "@modelcontextprotocol/server-filesystem", "/path/to/data/dir"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )
    # 给服务器一点启动时间
    time.sleep(2)

    # 2. 通过 stdio 连接到服务器
    # MCPClient 可以封装 stdio 通信
    client = MCPClient(server_process)
    return client, server_process

# 在实际异步环境中使用
async def main():
    client, process = start_and_connect_mcp_server()
    try:
        # 获取服务器提供的工具列表
        tools = await client.list_tools()
        print(f"可用的 MCP 工具: {[t.name for t in tools]}")
        # ... 后续使用这些工具
    finally:
        process.terminate()
```

### 步骤 2：将 MCP 工具转换为 LangChain 工具

一旦连接到 MCP 客户端，我们就可以将其提供的工具转换为 LangChain 的 `Tool` 对象，以便在链或代理中使用。

```python
from langchain.agents import Tool
from langchain_mcp_adapters.tools import convert_to_langchain_tool

async def setup_langchain_tools(mcp_client):
    # 从 MCP 客户端获取原始工具定义
    mcp_tools = await mcp_client.list_tools()
    
    langchain_tools = []
    for mcp_tool in mcp_tools:
        # 将每个 MCP 工具转换为 LangChain 工具
        lc_tool = convert_to_langchain_tool(
            mcp_tool,
            mcp_client # 传递客户端，用于实际执行工具调用
        )
        langchain_tools.append(lc_tool)
    
    return langchain_tools

# 假设我们有两个工具：`read_file` 和 `search_files`
# 转换后，它们在 LangChain 中就可以像普通工具一样被调用了。
```

### 步骤 3：在 LangChain 代理中使用 MCP 工具

现在，我们可以将这些工具赋予一个 LangChain 代理，让 LLM 自主决定何时以及如何使用这些工具来获取上下文。

```python
from langchain_openai import ChatOpenAI
from langchain.agents import initialize_agent, AgentType

async def create_mcp_enhanced_agent():
    # 1. 连接 MCP 服务器并获取工具
    mcp_client, process = start_and_connect_mcp_server()
    tools = await setup_langchain_tools(mcp_client)
    
    # 2. 初始化 LLM
    llm = ChatOpenAI(model="gpt-4o", temperature=0, openai_api_key="your-api-key")
    
    # 3. 创建代理
    agent = initialize_agent(
        tools,
        llm,
        agent=AgentType.OPENAI_FUNCTIONS, # 或 AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION
        verbose=True,
        handle_parsing_errors=True # 优雅地处理解析错误
    )
    
    return agent, process

# 使用代理
async def run_agent_example():
    agent, server_process = await create_mcp_enhanced_agent()
    try:
        response = await agent.ainvoke({
            "input": "请总结 `/path/to/data/dir` 目录下 `project_plan.md` 文件的主要内容，并告诉我其中提到的下一个截止日期是什么？"
        })
        print("Agent 响应:", response['output'])
    finally:
        server_process.terminate()

# 运行示例
import asyncio
asyncio.run(run_agent_example())
```

当代理运行时，LLM 会分析用户问题，识别出需要读取文件内容，于是自动调用 `read_file` 工具获取 `project_plan.md` 的文本，然后基于该上下文生成总结和答案。这一切对最终用户都是透明的。

## 实际应用场景与最佳实践

1.  **企业知识库问答**：部署多个 MCP 服务器，分别连接 Confluence、Notion、公司 Wiki、内部数据库。LangChain 代理可以动态选择最相关的源获取信息，回答员工问题。
2.  **动态数据分析**：MCP 服务器封装 SQL 查询或 API 调用。用户可以用自然语言提问，如“上季度华东区的销售额是多少？”，代理通过 MCP 工具查询数据库后给出答案。
3.  **代码库分析与操作**：使用类似 `MCP GitHub` 或 `MCP Filesystem` 的服务器，让 LLM 能够阅读代码、检索函数定义、甚至根据指令创建或修改文件（在安全约束下）。

**最佳实践：**
*   **工具描述清晰**：确保 MCP 服务器为每个工具提供准确、详细的描述，帮助 LLM 正确理解其用途。
*   **错误处理**：在 LangChain 端实现 robust 的错误处理，当 MCP 服务器不可用或工具调用失败时，提供友好的 fallback 响应。
*   **安全性**：严格控制 MCP 服务器的权限。例如，文件系统服务器应仅限于访问特定的安全目录。对工具调用进行验证和过滤。
*   **性能优化**：对于耗时较长的工具调用（如复杂查询），考虑实现异步或超时机制，避免阻塞应用主线程。

## 常见问题解答 (FAQ)

**Q1: MCP 和传统的 LangChain Tool 或 Retriever 有什么区别？**
A1: 传统 Tool/Retriever 是紧耦合在应用代码中的。MCP 将其标准化和外部化，使数据/工具提供者（服务器）与消费者（客户端应用）解耦。这意味着你可以独立更新、扩展或替换 MCP 服务器，而无需修改 LangChain 应用代码。

**Q2: 我需要自己编写 MCP 服务器吗？**
A2: 不一定。社区已经提供了许多开源的 MCP 服务器，用于连接 PostgreSQL、MySQL、Slack、Google Drive、文件系统等。你可以直接使用它们。只有当你有特殊的数据源或工具需求时，才需要自己实现。

**Q3: MCP 适合所有 LangChain 应用吗？**
A3: 对于简单、上下文固定的应用，直接使用 LangChain 内置组件可能更简单。但对于需要处理动态、多源、复杂上下文的应用，MCP 能显著提升架构的清晰度和可维护性。

**Q4: 生产环境中如何管理 MCP 服务器？**
A4: 建议将 MCP 服务器作为独立的微服务或容器进行部署和管理。使用进程管理工具（如 systemd, Docker Compose, Kubernetes）来确保其可用性。LangChain 应用通过配置好的网络端点（HTTP/SSE）或标准输入输出流与其通信。

## 总结

通过将 Model Context Protocol (MCP) 集成到 LangChain 中，我们为 LLM 应用打开了一扇通往广阔、动态外部世界的大门。这种集成不仅标准化了上下文获取流程，还带来了前所未有的灵活性和可扩展性。本文提供的示例为你搭建了一个起点，你可以在此基础上，探索连接更多类型的 MCP 服务器，构建出能够理解并操作真实世界数据的下一代智能应用。记住，关键在于设计好工具的描述和权限控制，让 LLM 在安全的范围内，最大限度地发挥其推理和规划能力。