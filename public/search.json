[{"title":"掌握提示工程与功能测试：确保可靠的LLM输出","date":"2025-03-25T00:00:00.000Z","tags":["LLM","AI","Prompt"],"draft":false,"summary":"如何通过包含输入/输出数据集的功能测试，以系统化方法评估提示，使复杂人工智能任务的提示工程更加可靠。  \r","type":"Blog","readingTime":{"text":"25 min read","minutes":24.515,"time":1470900,"words":4903},"slug":"2025/掌握提示工程与功能测试","path":"blog/2025/掌握提示工程与功能测试","filePath":"blog/2025/掌握提示工程与功能测试.mdx","toc":[{"value":"在提示优化中平衡精确性和一致性","url":"#在提示优化中平衡精确性和一致性","depth":2},{"value":"从实验室到人工智能：为什么测试LLM响应需要多次迭代","url":"#从实验室到人工智能为什么测试llm响应需要多次迭代","depth":2},{"value":"系统化方法：提示优化的功能测试","url":"#系统化方法提示优化的功能测试","depth":2},{"value":"1. 数据集","url":"#1-数据集","depth":3},{"value":"2. 自动化测试验证","url":"#2-自动化测试验证","depth":3},{"value":"3. 多次迭代","url":"#3-多次迭代","depth":3},{"value":"4. 算法评分","url":"#4-算法评分","depth":3},{"value":"第一步：定义测试数据集","url":"#第一步定义测试数据集","depth":2},{"value":"第二步：运行自动化测试","url":"#第二步运行自动化测试","depth":2},{"value":"执行流程","url":"#执行流程","depth":3},{"value":"示例：从文章中删除作者签名","url":"#示例从文章中删除作者签名","depth":2},{"value":"验证流程","url":"#验证流程","depth":3},{"value":"这种方法的优势","url":"#这种方法的优势","depth":2},{"value":"系统化提示测试：超越提示优化","url":"#系统化提示测试超越提示优化","depth":1},{"value":"1. 模型比较","url":"#1-模型比较","depth":2},{"value":"2. 版本升级","url":"#2-版本升级","depth":2},{"value":"3. 成本优化","url":"#3-成本优化","depth":2},{"value":"克服挑战","url":"#克服挑战","depth":2},{"value":"优缺点总结","url":"#优缺点总结","depth":2},{"value":"关键优势","url":"#关键优势","depth":3},{"value":"挑战","url":"#挑战","depth":3},{"value":"结论：何时应实施这种方法？","url":"#结论何时应实施这种方法","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"掌握提示工程与功能测试：确保可靠的LLM输出","datePublished":"2025-03-25T00:00:00.000Z","dateModified":"2025-03-25T00:00:00.000Z","description":"如何通过包含输入/输出数据集的功能测试，以系统化方法评估提示，使复杂人工智能任务的提示工程更加可靠。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/掌握提示工程与功能测试"}},{"title":"面向AI开发经验总结","date":"2025-03-25T00:00:00.000Z","tags":["AI","LLM"],"draft":false,"summary":"总结在AI驱动开发过程中的经验和最佳实践，包括如何更好地利用AI助手进行开发\r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.225,"time":253500,"words":845},"slug":"2025/面向AI开发经验总结","path":"blog/2025/面向AI开发经验总结","filePath":"blog/2025/面向AI开发经验总结.mdx","toc":[{"value":"面向AI开发经验总结","url":"#面向ai开发经验总结","depth":1},{"value":"1- 从结构开始，而不是代码","url":"#1--从结构开始而不是代码","depth":1},{"value":"2- Ask、Edit、Agent","url":"#2--askeditagent","depth":1},{"value":"3- 根据进展定制你的AI","url":"#3--根据进展定制你的ai","depth":1},{"value":"4- 分解复杂问题","url":"#4--分解复杂问题","depth":1},{"value":"5- 编码前先头脑风暴","url":"#5--编码前先头脑风暴","depth":1},{"value":"6- 文件命名和模块化很重要","url":"#6--文件命名和模块化很重要","depth":1},{"value":"7- 始终编写测试","url":"#7--始终编写测试","depth":1},{"value":"8- 经常提交！","url":"#8--经常提交","depth":1},{"value":"9- 保持聊天聚焦","url":"#9--保持聊天聚焦","depth":1},{"value":"10- 不要仅仅接受能工作的代码","url":"#10--不要仅仅接受能工作的代码","depth":1},{"value":"11- AI在新技术上会困难","url":"#11--ai在新技术上会困难","depth":1},{"value":"12- 摆脱困境","url":"#12--摆脱困境","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"面向AI开发经验总结","datePublished":"2025-03-25T00:00:00.000Z","dateModified":"2025-03-25T00:00:00.000Z","description":"总结在AI驱动开发过程中的经验和最佳实践，包括如何更好地利用AI助手进行开发\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/面向AI开发经验总结"}},{"title":"LLM前沿动态追踪指南","date":"2025-03-24T00:00:00.000Z","tags":["LLM","AI"],"draft":false,"summary":"本文提供了跟踪大语言模型(LLM)最新发展和趋势的全面资源导航，包括研究论文、技术博客、行业动态、社区讨论和开发工具等。帮助读者在快速发展的AI时代保持信息更新，紧跟前沿技术潮流，不错过LLM领域的关键进展。\r","type":"Blog","readingTime":{"text":"9 min read","minutes":8.09,"time":485400,"words":1618},"slug":"2025/llm-follow","path":"blog/2025/llm-follow","filePath":"blog/2025/llm-follow.mdx","toc":[{"value":"研究动态","url":"#研究动态","depth":2},{"value":"论文预印本平台","url":"#论文预印本平台","depth":3},{"value":"顶级会议论文","url":"#顶级会议论文","depth":3},{"value":"研究机构动态","url":"#研究机构动态","depth":3},{"value":"行业新闻","url":"#行业新闻","depth":2},{"value":"专业科技媒体","url":"#专业科技媒体","depth":3},{"value":"行业通讯","url":"#行业通讯","depth":3},{"value":"技术博客","url":"#技术博客","depth":2},{"value":"公司技术博客","url":"#公司技术博客","depth":3},{"value":"个人技术博客","url":"#个人技术博客","depth":3},{"value":"模型发布","url":"#模型发布","depth":2},{"value":"模型发布平台","url":"#模型发布平台","depth":3},{"value":"模型监测","url":"#模型监测","depth":3},{"value":"开发者社区","url":"#开发者社区","depth":2},{"value":"论坛和社区","url":"#论坛和社区","depth":3},{"value":"开源项目追踪","url":"#开源项目追踪","depth":3},{"value":"学习资源","url":"#学习资源","depth":2},{"value":"教程和课程","url":"#教程和课程","depth":3},{"value":"YouTube频道","url":"#youtube频道","depth":3},{"value":"前沿应用","url":"#前沿应用","depth":2},{"value":"LLM应用案例","url":"#llm应用案例","depth":3},{"value":"创新项目跟踪","url":"#创新项目跟踪","depth":3},{"value":"行业分析","url":"#行业分析","depth":2},{"value":"研究报告","url":"#研究报告","depth":3},{"value":"趋势分析","url":"#趋势分析","depth":3},{"value":"伦理与治理","url":"#伦理与治理","depth":2},{"value":"伦理研究与政策","url":"#伦理研究与政策","depth":3},{"value":"重要论文和报告","url":"#重要论文和报告","depth":3},{"value":"投资趋势","url":"#投资趋势","depth":2},{"value":"投资动态","url":"#投资动态","depth":3},{"value":"创业与创新","url":"#创业与创新","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"LLM前沿动态追踪指南","datePublished":"2025-03-24T00:00:00.000Z","dateModified":"2025-03-24T00:00:00.000Z","description":"本文提供了跟踪大语言模型(LLM)最新发展和趋势的全面资源导航，包括研究论文、技术博客、行业动态、社区讨论和开发工具等。帮助读者在快速发展的AI时代保持信息更新，紧跟前沿技术潮流，不错过LLM领域的关键进展。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/llm-follow"}},{"title":"Cursor新手教程：最佳实践指南","date":"2025-03-23T00:00:00.000Z","tags":["AI","LLM","Tools"],"draft":false,"summary":"这份指南提供了使用AI代码编辑器Cursor的实用技巧，帮助你更高效地构建应用程序，无论你是初学者还是有经验的开发者。\r","type":"Blog","readingTime":{"text":"7 min read","minutes":6.25,"time":375000,"words":1250},"slug":"2025/Cursor新手教程","path":"blog/2025/Cursor新手教程","filePath":"blog/2025/Cursor新手教程.mdx","toc":[{"value":"1. Cursor简介","url":"#1-cursor简介","depth":2},{"value":"2. 设置Cursor","url":"#2-设置cursor","depth":2},{"value":"3. 基本快捷键和命令","url":"#3-基本快捷键和命令","depth":2},{"value":"4. 编写清晰有效的提示","url":"#4-编写清晰有效的提示","depth":2},{"value":"5. 测试和调试AI生成的代码","url":"#5-测试和调试ai生成的代码","depth":2},{"value":"6. 管理AI上下文和记忆","url":"#6-管理ai上下文和记忆","depth":2},{"value":"高级主题","url":"#高级主题","depth":2},{"value":"7. 版本控制和AI辅助提交","url":"#7-版本控制和ai辅助提交","depth":2},{"value":"8. 明确的项目需求","url":"#8-明确的项目需求","depth":2},{"value":"9. 错误解决策略","url":"#9-错误解决策略","depth":2},{"value":"10. 长期项目的最佳实践","url":"#10-长期项目的最佳实践","depth":2},{"value":"总结","url":"#总结","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cursor新手教程：最佳实践指南","datePublished":"2025-03-23T00:00:00.000Z","dateModified":"2025-03-23T00:00:00.000Z","description":"这份指南提供了使用AI代码编辑器Cursor的实用技巧，帮助你更高效地构建应用程序，无论你是初学者还是有经验的开发者。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/Cursor新手教程"}},{"title":"我们应该怎样使用AI编程工具","date":"2025-03-23T00:00:00.000Z","tags":["AI","LLM"],"draft":false,"summary":"AI工具不仅改变了工程师的工作方式，还使更多人能够构建应用和网站。本文深入探讨了三类主要AI编程工具：通用AI聊天机器人、AI集成IDE助手和基于Web的应用生成器，分析它们的优缺点及实际应用案例，展示它们如何推动开发者生产力的新浪潮。\r","type":"Blog","readingTime":{"text":"11 min read","minutes":10.625,"time":637500,"words":2125},"slug":"2025/我们应该怎样使用AI编程工具","path":"blog/2025/我们应该怎样使用AI编程工具","filePath":"blog/2025/我们应该怎样使用AI编程工具.mdx","toc":[{"value":"通用AI聊天机器人","url":"#通用ai聊天机器人","depth":2},{"value":"AI集成IDE助手","url":"#ai集成ide助手","depth":2},{"value":"基于Web的应用生成器","url":"#基于web的应用生成器","depth":2},{"value":"最终思考","url":"#最终思考","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"我们应该怎样使用AI编程工具","datePublished":"2025-03-23T00:00:00.000Z","dateModified":"2025-03-23T00:00:00.000Z","description":"AI工具不仅改变了工程师的工作方式，还使更多人能够构建应用和网站。本文深入探讨了三类主要AI编程工具：通用AI聊天机器人、AI集成IDE助手和基于Web的应用生成器，分析它们的优缺点及实际应用案例，展示它们如何推动开发者生产力的新浪潮。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/我们应该怎样使用AI编程工具"}},{"title":"Python 包管理工具对比","date":"2025-03-19T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"本文对Python生态中的各种包管理工具如pip、pipenv、conda、poetry、pdm、pip-tools、pyenv和uv进行了全面对比，帮助开发者选择最适合其项目需求的工具。\r","type":"Blog","readingTime":{"text":"29 min read","minutes":28.435,"time":1706100,"words":5687},"slug":"2025/Python 包管理工具对比","path":"blog/2025/Python 包管理工具对比","filePath":"blog/2025/Python 包管理工具对比.mdx","toc":[{"value":"Table of Contents","url":"#table-of-contents","depth":2},{"value":"Python包管理工具对比","url":"#python包管理工具对比","depth":2},{"value":"依赖管理与锁定机制","url":"#依赖管理与锁定机制","depth":3},{"value":"虚拟环境管理","url":"#虚拟环境管理","depth":3},{"value":"包发布与私有仓库支持","url":"#包发布与私有仓库支持","depth":3},{"value":"性能与效率","url":"#性能与效率","depth":3},{"value":"社区支持与发展趋势","url":"#社区支持与发展趋势","depth":3},{"value":"uv：新一代高性能包管理工具","url":"#uv新一代高性能包管理工具","depth":3},{"value":"主要特点","url":"#主要特点","depth":4},{"value":"使用场景","url":"#使用场景","depth":4},{"value":"与其他工具的比较","url":"#与其他工具的比较","depth":4},{"value":"Pip 和 Pipenv 的功能和使用场景","url":"#pip-和-pipenv-的功能和使用场景","depth":2},{"value":"包管理功能","url":"#包管理功能","depth":3},{"value":"依赖解析和锁定机制","url":"#依赖解析和锁定机制","depth":3},{"value":"虚拟环境管理","url":"#虚拟环境管理-1","depth":3},{"value":"开发与生产环境的区分","url":"#开发与生产环境的区分","depth":3},{"value":"使用场景","url":"#使用场景-1","depth":3},{"value":"与 Docker 的结合","url":"#与-docker-的结合","depth":3},{"value":"结论","url":"#结论","depth":3},{"value":"虚拟环境与依赖管理","url":"#虚拟环境与依赖管理","depth":2},{"value":"虚拟环境的作用与重要性","url":"#虚拟环境的作用与重要性","depth":3},{"value":"虚拟环境的创建与管理工具","url":"#虚拟环境的创建与管理工具","depth":3},{"value":"依赖管理与版本控制","url":"#依赖管理与版本控制","depth":3},{"value":"依赖冲突的解决","url":"#依赖冲突的解决","depth":3},{"value":"高级依赖管理工具","url":"#高级依赖管理工具","depth":3},{"value":"Conclusion","url":"#conclusion","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 包管理工具对比","datePublished":"2025-03-19T00:00:00.000Z","dateModified":"2025-03-19T00:00:00.000Z","description":"本文对Python生态中的各种包管理工具如pip、pipenv、conda、poetry、pdm、pip-tools、pyenv和uv进行了全面对比，帮助开发者选择最适合其项目需求的工具。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/Python 包管理工具对比"}},{"title":"Python性能飙升的异步编程方法","date":"2025-03-19T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"本文深入探讨Python异步编程的原理和方法，展示如何通过asyncio库处理I/O密集型任务，显著提升应用性能，包含实用案例和最佳实践。\r","type":"Blog","readingTime":{"text":"8 min read","minutes":7.3,"time":438000,"words":1460},"slug":"2025/Python性能飙升的异步编程方法","path":"blog/2025/Python性能飙升的异步编程方法","filePath":"blog/2025/Python性能飙升的异步编程方法.mdx","toc":[{"value":"引言","url":"#引言","depth":2},{"value":"异步编程的基本概念","url":"#异步编程的基本概念","depth":2},{"value":"Python中的异步编程","url":"#python中的异步编程","depth":3},{"value":"协程","url":"#协程","depth":4},{"value":"事件循环","url":"#事件循环","depth":4},{"value":"异步编程的性能优势","url":"#异步编程的性能优势","depth":2},{"value":"性能测试与比较","url":"#性能测试与比较","depth":3},{"value":"异步编程的应用场景","url":"#异步编程的应用场景","depth":2},{"value":"网络编程","url":"#网络编程","depth":3},{"value":"数据处理","url":"#数据处理","depth":3},{"value":"GUI应用","url":"#gui应用","depth":3},{"value":"异步编程的挑战与解决方案","url":"#异步编程的挑战与解决方案","depth":2},{"value":"代码复杂性","url":"#代码复杂性","depth":3},{"value":"调试难度","url":"#调试难度","depth":3},{"value":"未来的发展趋势","url":"#未来的发展趋势","depth":2},{"value":"新特性与改进","url":"#新特性与改进","depth":3},{"value":"异步编程的普及","url":"#异步编程的普及","depth":3},{"value":"结论","url":"#结论","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python性能飙升的异步编程方法","datePublished":"2025-03-19T00:00:00.000Z","dateModified":"2025-03-19T00:00:00.000Z","description":"本文深入探讨Python异步编程的原理和方法，展示如何通过asyncio库处理I/O密集型任务，显著提升应用性能，包含实用案例和最佳实践。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/Python性能飙升的异步编程方法"}},{"title":"RAG技术实现原理","date":"2025-03-19T00:00:00.000Z","tags":["LLM","RAG"],"draft":false,"summary":"本文详细解析检索增强生成(RAG)技术的工作原理、架构组成和应用场景，介绍如何结合信息检索与生成模型提升大语言模型在知识密集型任务中的表现。\r","type":"Blog","readingTime":{"text":"26 min read","minutes":25.375,"time":1522500,"words":5075},"slug":"2025/RAG技术实现原理","path":"blog/2025/RAG技术实现原理","filePath":"blog/2025/RAG技术实现原理.mdx","toc":[{"value":"Table of Contents","url":"#table-of-contents","depth":2},{"value":"RAG技术介绍","url":"#rag技术介绍","depth":2},{"value":"检索增强生成（RAG）的基本概念","url":"#检索增强生成rag的基本概念","depth":3},{"value":"RAG的架构组成","url":"#rag的架构组成","depth":3},{"value":"检索器（Retriever）","url":"#检索器retriever","depth":4},{"value":"生成器（Generator）","url":"#生成器generator","depth":4},{"value":"增强模块（Augmentation Component）","url":"#增强模块augmentation-component","depth":4},{"value":"RAG的应用场景","url":"#rag的应用场景","depth":3},{"value":"智能客服","url":"#智能客服","depth":4},{"value":"知识问答系统","url":"#知识问答系统","depth":4},{"value":"内容生成","url":"#内容生成","depth":4},{"value":"多模态应用","url":"#多模态应用","depth":4},{"value":"RAG的技术挑战与改进方向","url":"#rag的技术挑战与改进方向","depth":3},{"value":"检索质量","url":"#检索质量","depth":4},{"value":"知识库覆盖范围","url":"#知识库覆盖范围","depth":4},{"value":"计算成本","url":"#计算成本","depth":4},{"value":"RAG的未来发展","url":"#rag的未来发展","depth":3},{"value":"RAG技术实现原理","url":"#rag技术实现原理","depth":2},{"value":"数据预处理与向量化","url":"#数据预处理与向量化","depth":3},{"value":"向量数据库的选择与优化","url":"#向量数据库的选择与优化","depth":3},{"value":"查询增强与优化","url":"#查询增强与优化","depth":3},{"value":"增强模块的集成与优化","url":"#增强模块的集成与优化","depth":3},{"value":"实时数据加载与更新","url":"#实时数据加载与更新","depth":3},{"value":"系统监控与性能优化","url":"#系统监控与性能优化","depth":3},{"value":"RAG在实际应用中的挑战与解决方案","url":"#rag在实际应用中的挑战与解决方案","depth":2},{"value":"数据隐私与安全性","url":"#数据隐私与安全性","depth":3},{"value":"检索与生成的准确性","url":"#检索与生成的准确性","depth":3},{"value":"系统性能与计算成本","url":"#系统性能与计算成本","depth":3},{"value":"多模态数据处理","url":"#多模态数据处理","depth":3},{"value":"用户体验与系统可解释性","url":"#用户体验与系统可解释性","depth":3},{"value":"实时性与动态更新","url":"#实时性与动态更新","depth":3},{"value":"Conclusion","url":"#conclusion","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"RAG技术实现原理","datePublished":"2025-03-19T00:00:00.000Z","dateModified":"2025-03-19T00:00:00.000Z","description":"本文详细解析检索增强生成(RAG)技术的工作原理、架构组成和应用场景，介绍如何结合信息检索与生成模型提升大语言模型在知识密集型任务中的表现。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/RAG技术实现原理"}},{"title":"软件开发中经常使用的代理或源设置方法","date":"2025-03-19T00:00:00.000Z","tags":["tools"],"draft":false,"summary":"本文全面介绍软件开发中常用的各种代理和源设置方法，涵盖HTTP、Git、pip、npm、apt、Go和Docker等平台，帮助开发者在受限网络环境中高效工作。\r","type":"Blog","readingTime":{"text":"15 min read","minutes":14.28,"time":856800,"words":2856},"slug":"2025/开发中的各种代理设置","path":"blog/2025/开发中的各种代理设置","filePath":"blog/2025/开发中的各种代理设置.mdx","toc":[{"value":"目录","url":"#目录","depth":2},{"value":"代理配置基础知识","url":"#代理配置基础知识","depth":2},{"value":"版本控制工具","url":"#版本控制工具","depth":2},{"value":"Git 代理配置","url":"#git-代理配置","depth":3},{"value":"基本配置","url":"#基本配置","depth":4},{"value":"高级配置","url":"#高级配置","depth":4},{"value":"包管理器","url":"#包管理器","depth":2},{"value":"Python (pip) 配置","url":"#python-pip-配置","depth":3},{"value":"基本配置与国内镜像","url":"#基本配置与国内镜像","depth":4},{"value":"高级配置","url":"#高级配置-1","depth":4},{"value":"常见问题排查","url":"#常见问题排查","depth":4},{"value":"Node.js (npm) 配置","url":"#nodejs-npm-配置","depth":3},{"value":"基本配置与国内镜像","url":"#基本配置与国内镜像-1","depth":4},{"value":"高级配置","url":"#高级配置-2","depth":4},{"value":"安全处理代理认证","url":"#安全处理代理认证","depth":4},{"value":"Linux (apt) 配置","url":"#linux-apt-配置","depth":3},{"value":"基本配置与国内镜像","url":"#基本配置与国内镜像-2","depth":4},{"value":"高级配置","url":"#高级配置-3","depth":4},{"value":"Go 模块配置","url":"#go-模块配置","depth":3},{"value":"基本配置与国内镜像","url":"#基本配置与国内镜像-3","depth":4},{"value":"高级配置","url":"#高级配置-4","depth":4},{"value":"Java (Maven/Gradle) 配置","url":"#java-mavengradle-配置","depth":3},{"value":"Maven 配置","url":"#maven-配置","depth":4},{"value":"Gradle 配置","url":"#gradle-配置","depth":4},{"value":"PHP (Composer) 配置","url":"#php-composer-配置","depth":3},{"value":"Ruby (RubyGems) 配置","url":"#ruby-rubygems-配置","depth":3},{"value":"容器化工具","url":"#容器化工具","depth":2},{"value":"Docker 代理配置","url":"#docker-代理配置","depth":3},{"value":"基本配置与国内镜像","url":"#基本配置与国内镜像-4","depth":4},{"value":"Docker 守护进程代理配置","url":"#docker-守护进程代理配置","depth":4},{"value":"Docker 容器代理配置","url":"#docker-容器代理配置","depth":4},{"value":"代理配置最佳实践","url":"#代理配置最佳实践","depth":2},{"value":"故障排查指南","url":"#故障排查指南","depth":2},{"value":"常见问题及解决方案","url":"#常见问题及解决方案","depth":3},{"value":"网络诊断工具","url":"#网络诊断工具","depth":3},{"value":"安全性考虑","url":"#安全性考虑","depth":2},{"value":"总结","url":"#总结","depth":2},{"value":"参考文献","url":"#参考文献","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"软件开发中经常使用的代理或源设置方法","datePublished":"2025-03-19T00:00:00.000Z","dateModified":"2025-03-19T00:00:00.000Z","description":"本文全面介绍软件开发中常用的各种代理和源设置方法，涵盖HTTP、Git、pip、npm、apt、Go和Docker等平台，帮助开发者在受限网络环境中高效工作。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/开发中的各种代理设置"}},{"title":"提示工程终极指南：从入门到精通","date":"2025-03-19T00:00:00.000Z","tags":["AI","LLM"],"draft":false,"summary":"本文提供全面的提示工程指南，从基础概念到高级策略，帮助读者掌握与AI大模型有效沟通的技巧，提高对话效率和结果质量。\r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.5,"time":270000,"words":900},"slug":"2025/提示工程实用指南","path":"blog/2025/提示工程实用指南","filePath":"blog/2025/提示工程实用指南.mdx","toc":[{"value":"目录","url":"#目录","depth":2},{"value":"什么是提示工程？","url":"#什么是提示工程","depth":2},{"value":"核心原则","url":"#核心原则","depth":2},{"value":"1. 明确性至上","url":"#1-明确性至上","depth":3},{"value":"2. 结构化思维","url":"#2-结构化思维","depth":3},{"value":"3. 动态迭代","url":"#3-动态迭代","depth":3},{"value":"实用技巧","url":"#实用技巧","depth":2},{"value":"魔法关键词","url":"#魔法关键词","depth":3},{"value":"格式控制","url":"#格式控制","depth":3},{"value":"参数调节","url":"#参数调节","depth":3},{"value":"常见错误","url":"#常见错误","depth":2},{"value":"高级策略","url":"#高级策略","depth":2},{"value":"元提示工程","url":"#元提示工程","depth":3},{"value":"混合模式","url":"#混合模式","depth":3},{"value":"防御性设计","url":"#防御性设计","depth":3},{"value":"工具推荐","url":"#工具推荐","depth":2},{"value":"延伸阅读","url":"#延伸阅读","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"提示工程终极指南：从入门到精通","datePublished":"2025-03-19T00:00:00.000Z","dateModified":"2025-03-19T00:00:00.000Z","description":"本文提供全面的提示工程指南，从基础概念到高级策略，帮助读者掌握与AI大模型有效沟通的技巧，提高对话效率和结果质量。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/提示工程实用指南"}},{"title":"Python asyncio 入门到精通","date":"2025-03-18T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"本文全面介绍Python asyncio库的基本概念、使用方法及最佳实践，从入门到精通，帮助开发者充分利用异步编程提升I/O密集型应用的性能。\r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.6,"time":336000,"words":1120},"slug":"2025/Python asyncio使用方法","path":"blog/2025/Python asyncio使用方法","filePath":"blog/2025/Python asyncio使用方法.mdx","toc":[{"value":"引言","url":"#引言","depth":2},{"value":"异步编程的基本概念","url":"#异步编程的基本概念","depth":2},{"value":"同步与异步","url":"#同步与异步","depth":3},{"value":"并发与并行","url":"#并发与并行","depth":3},{"value":"事件循环","url":"#事件循环","depth":3},{"value":"入门 asyncio","url":"#入门-asyncio","depth":2},{"value":"安装与导入","url":"#安装与导入","depth":3},{"value":"创建异步函数","url":"#创建异步函数","depth":3},{"value":"运行异步函数","url":"#运行异步函数","depth":3},{"value":"等待异步操作","url":"#等待异步操作","depth":3},{"value":"进阶 asyncio","url":"#进阶-asyncio","depth":2},{"value":"并发执行多个任务","url":"#并发执行多个任务","depth":3},{"value":"使用 asyncio.create_task","url":"#使用-asynciocreate_task","depth":3},{"value":"处理异常","url":"#处理异常","depth":3},{"value":"使用 asyncio.Queue","url":"#使用-asyncioqueue","depth":3},{"value":"实战应用","url":"#实战应用","depth":2},{"value":"异步网络请求","url":"#异步网络请求","depth":3},{"value":"异步文件操作","url":"#异步文件操作","depth":3},{"value":"性能优化与调试","url":"#性能优化与调试","depth":2},{"value":"性能分析","url":"#性能分析","depth":3},{"value":"避免阻塞","url":"#避免阻塞","depth":3},{"value":"使用 asyncio 的最佳实践","url":"#使用-asyncio-的最佳实践","depth":3},{"value":"总结","url":"#总结","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python asyncio 入门到精通","datePublished":"2025-03-18T00:00:00.000Z","dateModified":"2025-03-18T00:00:00.000Z","description":"本文全面介绍Python asyncio库的基本概念、使用方法及最佳实践，从入门到精通，帮助开发者充分利用异步编程提升I/O密集型应用的性能。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/Python asyncio使用方法"}},{"title":"大型语言模型不知道自己不知道——这是个问题","date":"2025-03-14T00:00:00.000Z","tags":["LLM"],"draft":false,"summary":"本文探讨了大型语言模型(LLMs)的一个关键缺陷：缺乏对自身能力的认知。这使得它们在执行自己并不理解的任务时过于自信，造成比幻觉问题更严重的实用性困境。\r","type":"Blog","readingTime":{"text":"9 min read","minutes":8.875,"time":532500,"words":1775},"slug":"2025/大型语言模型不知道自己不知道","path":"blog/2025/大型语言模型不知道自己不知道","filePath":"blog/2025/大型语言模型不知道自己不知道.mdx","toc":[{"value":"氛围编程","url":"#氛围编程","depth":2},{"value":"模糊的需求","url":"#模糊的需求","depth":2},{"value":"对自身局限性的理解不足","url":"#对自身局限性的理解不足","depth":2},{"value":"结论","url":"#结论","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"大型语言模型不知道自己不知道——这是个问题","datePublished":"2025-03-14T00:00:00.000Z","dateModified":"2025-03-14T00:00:00.000Z","description":"本文探讨了大型语言模型(LLMs)的一个关键缺陷：缺乏对自身能力的认知。这使得它们在执行自己并不理解的任务时过于自信，造成比幻觉问题更严重的实用性困境。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/大型语言模型不知道自己不知道"}},{"title":"向小白解释监督学习(SFT)和强化(RL)学习","date":"2025-02-18T00:00:00.000Z","tags":["LLM"],"draft":false,"summary":"用新手快递员来举例，如何向小白解释监督学习和强化学习。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.34,"time":80400,"words":268},"slug":"2025/20250218203500","path":"blog/2025/20250218203500","filePath":"blog/2025/20250218203500.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"向小白解释监督学习(SFT)和强化(RL)学习","datePublished":"2025-02-18T00:00:00.000Z","dateModified":"2025-02-18T00:00:00.000Z","description":"用新手快递员来举例，如何向小白解释监督学习和强化学习。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/20250218203500"}},{"title":"使用 natapp 进行内网穿透调试","date":"2025-02-06T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"本文介绍如何使用 Python 结合内网穿透工具 natapp 进行本地调试，解决 XXL-Job 调度中心无法直接访问本地开发机器的问题。\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.41,"time":204600,"words":682},"slug":"2025/20250206174700","path":"blog/2025/20250206174700","filePath":"blog/2025/20250206174700.mdx","toc":[{"value":"使用 Python pyxxl 进行本地调试","url":"#使用-python-pyxxl-进行本地调试","depth":1},{"value":"背景说明","url":"#背景说明","depth":2},{"value":"内网穿透配置","url":"#内网穿透配置","depth":2},{"value":"工具选择","url":"#工具选择","depth":3},{"value":"启动步骤","url":"#启动步骤","depth":3},{"value":"XXL-Job 执行器配置","url":"#xxl-job-执行器配置","depth":2},{"value":"执行器管理","url":"#执行器管理","depth":3},{"value":"PyXXL 配置实现","url":"#pyxxl-配置实现","depth":2},{"value":"环境变量配置","url":"#环境变量配置","depth":3},{"value":"代码实现","url":"#代码实现","depth":3},{"value":"调试验证","url":"#调试验证","depth":2},{"value":"常见问题","url":"#常见问题","depth":2},{"value":"注意事项","url":"#注意事项","depth":2},{"value":"总结","url":"#总结","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用 natapp 进行内网穿透调试","datePublished":"2025-02-06T00:00:00.000Z","dateModified":"2025-02-06T00:00:00.000Z","description":"本文介绍如何使用 Python 结合内网穿透工具 natapp 进行本地调试，解决 XXL-Job 调度中心无法直接访问本地开发机器的问题。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2025/20250206174700"}},{"title":"阿里云OSS链接去掉签名信息","date":"2024-12-07T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"本文介绍了如何去掉阿里云OSS链接中的签名信息，通过将Object设置为公共读权限（`oss2.OBJECT_ACL_PUBLIC_READ`），使链接公开且无时间限制。此操作虽简化了URL生成，但可能增加访问量和成本，需谨慎考虑。文章提供了上传字节流并设置权限的代码示例，以及生成公共访问URL的方法。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.645,"time":98700,"words":329},"slug":"2024/20240810221338","path":"blog/2024/20240810221338","filePath":"blog/2024/20240810221338.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"阿里云OSS链接去掉签名信息","datePublished":"2024-12-07T00:00:00.000Z","dateModified":"2024-12-07T00:00:00.000Z","description":"本文介绍了如何去掉阿里云OSS链接中的签名信息，通过将Object设置为公共读权限（`oss2.OBJECT_ACL_PUBLIC_READ`），使链接公开且无时间限制。此操作虽简化了URL生成，但可能增加访问量和成本，需谨慎考虑。文章提供了上传字节流并设置权限的代码示例，以及生成公共访问URL的方法。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240810221338"}},{"title":"shell脚本实现批量切换git分支","date":"2024-12-07T00:00:00.000Z","tags":["Shell"],"draft":false,"summary":"本文介绍了一 shell 脚本，用于批量切换 Git 项目及其子模块的分支，简化多模块项目分支管理，提高开发效率。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.605,"time":96300,"words":321},"slug":"2024/20240810221344","path":"blog/2024/20240810221344","filePath":"blog/2024/20240810221344.mdx","toc":[{"value":"用法","url":"#用法","depth":1},{"value":"源码","url":"#源码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"shell脚本实现批量切换git分支","datePublished":"2024-12-07T00:00:00.000Z","dateModified":"2024-12-07T00:00:00.000Z","description":"本文介绍了一 shell 脚本，用于批量切换 Git 项目及其子模块的分支，简化多模块项目分支管理，提高开发效率。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240810221344"}},{"title":"大语言模型学习指南","date":"2024-11-15T00:00:00.000Z","tags":["LLM","ChatGPT","RAG","favorites"],"draft":false,"summary":"本文提供了大语言模型（LLM）学习的全面指南，涵盖官方资源、论坛、博客、论文、视频博主和下载模型等多个方面。重点介绍了OpenAI、Stability AI等前沿公司，以及Reddit、Hugging Face等社区资源。同时推荐了多个B站和YouTube上的知名AI教育频道，帮助读者获取最新的技术和实践经验。此资源指南定期更新，为AI学习者提供最新最全的学习路径。\r","type":"Blog","readingTime":{"text":"11 min read","minutes":10.105,"time":606300,"words":2021},"slug":"llm-guide","path":"blog/llm-guide","filePath":"blog/llm-guide.mdx","toc":[{"value":"本站链接","url":"#本站链接","depth":1},{"value":"官网 Official Website","url":"#官网-official-website","depth":2},{"value":"论坛 Community","url":"#论坛-community","depth":2},{"value":"Reddit社区","url":"#reddit社区","depth":3},{"value":"其他社区平台","url":"#其他社区平台","depth":3},{"value":"网站博客 Blog","url":"#网站博客-blog","depth":2},{"value":"论文 Papers","url":"#论文-papers","depth":2},{"value":"在线课程平台 Online Courses","url":"#在线课程平台-online-courses","depth":2},{"value":"Coursera","url":"#coursera","depth":3},{"value":"其他优质平台","url":"#其他优质平台","depth":3},{"value":"开发工具 Development Tools","url":"#开发工具-development-tools","depth":2},{"value":"RAG框架 RAG Frameworks","url":"#rag框架-rag-frameworks","depth":3},{"value":"本地部署工具 Local Deployment","url":"#本地部署工具-local-deployment","depth":3},{"value":"视频博主 Content creators","url":"#视频博主-content-creators","depth":2},{"value":"哔哩哔哩 (B站)","url":"#哔哩哔哩-b站","depth":3},{"value":"YouTube","url":"#youtube","depth":3},{"value":"下载模型 AI Models","url":"#下载模型-ai-models","depth":2},{"value":"Awesome LLM","url":"#awesome-llm","depth":2},{"value":"实践建议 Practical Advice","url":"#实践建议-practical-advice","depth":2},{"value":"初学者路线图","url":"#初学者路线图","depth":3},{"value":"如何高效使用大语言模型","url":"#如何高效使用大语言模型","depth":3},{"value":"构建LLM应用的最佳实践","url":"#构建llm应用的最佳实践","depth":3},{"value":"前沿趋势 Emerging Trends","url":"#前沿趋势-emerging-trends","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"大语言模型学习指南","datePublished":"2024-11-15T00:00:00.000Z","dateModified":"2024-11-15T00:00:00.000Z","description":"本文提供了大语言模型（LLM）学习的全面指南，涵盖官方资源、论坛、博客、论文、视频博主和下载模型等多个方面。重点介绍了OpenAI、Stability AI等前沿公司，以及Reddit、Hugging Face等社区资源。同时推荐了多个B站和YouTube上的知名AI教育频道，帮助读者获取最新的技术和实践经验。此资源指南定期更新，为AI学习者提供最新最全的学习路径。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/llm-guide"}},{"title":"pytest中fixture用法","date":"2024-10-14T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"pytest 中的 fixture 是一种强大的功能，允许在测试执行前设置状态或资源，并在结束后清理。支持不同作用域（function、class、module、session），并可通过 autouse 自动应用。\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.785,"time":167100,"words":557},"slug":"2024/20240810221343","path":"blog/2024/20240810221343","filePath":"blog/2024/20240810221343.mdx","toc":[{"value":"基本用法","url":"#基本用法","depth":1},{"value":"Fixture 的作用域","url":"#fixture-的作用域","depth":1},{"value":"scope function","url":"#scope-function","depth":1},{"value":"scope class","url":"#scope-class","depth":1},{"value":"scope module","url":"#scope-module","depth":1},{"value":"scope session","url":"#scope-session","depth":1},{"value":"autouse=True","url":"#autousetrue","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"pytest中fixture用法","datePublished":"2024-10-14T00:00:00.000Z","dateModified":"2024-10-14T00:00:00.000Z","description":"pytest 中的 fixture 是一种强大的功能，允许在测试执行前设置状态或资源，并在结束后清理。支持不同作用域（function、class、module、session），并可通过 autouse 自动应用。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240810221343"}},{"title":"推荐一个C++线程池实现","date":"2024-10-08T00:00:00.000Z","tags":["C++"],"draft":false,"summary":"本文推荐一个简单易用的 C++11 线程池实现，支持任务排队、线程管理及等待任务完成等功能。示例代码展示了如何创建线程池并提交任务。\r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.255,"time":315300,"words":1051},"slug":"2024/20240810221340","path":"blog/2024/20240810221340","filePath":"blog/2024/20240810221340.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"推荐一个C++线程池实现","datePublished":"2024-10-08T00:00:00.000Z","dateModified":"2024-10-08T00:00:00.000Z","description":"本文推荐一个简单易用的 C++11 线程池实现，支持任务排队、线程管理及等待任务完成等功能。示例代码展示了如何创建线程池并提交任务。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240810221340"}},{"title":"邮件接入方案","date":"2024-10-08T00:00:00.000Z","tags":["Design"],"draft":false,"summary":"本文介绍了邮件系统的常见协议（SMTP、POP3、IMAP、MIME、S/MIME）及其适用场景，并推荐了 Python 中常用的邮件处理库，帮助开发者选择合适的工具进行邮件开发。\r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.61,"time":276600,"words":922},"slug":"2024/20240810221341","path":"blog/2024/20240810221341","filePath":"blog/2024/20240810221341.mdx","toc":[{"value":"邮件协议","url":"#邮件协议","depth":1},{"value":"发送邮件的协议","url":"#发送邮件的协议","depth":2},{"value":"接收邮件的协议","url":"#接收邮件的协议","depth":2},{"value":"其他相关协议","url":"#其他相关协议","depth":2},{"value":"协议的选择","url":"#协议的选择","depth":1},{"value":"Python邮件处理库","url":"#python邮件处理库","depth":1},{"value":"发送邮件","url":"#发送邮件","depth":2},{"value":"接收邮件","url":"#接收邮件","depth":2},{"value":"综合处理邮件","url":"#综合处理邮件","depth":2},{"value":"邮件解析","url":"#邮件解析","depth":3},{"value":"用法","url":"#用法","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"邮件接入方案","datePublished":"2024-10-08T00:00:00.000Z","dateModified":"2024-10-08T00:00:00.000Z","description":"本文介绍了邮件系统的常见协议（SMTP、POP3、IMAP、MIME、S/MIME）及其适用场景，并推荐了 Python 中常用的邮件处理库，帮助开发者选择合适的工具进行邮件开发。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240810221341"}},{"title":"边缘函数简介","date":"2024-10-06T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"本文介绍了边缘函数（Edge Function）的概念及其在网络边缘执行计算逻辑的作用，包括降低延迟、提高性能、内容个性化、增强安全性和数据处理等。边缘函数采用分布式架构和无服务器计算模式，支持事件驱动和快速启动。文章还展示了其在动态内容生成、A/B 测试、内容缓存、API 网关和安全性增强等场景中的具体应用示例。\r","type":"Blog","readingTime":{"text":"7 min read","minutes":6.2,"time":372000,"words":1240},"slug":"2024/20240810221339","path":"blog/2024/20240810221339","filePath":"blog/2024/20240810221339.mdx","toc":[{"value":"边缘函数的作用","url":"#边缘函数的作用","depth":3},{"value":"边缘函数的原理","url":"#边缘函数的原理","depth":3},{"value":"使用场景","url":"#使用场景","depth":3},{"value":"1. 动态内容生成","url":"#1-动态内容生成","depth":3},{"value":"2. A/B 测试","url":"#2-ab-测试","depth":3},{"value":"3. 内容缓存","url":"#3-内容缓存","depth":3},{"value":"4. API 网关","url":"#4-api-网关","depth":3},{"value":"5. 安全性增强","url":"#5-安全性增强","depth":3},{"value":"总结","url":"#总结","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"边缘函数简介","datePublished":"2024-10-06T00:00:00.000Z","dateModified":"2024-10-06T00:00:00.000Z","description":"本文介绍了边缘函数（Edge Function）的概念及其在网络边缘执行计算逻辑的作用，包括降低延迟、提高性能、内容个性化、增强安全性和数据处理等。边缘函数采用分布式架构和无服务器计算模式，支持事件驱动和快速启动。文章还展示了其在动态内容生成、A/B 测试、内容缓存、API 网关和安全性增强等场景中的具体应用示例。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240810221339"}},{"title":"PostgreSQL全文检索","date":"2024-09-27T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"本文介绍了在 PostgreSQL 中启用 pg_trgm 和 zhparser 扩展以实现高效的中文全文检索，包括安装步骤、分词示例及使用 GIN 索引优化查询性能。\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.515,"time":210900,"words":703},"slug":"2024/20240810221342","path":"blog/2024/20240810221342","filePath":"blog/2024/20240810221342.mdx","toc":[{"value":"数据库中启用 pg_trgm 扩展","url":"#数据库中启用-pg_trgm-扩展","depth":1},{"value":"安装 zhparser 扩展","url":"#安装-zhparser-扩展","depth":1},{"value":"安装SCWS","url":"#安装scws","depth":2},{"value":"编译安装zhparser","url":"#编译安装zhparser","depth":2},{"value":"分词","url":"#分词","depth":1},{"value":"Example","url":"#example","depth":1},{"value":"实际测试","url":"#实际测试","depth":1},{"value":"使用GIN索引","url":"#使用gin索引","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"PostgreSQL全文检索","datePublished":"2024-09-27T00:00:00.000Z","dateModified":"2024-09-27T00:00:00.000Z","description":"本文介绍了在 PostgreSQL 中启用 pg_trgm 和 zhparser 扩展以实现高效的中文全文检索，包括安装步骤、分词示例及使用 GIN 索引优化查询性能。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240810221342"}},{"title":"U盘做系统盘后恢复","date":"2024-09-13T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"本文介绍如何使用 Windows 系统自带的磁盘管理工具恢复被用作系统盘的 U 盘到原始状态，通过删除已分配卷并重新创建简单卷，轻松恢复 U 盘的正常使用，无需额外工具。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.29,"time":77400,"words":258},"slug":"2024/20240810221345","path":"blog/2024/20240810221345","filePath":"blog/2024/20240810221345.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"U盘做系统盘后恢复","datePublished":"2024-09-13T00:00:00.000Z","dateModified":"2024-09-13T00:00:00.000Z","description":"本文介绍如何使用 Windows 系统自带的磁盘管理工具恢复被用作系统盘的 U 盘到原始状态，通过删除已分配卷并重新创建简单卷，轻松恢复 U 盘的正常使用，无需额外工具。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240810221345"}},{"title":"debian使用记录","date":"2024-08-10T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"本文记录了在 Debian 系统中重置 XFCE 面板为默认设置及关闭系统提示音的方法。通过删除配置文件和重启面板，轻松恢复 XFCE 面板，默认设置，并介绍如何永久禁用系统蜂鸣声。\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.935,"time":56100,"words":187},"slug":"2024/20240810221337","path":"blog/2024/20240810221337","filePath":"blog/2024/20240810221337.mdx","toc":[{"value":"将Xfce面板重置为默认设置","url":"#将xfce面板重置为默认设置","depth":1},{"value":"关闭beep系统提示音","url":"#关闭beep系统提示音","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"debian使用记录","datePublished":"2024-08-10T00:00:00.000Z","dateModified":"2024-08-10T00:00:00.000Z","description":"本文记录了在 Debian 系统中重置 XFCE 面板为默认设置及关闭系统提示音的方法。通过删除配置文件和重启面板，轻松恢复 XFCE 面板，默认设置，并介绍如何永久禁用系统蜂鸣声。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240810221337"}},{"title":"Qt6中不能使用搜狗输入法","date":"2024-04-04T00:00:00.000Z","tags":["Qt","Linux"],"draft":false,"summary":"本文解决了在 Ubuntu 上使用 Qt6 和 PySide6 时无法使用搜狗输入法的问题，通过拷贝并设置 libfcitxplatforminputcontextplugin-qt6.so 文件为可执行状态，修复了 QtCreator 和 PySide6 程序中的输入法问题。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.055,"time":63300,"words":211},"slug":"2024/20240404154338","path":"blog/2024/20240404154338","filePath":"blog/2024/20240404154338.mdx","toc":[{"value":"原因","url":"#原因","depth":1},{"value":"解决QtCreator问题","url":"#解决qtcreator问题","depth":1},{"value":"解决PySide6编写的程序的问题","url":"#解决pyside6编写的程序的问题","depth":1},{"value":"编译好的文件","url":"#编译好的文件","depth":1},{"value":"编译","url":"#编译","depth":1},{"value":"安装依赖","url":"#安装依赖","depth":2},{"value":"设置编译环境","url":"#设置编译环境","depth":2},{"value":"源码","url":"#源码","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt6中不能使用搜狗输入法","datePublished":"2024-04-04T00:00:00.000Z","dateModified":"2024-04-04T00:00:00.000Z","description":"本文解决了在 Ubuntu 上使用 Qt6 和 PySide6 时无法使用搜狗输入法的问题，通过拷贝并设置 libfcitxplatforminputcontextplugin-qt6.so 文件为可执行状态，修复了 QtCreator 和 PySide6 程序中的输入法问题。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240404154338"}},{"title":"100行代码复现Langchain","date":"2024-02-26T00:00:00.000Z","tags":["LLM"],"draft":false,"summary":"本文通过约100行代码复现了LangChain的核心功能，展示了如何利用LLM（如GPT）和工具（如搜索引擎、计算器）构建智能对话界面。作者详细介绍了从问题解析、工具调用到结果反馈的实现过程，并探讨了其背后的提示设计与推理机制。尽管简单，该实现已能处理多轮对话和复杂查询，但也揭示了当前技术的局限性。\r","type":"Blog","readingTime":{"text":"20 min read","minutes":19.52,"time":1171200,"words":3904},"slug":"2024/20240226220806","path":"blog/2024/20240226220806","filePath":"blog/2024/20240226220806.mdx","toc":[{"value":"1、主问题循环","url":"#1主问题循环","depth":2},{"value":"2、一个搜索工具","url":"#2一个搜索工具","depth":2},{"value":"3、一个计算器工具","url":"#3一个计算器工具","depth":2},{"value":"4、对话式界面","url":"#4对话式界面","depth":2},{"value":"5、进一步的例子","url":"#5进一步的例子","depth":2},{"value":"7、结束语","url":"#7结束语","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"100行代码复现Langchain","datePublished":"2024-02-26T00:00:00.000Z","dateModified":"2024-02-26T00:00:00.000Z","description":"本文通过约100行代码复现了LangChain的核心功能，展示了如何利用LLM（如GPT）和工具（如搜索引擎、计算器）构建智能对话界面。作者详细介绍了从问题解析、工具调用到结果反馈的实现过程，并探讨了其背后的提示设计与推理机制。尽管简单，该实现已能处理多轮对话和复杂查询，但也揭示了当前技术的局限性。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240226220806"}},{"title":"人工智能视频收藏","date":"2024-02-24T00:00:00.000Z","tags":["LLM","favorites"],"draft":false,"summary":"本文整理了多个人工智能入门和 ChatGPT 相关的优质视频资源，涵盖从基础概念到深入原理的讲解，适合不同层次的学习者，帮助快速理解人工智能和大模型技术。\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.54,"time":32400,"words":108},"slug":"2024/20240224180217","path":"blog/2024/20240224180217","filePath":"blog/2024/20240224180217.mdx","toc":[{"value":"人工智能入门","url":"#人工智能入门","depth":1},{"value":"ChatGPT","url":"#chatgpt","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"人工智能视频收藏","datePublished":"2024-02-24T00:00:00.000Z","dateModified":"2024-02-24T00:00:00.000Z","description":"本文整理了多个人工智能入门和 ChatGPT 相关的优质视频资源，涵盖从基础概念到深入原理的讲解，适合不同层次的学习者，帮助快速理解人工智能和大模型技术。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240224180217"}},{"title":"Navicat for PostgreSQL ubuntu 无限续期","date":"2024-02-23T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"本文介绍了在 Ubuntu 上延长 Navicat 16 for PostgreSQL 免费试用期的方法，通过删除本地配置文件实现续期，并提供两种保存连接信息的方式：导出导入和使用 Navicat Cloud。\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.8,"time":48000,"words":160},"slug":"2024/20240223170153","path":"blog/2024/20240223170153","filePath":"blog/2024/20240223170153.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Navicat for PostgreSQL ubuntu 无限续期","datePublished":"2024-02-23T00:00:00.000Z","dateModified":"2024-02-23T00:00:00.000Z","description":"本文介绍了在 Ubuntu 上延长 Navicat 16 for PostgreSQL 免费试用期的方法，通过删除本地配置文件实现续期，并提供两种保存连接信息的方式：导出导入和使用 Navicat Cloud。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240223170153"}},{"title":"AI 产品收藏","date":"2024-02-20T00:00:00.000Z","tags":["AI","favorites"],"draft":false,"summary":"精选当前值得关注的AI工具与产品，包括搜索、对话、图像生成和内容创作等多种实用AI服务。\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.5,"time":30000,"words":100},"slug":"2024/20240220092745","path":"blog/2024/20240220092745","filePath":"blog/2024/20240220092745.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"AI 产品收藏","datePublished":"2024-02-20T00:00:00.000Z","dateModified":"2024-02-20T00:00:00.000Z","description":"精选当前值得关注的AI工具与产品，包括搜索、对话、图像生成和内容创作等多种实用AI服务。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240220092745"}},{"title":"LangChain和LlamaIndex之间有什么区别？","date":"2024-02-16T00:00:00.000Z","tags":["LLM"],"draft":false,"summary":"本文比较了LangChain和LlamaIndex两个框架在构建LLM应用程序时的表现，通过四个任务：连接本地LLM、构建RAG系统、结合两者及转换为代理人，帮助读者选择适合的框架。\r","type":"Blog","readingTime":{"text":"17 min read","minutes":16.6,"time":996000,"words":3320},"slug":"2024/20240216015930","path":"blog/2024/20240216015930","filePath":"blog/2024/20240216015930.mdx","toc":[{"value":"创建一个使用本地LLM的聊天机器人","url":"#创建一个使用本地llm的聊天机器人","depth":1},{"value":"构建一个用于本地文件的RAG系统","url":"#构建一个用于本地文件的rag系统","depth":1},{"value":"将两者结合起来：一个启用了RAG的聊天机器人","url":"#将两者结合起来一个启用了rag的聊天机器人","depth":1},{"value":"升级到代理","url":"#升级到代理","depth":1},{"value":"总结：","url":"#总结","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"LangChain和LlamaIndex之间有什么区别？","datePublished":"2024-02-16T00:00:00.000Z","dateModified":"2024-02-16T00:00:00.000Z","description":"本文比较了LangChain和LlamaIndex两个框架在构建LLM应用程序时的表现，通过四个任务：连接本地LLM、构建RAG系统、结合两者及转换为代理人，帮助读者选择适合的框架。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240216015930"}},{"title":"为什么RAG很重要","date":"2024-02-16T00:00:00.000Z","tags":["LLM"],"draft":false,"summary":"本文探讨了检索增强生成（RAG）在大型语言模型（LLM）中的重要性，解释了其如何降低成本、保持数据更新和提高透明度，并介绍了ReAct范式使LLM成为代理人的机制，推动人工智能技术的民主化。\r","type":"Blog","readingTime":{"text":"7 min read","minutes":6.285,"time":377100,"words":1257},"slug":"2024/20240216020939","path":"blog/2024/20240216020939","filePath":"blog/2024/20240216020939.mdx","toc":[{"value":"自主托管LLM","url":"#自主托管llm","depth":1},{"value":"让LLM了解您","url":"#让llm了解您","depth":1},{"value":"具有RAG的LLM是代理人","url":"#具有rag的llm是代理人","depth":1},{"value":"总结","url":"#总结","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"为什么RAG很重要","datePublished":"2024-02-16T00:00:00.000Z","dateModified":"2024-02-16T00:00:00.000Z","description":"本文探讨了检索增强生成（RAG）在大型语言模型（LLM）中的重要性，解释了其如何降低成本、保持数据更新和提高透明度，并介绍了ReAct范式使LLM成为代理人的机制，推动人工智能技术的民主化。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240216020939"}},{"title":"让LLM性能飙升的Prompt黄金准则","date":"2024-02-16T00:00:00.000Z","tags":["LLM"],"draft":false,"summary":"本文介绍了穆罕默德・本・扎耶德人工智能大学 VILA Lab 的一项研究，提出了26条具体的提示工程准则，旨在提升大语言模型（LLM）的性能，无需额外训练即可提高50%以上的效果。这些准则涵盖了回答内容控制、任务分解、用户交互等多个方面，帮助用户更有效地与大模型互动并获得高质量的回答。研究引起了广泛关注，并提供了详细的指南和示例。\r","type":"Blog","readingTime":{"text":"9 min read","minutes":8.27,"time":496200,"words":1654},"slug":"2024/20240216230643","path":"blog/2024/20240216230643","filePath":"blog/2024/20240216230643.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"让LLM性能飙升的Prompt黄金准则","datePublished":"2024-02-16T00:00:00.000Z","dateModified":"2024-02-16T00:00:00.000Z","description":"本文介绍了穆罕默德・本・扎耶德人工智能大学 VILA Lab 的一项研究，提出了26条具体的提示工程准则，旨在提升大语言模型（LLM）的性能，无需额外训练即可提高50%以上的效果。这些准则涵盖了回答内容控制、任务分解、用户交互等多个方面，帮助用户更有效地与大模型互动并获得高质量的回答。研究引起了广泛关注，并提供了详细的指南和示例。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240216230643"}},{"title":"简单易懂的Prompt 高级技巧： Few-Shots 、 COT 、SC、TOT 、Step-Back","date":"2024-02-15T00:00:00.000Z","tags":["LLM"],"draft":false,"summary":"本文介绍了几种高级的Prompt编写技巧，包括CRISPE框架、Zero-Shot、Few-Shots、COT（思维链）、SC（自我一致性）、TOT（树状推理）和Step-Back。通过一个英文翻译成中文的任务示例，展示了不同Prompt模式对大语言模型输出结果的影响，并总结了每种模式的效果。文章还解释了Google在Gemini大模型评测中使用不同Prompt模式的原因，指出其在不同指标上采用不同的提示策略以优化表现。\r","type":"Blog","readingTime":{"text":"32 min read","minutes":31.035,"time":1862100,"words":6207},"slug":"2024/20240215001441","path":"blog/2024/20240215001441","filePath":"blog/2024/20240215001441.mdx","toc":[{"value":"CRISPE框架","url":"#crispe框架","depth":1},{"value":"Zero-shot","url":"#zero-shot","depth":1},{"value":"Few_shot","url":"#few_shot","depth":1},{"value":"COT","url":"#cot","depth":1},{"value":"COT+SC","url":"#cotsc","depth":1},{"value":"TOT","url":"#tot","depth":1},{"value":"Step-Back","url":"#step-back","depth":1},{"value":"总结","url":"#总结","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"简单易懂的Prompt 高级技巧： Few-Shots 、 COT 、SC、TOT 、Step-Back","datePublished":"2024-02-15T00:00:00.000Z","dateModified":"2024-02-15T00:00:00.000Z","description":"本文介绍了几种高级的Prompt编写技巧，包括CRISPE框架、Zero-Shot、Few-Shots、COT（思维链）、SC（自我一致性）、TOT（树状推理）和Step-Back。通过一个英文翻译成中文的任务示例，展示了不同Prompt模式对大语言模型输出结果的影响，并总结了每种模式的效果。文章还解释了Google在Gemini大模型评测中使用不同Prompt模式的原因，指出其在不同指标上采用不同的提示策略以优化表现。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240215001441"}},{"title":"解决微信公众号文章中的图片不能显示的问题","date":"2024-02-15T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"本文介绍了微信公众号文章中图片无法正常显示的原因及解决方法。原因是微信图片服务器通过检查HTTP请求头中的Referer字段来防止其他网站盗用图片资源（防盗链）。当Referer不是微信域名时，服务器会返回提示图片。解决方法是在HTML头部添加`<meta name=\"referrer\" content=\"never\">`，但这可能影响数据分析、SEO和某些网站功能，需权衡隐私与这些潜在问题。\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.94,"time":236400,"words":788},"slug":"2024/20240215130343","path":"blog/2024/20240215130343","filePath":"blog/2024/20240215130343.mdx","toc":[{"value":"问题","url":"#问题","depth":1},{"value":"原因","url":"#原因","depth":1},{"value":"解决","url":"#解决","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"解决微信公众号文章中的图片不能显示的问题","datePublished":"2024-02-15T00:00:00.000Z","dateModified":"2024-02-15T00:00:00.000Z","description":"本文介绍了微信公众号文章中图片无法正常显示的原因及解决方法。原因是微信图片服务器通过检查HTTP请求头中的Referer字段来防止其他网站盗用图片资源（防盗链）。当Referer不是微信域名时，服务器会返回提示图片。解决方法是在HTML头部添加`<meta name=\"referrer\" content=\"never\">`，但这可能影响数据分析、SEO和某些网站功能，需权衡隐私与这些潜在问题。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240215130343"}},{"title":"RAG的7种常见问题及解决方案","date":"2024-02-15T00:00:00.000Z","tags":["LLM","RAG"],"draft":false,"summary":"本文总结了RAG系统的7种常见问题及解决方案，涵盖内容幻觉、答案遗漏、整合限制等，并提供了优化策略，如元数据过滤、模型微调和知识库优化，提升系统性能。\r","type":"Blog","readingTime":{"text":"10 min read","minutes":9.38,"time":562800,"words":1876},"slug":"2024/20240215170649","path":"blog/2024/20240215170649","filePath":"blog/2024/20240215170649.mdx","toc":[{"value":"一、7种常见问题","url":"#一7种常见问题","depth":1},{"value":"FP1 缺少内容/幻觉答错：","url":"#fp1-缺少内容幻觉答错","depth":2},{"value":"FP2 不在topN中，导致漏掉答案","url":"#fp2-不在topn中导致漏掉答案","depth":2},{"value":"FP3 不在上下文中-整合策略的限制","url":"#fp3-不在上下文中-整合策略的限制","depth":2},{"value":"FP4 未提取出","url":"#fp4-未提取出","depth":2},{"value":"FP5 错误格式","url":"#fp5-错误格式","depth":2},{"value":"FP6 不正确的特异性","url":"#fp6-不正确的特异性","depth":2},{"value":"FP7 不完整","url":"#fp7-不完整","depth":2},{"value":"二、论文中的经验教训","url":"#二论文中的经验教训","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"RAG的7种常见问题及解决方案","datePublished":"2024-02-15T00:00:00.000Z","dateModified":"2024-02-15T00:00:00.000Z","description":"本文总结了RAG系统的7种常见问题及解决方案，涵盖内容幻觉、答案遗漏、整合限制等，并提供了优化策略，如元数据过滤、模型微调和知识库优化，提升系统性能。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240215170649"}},{"title":"ubuntu edge起不来解决方法","date":"2024-01-20T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"本文记录了解决 Ubuntu 系统上 Microsoft Edge 浏览器启动失败的问题。通过删除配置目录 `~/.config/microsoft-edge` 下的 `Singleton*` 文件，成功解除文件锁定，使 Edge 重新正常启动。\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.875,"time":52500,"words":175},"slug":"2024/20240120101101","path":"blog/2024/20240120101101","filePath":"blog/2024/20240120101101.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ubuntu edge起不来解决方法","datePublished":"2024-01-20T00:00:00.000Z","dateModified":"2024-01-20T00:00:00.000Z","description":"本文记录了解决 Ubuntu 系统上 Microsoft Edge 浏览器启动失败的问题。通过删除配置目录 `~/.config/microsoft-edge` 下的 `Singleton*` 文件，成功解除文件锁定，使 Edge 重新正常启动。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2024/20240120101101"}},{"title":"使用Python和Redis实现多台电脑剪切板内容同步","date":"2023-11-12T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"本文介绍了如何使用 Python 和 Redis 实现多台电脑之间的剪切板内容同步。通过创建 `ClipboardSync` 类，程序能够监听本地剪切板的变化，并将复制的内容发送到 Redis 服务器。其他运行相同程序的电脑可以从 Redis 接收并粘贴这些内容。项目依赖于 `pyperclip` 和 `redis-py` 库，利用多线程和 `asyncio` 事件循环确保实时同步。此工具简化了跨设备分享文本和链接的过程，提升了工作效率。\r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.805,"time":288300,"words":961},"slug":"2023/20231112170011","path":"blog/2023/20231112170011","filePath":"blog/2023/20231112170011.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用Python和Redis实现多台电脑剪切板内容同步","datePublished":"2023-11-12T00:00:00.000Z","dateModified":"2023-11-12T00:00:00.000Z","description":"本文介绍了如何使用 Python 和 Redis 实现多台电脑之间的剪切板内容同步。通过创建 `ClipboardSync` 类，程序能够监听本地剪切板的变化，并将复制的内容发送到 Redis 服务器。其他运行相同程序的电脑可以从 Redis 接收并粘贴这些内容。项目依赖于 `pyperclip` 和 `redis-py` 库，利用多线程和 `asyncio` 事件循环确保实时同步。此工具简化了跨设备分享文本和链接的过程，提升了工作效率。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2023/20231112170011"}},{"title":"获取windows桌面所有可见窗口信息","date":"2023-05-14T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"本文介绍了如何获取 Windows 桌面上所有可见窗口的信息，包括窗口句柄、标题、类名、区域和 ZOrder（显示层级）。通过使用 C++ 和 Windows API，定义了 `WindowInfo` 结构体来存储窗口信息，并通过 `EnumWindows` 函数枚举所有可见窗口。代码示例展示了如何遍历窗口列表，获取每个窗口的详细信息，并计算其 ZOrder，最终返回包含所有窗口信息的 `QVector<WindowInfo>`。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.19,"time":71400,"words":238},"slug":"2023/20230514215129","path":"blog/2023/20230514215129","filePath":"blog/2023/20230514215129.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"获取windows桌面所有可见窗口信息","datePublished":"2023-05-14T00:00:00.000Z","dateModified":"2023-05-14T00:00:00.000Z","description":"本文介绍了如何获取 Windows 桌面上所有可见窗口的信息，包括窗口句柄、标题、类名、区域和 ZOrder（显示层级）。通过使用 C++ 和 Windows API，定义了 `WindowInfo` 结构体来存储窗口信息，并通过 `EnumWindows` 函数枚举所有可见窗口。代码示例展示了如何遍历窗口列表，获取每个窗口的详细信息，并计算其 ZOrder，最终返回包含所有窗口信息的 `QVector<WindowInfo>`。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2023/20230514215129"}},{"title":"远程桌面切换到console session","date":"2023-04-22T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"本文介绍了如何在使用第三方远程桌面软件连接公司电脑时，解决物理控制台无显示的问题。原因是微软远程桌面（RDP）会创建独立的会话，默认不显示在物理控制台上，而其他软件如 TeamViewer 无法直接输出到物理屏幕。通过使用 `tscon` 命令将远程会话转换为 console session，可以实现在物理控制台上查看远程桌面输出。具体步骤包括使用 `query user` 查看会话ID，并执行 `tscon <session ID> /dest:console` 进行转换。\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.67,"time":220200,"words":734},"slug":"2023/20230422105222","path":"blog/2023/20230422105222","filePath":"blog/2023/20230422105222.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"远程桌面切换到console session","datePublished":"2023-04-22T00:00:00.000Z","dateModified":"2023-04-22T00:00:00.000Z","description":"本文介绍了如何在使用第三方远程桌面软件连接公司电脑时，解决物理控制台无显示的问题。原因是微软远程桌面（RDP）会创建独立的会话，默认不显示在物理控制台上，而其他软件如 TeamViewer 无法直接输出到物理屏幕。通过使用 `tscon` 命令将远程会话转换为 console session，可以实现在物理控制台上查看远程桌面输出。具体步骤包括使用 `query user` 查看会话ID，并执行 `tscon <session ID> /dest:console` 进行转换。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2023/20230422105222"}},{"title":"C++20 模块入门指南","date":"2023-04-05T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"C++20 引入模块特性以解决头文件问题。模块由 interface 和 implementation 组成，使用 import 导入，如 example 模块示例。命名应遵循规范，像 math 模块。模块能提升代码维护重用性，编译快、组织简单、冲突少。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.125,"time":247500,"words":825},"slug":"2023/20230405091616","path":"blog/2023/20230405091616","filePath":"blog/2023/20230405091616.mdx","toc":[{"value":"1. 模块的基本结构","url":"#1-模块的基本结构","depth":1},{"value":"2. 模块的使用方法","url":"#2-模块的使用方法","depth":1},{"value":"3. 模块的命名规范","url":"#3-模块的命名规范","depth":1},{"value":"4. 总结","url":"#4-总结","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++20 模块入门指南","datePublished":"2023-04-05T00:00:00.000Z","dateModified":"2023-04-05T00:00:00.000Z","description":"C++20 引入模块特性以解决头文件问题。模块由 interface 和 implementation 组成，使用 import 导入，如 example 模块示例。命名应遵循规范，像 math 模块。模块能提升代码维护重用性，编译快、组织简单、冲突少。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2023/20230405091616"}},{"title":"Win32 MSAA UIA技术介绍","date":"2023-04-05T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"本文介绍 Win32、MSAA、UIA 技术。Win32 是基础 API 用于 Windows 界面开发，MSAA 助开发辅助功能，UIA 是 Windows7 新功能提供更精确访问信息。RPA 产品需这些技术来控制 GUI 应用，各技术优缺点各异，需根据需求灵活选择。 \r","type":"Blog","readingTime":{"text":"7 min read","minutes":6.235,"time":374100,"words":1247},"slug":"2023/20230405212722","path":"blog/2023/20230405212722","filePath":"blog/2023/20230405212722.mdx","toc":[{"value":"Win32","url":"#win32","depth":1},{"value":"MSAA","url":"#msaa","depth":1},{"value":"RPA产品运用","url":"#rpa产品运用","depth":1},{"value":"Win32技术","url":"#win32技术","depth":2},{"value":"MSAA技术","url":"#msaa技术","depth":2},{"value":"UIA技术","url":"#uia技术","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Win32 MSAA UIA技术介绍","datePublished":"2023-04-05T00:00:00.000Z","dateModified":"2023-04-05T00:00:00.000Z","description":"本文介绍 Win32、MSAA、UIA 技术。Win32 是基础 API 用于 Windows 界面开发，MSAA 助开发辅助功能，UIA 是 Windows7 新功能提供更精确访问信息。RPA 产品需这些技术来控制 GUI 应用，各技术优缺点各异，需根据需求灵活选择。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2023/20230405212722"}},{"title":"实现RPA软件的关键点","date":"2023-04-05T00:00:00.000Z","tags":["Design"],"draft":false,"summary":"实现 RPA 软件关键点：识别业务流程，开发脚本处理异常，提供配置管理监控，保障安全，迭代优化，还需社交网络信息收集，全面考虑多因素，保证自动化高效稳定安全。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.28,"time":136800,"words":456},"slug":"2023/20230405213208","path":"blog/2023/20230405213208","filePath":"blog/2023/20230405213208.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"实现RPA软件的关键点","datePublished":"2023-04-05T00:00:00.000Z","dateModified":"2023-04-05T00:00:00.000Z","description":"实现 RPA 软件关键点：识别业务流程，开发脚本处理异常，提供配置管理监控，保障安全，迭代优化，还需社交网络信息收集，全面考虑多因素，保证自动化高效稳定安全。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2023/20230405213208"}},{"title":"JavaScript优雅的编程方式","date":"2023-04-05T00:00:00.000Z","tags":["Javascript"],"draft":false,"summary":"总结：介绍 JavaScript 优雅编程方式，如函数式编程、async/await、模块化开发、箭头函数、函数默认参数与对象解构、链式调用等，各举实例说明其优势，可提升代码可读性与效率。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.295,"time":257700,"words":859},"slug":"2023/20230405221938","path":"blog/2023/20230405221938","filePath":"blog/2023/20230405221938.mdx","toc":[{"value":"1. 使用函数式编程","url":"#1-使用函数式编程","depth":1},{"value":"2. 使用 async/await","url":"#2-使用-asyncawait","depth":1},{"value":"3. 使用模块化开发","url":"#3-使用模块化开发","depth":1},{"value":"4. 使用箭头函数","url":"#4-使用箭头函数","depth":1},{"value":"5. 使用函数默认参数和对象解构","url":"#5-使用函数默认参数和对象解构","depth":1},{"value":"6. 使用链式调用和方法链","url":"#6-使用链式调用和方法链","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript优雅的编程方式","datePublished":"2023-04-05T00:00:00.000Z","dateModified":"2023-04-05T00:00:00.000Z","description":"总结：介绍 JavaScript 优雅编程方式，如函数式编程、async/await、模块化开发、箭头函数、函数默认参数与对象解构、链式调用等，各举实例说明其优势，可提升代码可读性与效率。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2023/20230405221938"}},{"title":"Python的几种函数参数类型","date":"2022-12-11T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"本文介绍了Python函数的几种参数类型，包括位置参数、默认参数、可变参数、关键字参数、命名关键字参数及其组合使用方法，帮助开发者灵活定义和调用函数。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.96,"time":117600,"words":392},"slug":"2022/20221211222811","path":"blog/2022/20221211222811","filePath":"blog/2022/20221211222811.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python的几种函数参数类型","datePublished":"2022-12-11T00:00:00.000Z","dateModified":"2022-12-11T00:00:00.000Z","description":"本文介绍了Python函数的几种参数类型，包括位置参数、默认参数、可变参数、关键字参数、命名关键字参数及其组合使用方法，帮助开发者灵活定义和调用函数。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2022/20221211222811"}},{"title":"Effective Python","date":"2022-11-26T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"本文记录了《Effective Python》中的部分练习和建议，涵盖命名规范、空值判断简化、列表切片、遍历优化及函数默认参数的正确使用，帮助编写更高效的Python代码。\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.42,"time":145200,"words":484},"slug":"2022/20221126205959","path":"blog/2022/20221126205959","filePath":"blog/2022/20221126205959.mdx","toc":[{"value":"关于命名的建议","url":"#关于命名的建议","depth":1},{"value":"判断字符串或列表是否为空","url":"#判断字符串或列表是否为空","depth":1},{"value":"if else可以用or来简化代码（适合短语句）","url":"#if-else可以用or来简化代码适合短语句","depth":1},{"value":"list切片会生成新对象，有新地址，而引用不会","url":"#list切片会生成新对象有新地址而引用不会","depth":1},{"value":"遍历需要下标时用enumerate替代range","url":"#遍历需要下标时用enumerate替代range","depth":1},{"value":"函数的参数不要是动态默认值","url":"#函数的参数不要是动态默认值","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Effective Python","datePublished":"2022-11-26T00:00:00.000Z","dateModified":"2022-11-26T00:00:00.000Z","description":"本文记录了《Effective Python》中的部分练习和建议，涵盖命名规范、空值判断简化、列表切片、遍历优化及函数默认参数的正确使用，帮助编写更高效的Python代码。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2022/20221126205959"}},{"title":"Mac、linux安装brew终极办法","date":"2022-10-07T00:00:00.000Z","tags":["Shell"],"draft":false,"summary":"文章介绍了 Mac、linux 安装 brew 的终极办法，即粘贴特定命令`/bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\"`到终端回车，执行后可能需输入开机密码，可解决安装时连不上或下载缓慢的问题。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.4,"time":24000,"words":80},"slug":"2022/20221007161327","path":"blog/2022/20221007161327","filePath":"blog/2022/20221007161327.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Mac、linux安装brew终极办法","datePublished":"2022-10-07T00:00:00.000Z","dateModified":"2022-10-07T00:00:00.000Z","description":"文章介绍了 Mac、linux 安装 brew 的终极办法，即粘贴特定命令`/bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\"`到终端回车，执行后可能需输入开机密码，可解决安装时连不上或下载缓慢的问题。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2022/20221007161327"}},{"title":"IE获取元素样式","date":"2022-07-22T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"IE 浏览器获取元素样式时，常规方式获取不了。文中给出正确方法，包括一系列函数如 bstr2str、str2bstr 等，通过这些函数可获取元素的样式属性。先获取“style”属性的 DISPATCH 值，再获取“cssText”属性值并转换为字符串。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.735,"time":104100,"words":347},"slug":"2022/20220722160106","path":"blog/2022/20220722160106","filePath":"blog/2022/20220722160106.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"IE获取元素样式","datePublished":"2022-07-22T00:00:00.000Z","dateModified":"2022-07-22T00:00:00.000Z","description":"IE 浏览器获取元素样式时，常规方式获取不了。文中给出正确方法，包括一系列函数如 bstr2str、str2bstr 等，通过这些函数可获取元素的样式属性。先获取“style”属性的 DISPATCH 值，再获取“cssText”属性值并转换为字符串。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2022/20220722160106"}},{"title":"QProcess 7z.exe 解压进度","date":"2022-07-06T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"通过 QProcess 结合 7z.exe 实现解压进度，在 Worker 线程中读取进度信息，利用相关信号处理解压过程，避免主界面卡顿。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.55,"time":93000,"words":310},"slug":"2022/20220706190423","path":"blog/2022/20220706190423","filePath":"blog/2022/20220706190423.mdx","toc":[{"value":"7z命令行","url":"#7z命令行","depth":1},{"value":"Worker线程","url":"#worker线程","depth":1},{"value":"QProcess使用","url":"#qprocess使用","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QProcess 7z.exe 解压进度","datePublished":"2022-07-06T00:00:00.000Z","dateModified":"2022-07-06T00:00:00.000Z","description":"通过 QProcess 结合 7z.exe 实现解压进度，在 Worker 线程中读取进度信息，利用相关信号处理解压过程，避免主界面卡顿。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2022/20220706190423"}},{"title":"降权启动应用","date":"2022-04-02T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"介绍了在 Windows 中降权启动应用的方法，指出 WTSQueryUserToken 在普通会话下调用常失败但在 session 0 服务中可成功，给出代码`runProcessAsUser`，但强调此代码未严谨测试仅供参考。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.545,"time":92700,"words":309},"slug":"2022/20220402220837","path":"blog/2022/20220402220837","filePath":"blog/2022/20220402220837.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"降权启动应用","datePublished":"2022-04-02T00:00:00.000Z","dateModified":"2022-04-02T00:00:00.000Z","description":"介绍了在 Windows 中降权启动应用的方法，指出 WTSQueryUserToken 在普通会话下调用常失败但在 session 0 服务中可成功，给出代码`runProcessAsUser`，但强调此代码未严谨测试仅供参考。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2022/20220402220837"}},{"title":"beast websocket demo","date":"2022-03-06T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"这是一个 C++ 的 beast websocket 示例，包含客户端和服务器代码。客户端发送随机生成的文本消息并接收服务器响应，服务器接收客户端消息并回显。客户端通过连接本地主机的 2236 端口进行通信，服务器在 127.0.0.1 的 2236 端口监听新连接。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.93,"time":235800,"words":786},"slug":"2022/20220306170927","path":"blog/2022/20220306170927","filePath":"blog/2022/20220306170927.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"beast websocket demo","datePublished":"2022-03-06T00:00:00.000Z","dateModified":"2022-03-06T00:00:00.000Z","description":"这是一个 C++ 的 beast websocket 示例，包含客户端和服务器代码。客户端发送随机生成的文本消息并接收服务器响应，服务器接收客户端消息并回显。客户端通过连接本地主机的 2236 端口进行通信，服务器在 127.0.0.1 的 2236 端口监听新连接。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2022/20220306170927"}},{"title":"隐式共享的QJsonArray对象，非const遍历会导致一次内存拷贝","date":"2021-11-17T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.605,"time":96300,"words":321},"slug":"2021/20211117122510","path":"blog/2021/20211117122510","filePath":"blog/2021/20211117122510.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"隐式共享的QJsonArray对象，非const遍历会导致一次内存拷贝","datePublished":"2021-11-17T00:00:00.000Z","dateModified":"2021-11-17T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20211117122510"}},{"title":"visual studio修改堆栈保留大小和提交大小","date":"2021-11-03T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.775,"time":46500,"words":155},"slug":"2021/20211103112713","path":"blog/2021/20211103112713","filePath":"blog/2021/20211103112713.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"visual studio修改堆栈保留大小和提交大小","datePublished":"2021-11-03T00:00:00.000Z","dateModified":"2021-11-03T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20211103112713"}},{"title":"bat常用命令","date":"2021-10-28T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.51,"time":90600,"words":302},"slug":"2021/20211028195907","path":"blog/2021/20211028195907","filePath":"blog/2021/20211028195907.mdx","toc":[{"value":"当前所执行bat文件的路径","url":"#当前所执行bat文件的路径","depth":1},{"value":"设置变量","url":"#设置变量","depth":1},{"value":"使用变量，注意路径中可能有空格要加双引号","url":"#使用变量注意路径中可能有空格要加双引号","depth":1},{"value":"强制杀死进程","url":"#强制杀死进程","depth":1},{"value":"删除文件","url":"#删除文件","depth":1},{"value":"删除目录","url":"#删除目录","depth":1},{"value":"拷贝文件，自动确认","url":"#拷贝文件自动确认","depth":1},{"value":"拷贝文件到目录","url":"#拷贝文件到目录","depth":1},{"value":"判断目录存在再删除","url":"#判断目录存在再删除","depth":1},{"value":"调用其他脚本","url":"#调用其他脚本","depth":1},{"value":"7z.exe生成压缩文件","url":"#7zexe生成压缩文件","depth":1},{"value":"7z转zip","url":"#7z转zip","depth":1},{"value":"7z解压排除文件","url":"#7z解压排除文件","depth":1},{"value":"查询任务管理器中的进程IMECMNT.exe的会话ID","url":"#查询任务管理器中的进程imecmntexe的会话id","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"bat常用命令","datePublished":"2021-10-28T00:00:00.000Z","dateModified":"2021-10-28T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20211028195907"}},{"title":"boost命令行解析","date":"2021-08-13T00:00:00.000Z","tags":["Boost"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.455,"time":87300,"words":291},"slug":"2021/20210813094249","path":"blog/2021/20210813094249","filePath":"blog/2021/20210813094249.mdx","toc":[{"value":"头文件","url":"#头文件","depth":1},{"value":"增加描述信息","url":"#增加描述信息","depth":1},{"value":"解析","url":"#解析","depth":1},{"value":"获取值","url":"#获取值","depth":1},{"value":"使用方法","url":"#使用方法","depth":1},{"value":"异常","url":"#异常","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"boost命令行解析","datePublished":"2021-08-13T00:00:00.000Z","dateModified":"2021-08-13T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210813094249"}},{"title":"golang 下载大文件进度","date":"2021-08-13T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.915,"time":54900,"words":183},"slug":"2021/20210813191937","path":"blog/2021/20210813191937","filePath":"blog/2021/20210813191937.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang 下载大文件进度","datePublished":"2021-08-13T00:00:00.000Z","dateModified":"2021-08-13T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210813191937"}},{"title":"卸载程序——自删除","date":"2021-08-10T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.66,"time":99600,"words":332},"slug":"2021/20210810191653","path":"blog/2021/20210810191653","filePath":"blog/2021/20210810191653.mdx","toc":[{"value":"问题","url":"#问题","depth":1},{"value":"分析","url":"#分析","depth":1},{"value":"解决方法","url":"#解决方法","depth":1},{"value":"生成delme.bat文件","url":"#生成delmebat文件","depth":2},{"value":"在退出的前一刻执行delme.bat","url":"#在退出的前一刻执行delmebat","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"卸载程序——自删除","datePublished":"2021-08-10T00:00:00.000Z","dateModified":"2021-08-10T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210810191653"}},{"title":"Qt怎样将gif作为窗口背景","date":"2021-08-10T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.81,"time":48600,"words":162},"slug":"2021/20210810194503","path":"blog/2021/20210810194503","filePath":"blog/2021/20210810194503.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt怎样将gif作为窗口背景","datePublished":"2021-08-10T00:00:00.000Z","dateModified":"2021-08-10T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210810194503"}},{"title":"Python 更新xml文件非常方便","date":"2021-07-25T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"文章介绍 Python 更新 xml 文件很方便，起初查找相关库眼花缭乱，后找到方法。通过`updateAppCfg`函数，可修改`app.xml`中`startup`下`project`和`version`的文本内容，最终成功更新。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.66,"time":39600,"words":132},"slug":"2021/20210725113948","path":"blog/2021/20210725113948","filePath":"blog/2021/20210725113948.mdx","toc":[{"value":"xml原文","url":"#xml原文","depth":1},{"value":"修改project和version的文本内容","url":"#修改project和version的文本内容","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 更新xml文件非常方便","datePublished":"2021-07-25T00:00:00.000Z","dateModified":"2021-07-25T00:00:00.000Z","description":"文章介绍 Python 更新 xml 文件很方便，起初查找相关库眼花缭乱，后找到方法。通过`updateAppCfg`函数，可修改`app.xml`中`startup`下`project`和`version`的文本内容，最终成功更新。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210725113948"}},{"title":"golang 生成目录的check list文件并校验目录","date":"2021-07-04T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍 golang 生成目录的 check list 文件并校验目录的方法。可通过特定命令生成和校验，代码实现了写入和校验功能，包括遍历目录、计算 MD5 值等操作，能判断目录内容完整性。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.665,"time":159900,"words":533},"slug":"2021/20210704170805","path":"blog/2021/20210704170805","filePath":"blog/2021/20210704170805.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang 生成目录的check list文件并校验目录","datePublished":"2021-07-04T00:00:00.000Z","dateModified":"2021-07-04T00:00:00.000Z","description":"文章介绍 golang 生成目录的 check list 文件并校验目录的方法。可通过特定命令生成和校验，代码实现了写入和校验功能，包括遍历目录、计算 MD5 值等操作，能判断目录内容完整性。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210704170805"}},{"title":"多个Qt程序共享公共库","date":"2021-06-22T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.825,"time":169500,"words":565},"slug":"2021/20210622203918","path":"blog/2021/20210622203918","filePath":"blog/2021/20210622203918.mdx","toc":[{"value":"目的","url":"#目的","depth":1},{"value":"实现","url":"#实现","depth":1},{"value":"plugin查找","url":"#plugin查找","depth":2},{"value":"common目录","url":"#common目录","depth":2},{"value":"让应用程序加载common","url":"#让应用程序加载common","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"多个Qt程序共享公共库","datePublished":"2021-06-22T00:00:00.000Z","dateModified":"2021-06-22T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210622203918"}},{"title":"datetime封装常用功能","date":"2021-06-11T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"10 min read","minutes":9.215,"time":552900,"words":1843},"slug":"2021/20210611104617","path":"blog/2021/20210611104617","filePath":"blog/2021/20210611104617.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"datetime封装常用功能","datePublished":"2021-06-11T00:00:00.000Z","dateModified":"2021-06-11T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210611104617"}},{"title":"boost类型转换异常捕获","date":"2021-06-11T00:00:00.000Z","tags":["Boost"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.695,"time":101700,"words":339},"slug":"2021/20210611105105","path":"blog/2021/20210611105105","filePath":"blog/2021/20210611105105.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"boost类型转换异常捕获","datePublished":"2021-06-11T00:00:00.000Z","dateModified":"2021-06-11T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210611105105"}},{"title":"robotgo模拟鼠标键盘操作","date":"2021-06-08T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍用 robotgo 库实现自动化过程，包括打开记事本输入当前日期保存并关闭，还可全局监听键盘事件退出程序，以及录入回放功能，可将动作写入本地文件或读取执行。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.53,"time":271800,"words":906},"slug":"2021/20210608172805","path":"blog/2021/20210608172805","filePath":"blog/2021/20210608172805.mdx","toc":[{"value":"自动化记事本","url":"#自动化记事本","depth":1},{"value":"录入回放","url":"#录入回放","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"robotgo模拟鼠标键盘操作","datePublished":"2021-06-08T00:00:00.000Z","dateModified":"2021-06-08T00:00:00.000Z","description":"文章介绍用 robotgo 库实现自动化过程，包括打开记事本输入当前日期保存并关闭，还可全局监听键盘事件退出程序，以及录入回放功能，可将动作写入本地文件或读取执行。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210608172805"}},{"title":"Python codingbat练习一下","date":"2021-06-04T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"27 min read","minutes":26.415,"time":1584900,"words":5283},"slug":"2021/20210604133556","path":"blog/2021/20210604133556","filePath":"blog/2021/20210604133556.mdx","toc":[{"value":"Warmup-1","url":"#warmup-1","depth":1},{"value":"sleep_in","url":"#sleep_in","depth":2},{"value":"monkey_trouble","url":"#monkey_trouble","depth":2},{"value":"sum_double","url":"#sum_double","depth":2},{"value":"diff21","url":"#diff21","depth":2},{"value":"parrot_trouble","url":"#parrot_trouble","depth":2},{"value":"makes10","url":"#makes10","depth":2},{"value":"near_hundred","url":"#near_hundred","depth":2},{"value":"pos_neg","url":"#pos_neg","depth":2},{"value":"not_string","url":"#not_string","depth":2},{"value":"missing_char","url":"#missing_char","depth":2},{"value":"front_back","url":"#front_back","depth":2},{"value":"front3","url":"#front3","depth":2},{"value":"Warmup-2","url":"#warmup-2","depth":1},{"value":"string_times","url":"#string_times","depth":2},{"value":"front_times","url":"#front_times","depth":2},{"value":"string_bits","url":"#string_bits","depth":2},{"value":"string_splosion","url":"#string_splosion","depth":2},{"value":"last2","url":"#last2","depth":2},{"value":"array_count9","url":"#array_count9","depth":2},{"value":"array_front9","url":"#array_front9","depth":2},{"value":"array123","url":"#array123","depth":2},{"value":"string_match","url":"#string_match","depth":2},{"value":"String-1","url":"#string-1","depth":1},{"value":"hello_name","url":"#hello_name","depth":2},{"value":"make_abba","url":"#make_abba","depth":2},{"value":"make_tags","url":"#make_tags","depth":2},{"value":"make_out_word","url":"#make_out_word","depth":2},{"value":"extra_end","url":"#extra_end","depth":2},{"value":"first_two","url":"#first_two","depth":2},{"value":"first_half","url":"#first_half","depth":2},{"value":"without_end","url":"#without_end","depth":2},{"value":"combo_string","url":"#combo_string","depth":2},{"value":"non_start","url":"#non_start","depth":2},{"value":"left2","url":"#left2","depth":2},{"value":"List-1","url":"#list-1","depth":1},{"value":"first_last6","url":"#first_last6","depth":2},{"value":"same_first_last","url":"#same_first_last","depth":2},{"value":"make_pi","url":"#make_pi","depth":2},{"value":"common_end","url":"#common_end","depth":2},{"value":"sum3","url":"#sum3","depth":2},{"value":"rotate_left3","url":"#rotate_left3","depth":2},{"value":"reverse3","url":"#reverse3","depth":2},{"value":"max_end3","url":"#max_end3","depth":2},{"value":"sum2","url":"#sum2","depth":2},{"value":"middle_way","url":"#middle_way","depth":2},{"value":"make_ends","url":"#make_ends","depth":2},{"value":"has23","url":"#has23","depth":2},{"value":"Logic-1","url":"#logic-1","depth":1},{"value":"cigar_party","url":"#cigar_party","depth":2},{"value":"date_fashion","url":"#date_fashion","depth":2},{"value":"squirrel_play","url":"#squirrel_play","depth":2},{"value":"caught_speeding","url":"#caught_speeding","depth":2},{"value":"sorta_sum","url":"#sorta_sum","depth":2},{"value":"alarm_clock","url":"#alarm_clock","depth":2},{"value":"love6","url":"#love6","depth":2},{"value":"in1to10","url":"#in1to10","depth":2},{"value":"near_ten","url":"#near_ten","depth":2},{"value":"Logic-2","url":"#logic-2","depth":1},{"value":"make_bricks","url":"#make_bricks","depth":2},{"value":"lone_sum","url":"#lone_sum","depth":2},{"value":"lucky_sum","url":"#lucky_sum","depth":2},{"value":"no_teen_sum","url":"#no_teen_sum","depth":2},{"value":"round_sum","url":"#round_sum","depth":2},{"value":"close_far","url":"#close_far","depth":2},{"value":"make_chocolate","url":"#make_chocolate","depth":2},{"value":"String-2","url":"#string-2","depth":1},{"value":"double_char","url":"#double_char","depth":2},{"value":"count_hi","url":"#count_hi","depth":2},{"value":"cat_dog","url":"#cat_dog","depth":2},{"value":"count_code","url":"#count_code","depth":2},{"value":"end_other","url":"#end_other","depth":2},{"value":"xyz_there","url":"#xyz_there","depth":2},{"value":"List-2","url":"#list-2","depth":1},{"value":"count_evens","url":"#count_evens","depth":2},{"value":"big_diff","url":"#big_diff","depth":2},{"value":"centered_average","url":"#centered_average","depth":2},{"value":"sum13","url":"#sum13","depth":2},{"value":"sum67","url":"#sum67","depth":2},{"value":"has22","url":"#has22","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python codingbat练习一下","datePublished":"2021-06-04T00:00:00.000Z","dateModified":"2021-06-04T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210604133556"}},{"title":"Python 统计项目代码行数","date":"2021-06-03T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.865,"time":171900,"words":573},"slug":"2021/20210603173706","path":"blog/2021/20210603173706","filePath":"blog/2021/20210603173706.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 统计项目代码行数","datePublished":"2021-06-03T00:00:00.000Z","dateModified":"2021-06-03T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210603173706"}},{"title":"Python 列表、字典的几种遍历方式","date":"2021-06-03T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.605,"time":96300,"words":321},"slug":"2021/20210603175505","path":"blog/2021/20210603175505","filePath":"blog/2021/20210603175505.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 列表、字典的几种遍历方式","datePublished":"2021-06-03T00:00:00.000Z","dateModified":"2021-06-03T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210603175505"}},{"title":"Solution - Find your Unicorn Name - StudioX Project","date":"2021-06-01T00:00:00.000Z","tags":["Others"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.025,"time":301500,"words":1005},"slug":"2021/20210601123035","path":"blog/2021/20210601123035","filePath":"blog/2021/20210601123035.mdx","toc":[{"value":"安装","url":"#安装","depth":1},{"value":"准备","url":"#准备","depth":1},{"value":"目的","url":"#目的","depth":1},{"value":"使用","url":"#使用","depth":1},{"value":"Use Excel File","url":"#use-excel-file","depth":2},{"value":"Use Application/Browser","url":"#use-applicationbrowser","depth":2},{"value":"Type Into","url":"#type-into","depth":2},{"value":"Select Item","url":"#select-item","depth":2},{"value":"Click","url":"#click","depth":2},{"value":"Get Text","url":"#get-text","depth":2},{"value":"运行","url":"#运行","depth":2},{"value":"完整图","url":"#完整图","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Solution - Find your Unicorn Name - StudioX Project","datePublished":"2021-06-01T00:00:00.000Z","dateModified":"2021-06-01T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210601123035"}},{"title":"MySql查询前一条后一条记录","date":"2021-06-01T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.175,"time":70500,"words":235},"slug":"2021/20210601170825","path":"blog/2021/20210601170825","filePath":"blog/2021/20210601170825.mdx","toc":[{"value":"方法一","url":"#方法一","depth":1},{"value":"方法二","url":"#方法二","depth":1},{"value":"方法三","url":"#方法三","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySql查询前一条后一条记录","datePublished":"2021-06-01T00:00:00.000Z","dateModified":"2021-06-01T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210601170825"}},{"title":"boost asio + protobuf封装通信库","date":"2021-05-28T00:00:00.000Z","tags":["C/C++","Boost"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"13 min read","minutes":12.405,"time":744300,"words":2481},"slug":"2021/20210528103534","path":"blog/2021/20210528103534","filePath":"blog/2021/20210528103534.mdx","toc":[{"value":"特点","url":"#特点","depth":1},{"value":"请求应答代码演示","url":"#请求应答代码演示","depth":1},{"value":"推送订阅代码演示","url":"#推送订阅代码演示","depth":1},{"value":"项目结构介绍","url":"#项目结构介绍","depth":1},{"value":"自定义协议","url":"#自定义协议","depth":1},{"value":"包头","url":"#包头","depth":2},{"value":"包体","url":"#包体","depth":2},{"value":"包的编解码","url":"#包的编解码","depth":2},{"value":"client封装","url":"#client封装","depth":1},{"value":"服务端封装","url":"#服务端封装","depth":1},{"value":"session管理","url":"#session管理","depth":1},{"value":"任务管理","url":"#任务管理","depth":1},{"value":"Buffer二进制流处理","url":"#buffer二进制流处理","depth":1},{"value":"日志","url":"#日志","depth":1},{"value":"包压缩","url":"#包压缩","depth":1},{"value":"msgbus","url":"#msgbus","depth":1},{"value":"源码地址","url":"#源码地址","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"boost asio + protobuf封装通信库","datePublished":"2021-05-28T00:00:00.000Z","dateModified":"2021-05-28T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210528103534"}},{"title":"业界消息总线技术分析-ZeroMQ","date":"2021-05-26T00:00:00.000Z","tags":["MQ"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"52 min read","minutes":52,"time":3120000,"words":10400},"slug":"2021/20210526145420","path":"blog/2021/20210526145420","filePath":"blog/2021/20210526145420.mdx","toc":[{"value":"ZeroMQ的设计理念","url":"#zeromq的设计理念","depth":1},{"value":"为什么需要ZeroMQ","url":"#为什么需要zeromq","depth":1},{"value":"应用场景","url":"#应用场景","depth":1},{"value":"总体架构图","url":"#总体架构图","depth":1},{"value":"线程模型","url":"#线程模型","depth":1},{"value":"I/O线程","url":"#io线程","depth":2},{"value":"回收线程","url":"#回收线程","depth":2},{"value":"特性","url":"#特性","depth":1},{"value":"消息分配","url":"#消息分配","depth":2},{"value":"批量处理","url":"#批量处理","depth":2},{"value":"并发模型","url":"#并发模型","depth":2},{"value":"无锁队列","url":"#无锁队列","depth":2},{"value":"多种通讯模式","url":"#多种通讯模式","depth":2},{"value":"Request-reply 模式","url":"#request-reply-模式","depth":3},{"value":"Publish-subscribe模式","url":"#publish-subscribe模式","depth":3},{"value":"Pipeline模式","url":"#pipeline模式","depth":3},{"value":"Exclusive pair模式","url":"#exclusive-pair模式","depth":3},{"value":"性能分析","url":"#性能分析","depth":1},{"value":"横向对比","url":"#横向对比","depth":1},{"value":"总结","url":"#总结","depth":1},{"value":"简单","url":"#简单","depth":2},{"value":"灵活","url":"#灵活","depth":2},{"value":"跨平台","url":"#跨平台","depth":2},{"value":"多语言","url":"#多语言","depth":2},{"value":"高性能","url":"#高性能","depth":2},{"value":"参考资料","url":"#参考资料","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"业界消息总线技术分析-ZeroMQ","datePublished":"2021-05-26T00:00:00.000Z","dateModified":"2021-05-26T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210526145420"}},{"title":"ZMQ DEMO 请求应答模式","date":"2021-05-26T00:00:00.000Z","tags":["MQ"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.025,"time":61500,"words":205},"slug":"2021/20210526162241","path":"blog/2021/20210526162241","filePath":"blog/2021/20210526162241.mdx","toc":[{"value":"介绍","url":"#介绍","depth":1},{"value":"示例说明","url":"#示例说明","depth":1},{"value":"代码","url":"#代码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ZMQ DEMO 请求应答模式","datePublished":"2021-05-26T00:00:00.000Z","dateModified":"2021-05-26T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210526162241"}},{"title":"ZMQ DEMO 发布订阅模式-进程内","date":"2021-05-26T00:00:00.000Z","tags":["MQ"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.395,"time":143700,"words":479},"slug":"2021/20210526162401","path":"blog/2021/20210526162401","filePath":"blog/2021/20210526162401.mdx","toc":[{"value":"简介","url":"#简介","depth":1},{"value":"示例说明","url":"#示例说明","depth":1},{"value":"代码","url":"#代码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ZMQ DEMO 发布订阅模式-进程内","datePublished":"2021-05-26T00:00:00.000Z","dateModified":"2021-05-26T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210526162401"}},{"title":"ZMQ DEMO pull方法的使用","date":"2021-05-26T00:00:00.000Z","tags":["MQ"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.33,"time":199800,"words":666},"slug":"2021/20210526163008","path":"blog/2021/20210526163008","filePath":"blog/2021/20210526163008.mdx","toc":[{"value":"多个socket recv","url":"#多个socket-recv","depth":1},{"value":"介绍poll","url":"#介绍poll","depth":1},{"value":"poll代码演示","url":"#poll代码演示","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ZMQ DEMO pull方法的使用","datePublished":"2021-05-26T00:00:00.000Z","dateModified":"2021-05-26T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210526163008"}},{"title":"ZMQ DEMO 分布式处理","date":"2021-05-26T00:00:00.000Z","tags":["MQ"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.205,"time":132300,"words":441},"slug":"2021/20210526163228","path":"blog/2021/20210526163228","filePath":"blog/2021/20210526163228.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ZMQ DEMO 分布式处理","datePublished":"2021-05-26T00:00:00.000Z","dateModified":"2021-05-26T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210526163228"}},{"title":"ZMQ DEMO 发布订阅模式","date":"2021-05-26T00:00:00.000Z","tags":["MQ"],"draft":false,"summary":"ZMQ DEMO 发布订阅模式，一端发布多端接收。发布者每秒推送气象信息，订阅者可接收所有或特定开头信息。示例代码展示了发布者和订阅者的实现，包括绑定和连接等操作。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.335,"time":80100,"words":267},"slug":"2021/20210526163504","path":"blog/2021/20210526163504","filePath":"blog/2021/20210526163504.mdx","toc":[{"value":"简介","url":"#简介","depth":1},{"value":"发布者","url":"#发布者","depth":1},{"value":"订阅者","url":"#订阅者","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ZMQ DEMO 发布订阅模式","datePublished":"2021-05-26T00:00:00.000Z","dateModified":"2021-05-26T00:00:00.000Z","description":"ZMQ DEMO 发布订阅模式，一端发布多端接收。发布者每秒推送气象信息，订阅者可接收所有或特定开头信息。示例代码展示了发布者和订阅者的实现，包括绑定和连接等操作。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210526163504"}},{"title":"ZMQ DEMO push pull 模式","date":"2021-05-26T00:00:00.000Z","tags":["MQ"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.08,"time":64800,"words":216},"slug":"2021/20210526163650","path":"blog/2021/20210526163650","filePath":"blog/2021/20210526163650.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ZMQ DEMO push pull 模式","datePublished":"2021-05-26T00:00:00.000Z","dateModified":"2021-05-26T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210526163650"}},{"title":"ZMQ DEMO send_multipart方法的使用","date":"2021-05-26T00:00:00.000Z","tags":["MQ"],"draft":false,"summary":"本文介绍了 ZMQ DEMO 中 send_multipart 方法的使用。在同一进程内演示多包同时收发，通过创建上下文、套接字并绑定连接，使用 send_multipart 发送消息，recv_multipart 接收消息，最后输出结果。  \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.53,"time":31800,"words":106},"slug":"2021/20210526164110","path":"blog/2021/20210526164110","filePath":"blog/2021/20210526164110.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ZMQ DEMO send_multipart方法的使用","datePublished":"2021-05-26T00:00:00.000Z","dateModified":"2021-05-26T00:00:00.000Z","description":"本文介绍了 ZMQ DEMO 中 send_multipart 方法的使用。在同一进程内演示多包同时收发，通过创建上下文、套接字并绑定连接，使用 send_multipart 发送消息，recv_multipart 接收消息，最后输出结果。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210526164110"}},{"title":"ZMQ DEMO proxy代理模式","date":"2021-05-26T00:00:00.000Z","tags":["MQ"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.375,"time":22500,"words":75},"slug":"2021/20210526164445","path":"blog/2021/20210526164445","filePath":"blog/2021/20210526164445.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ZMQ DEMO proxy代理模式","datePublished":"2021-05-26T00:00:00.000Z","dateModified":"2021-05-26T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210526164445"}},{"title":"ntscreenshot截图工具开源了","date":"2021-05-21T00:00:00.000Z","tags":["Windows","Qt"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.855,"time":111300,"words":371},"slug":"2021/20210521152616","path":"blog/2021/20210521152616","filePath":"blog/2021/20210521152616.mdx","toc":[{"value":"ntscreenshot介绍","url":"#ntscreenshot介绍","depth":1},{"value":"开发环境","url":"#开发环境","depth":1},{"value":"基本的截图功能","url":"#基本的截图功能","depth":1},{"value":"贴图","url":"#贴图","depth":1},{"value":"标注","url":"#标注","depth":1},{"value":"上传图床","url":"#上传图床","depth":1},{"value":"设置","url":"#设置","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ntscreenshot截图工具开源了","datePublished":"2021-05-21T00:00:00.000Z","dateModified":"2021-05-21T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210521152616"}},{"title":"接入腾讯AI智能闲聊API接口","date":"2021-05-20T00:00:00.000Z","tags":["Tools","Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.1,"time":186000,"words":620},"slug":"2021/20210520080220","path":"blog/2021/20210520080220","filePath":"blog/2021/20210520080220.mdx","toc":[{"value":"创建应用","url":"#创建应用","depth":1},{"value":"接口鉴权","url":"#接口鉴权","depth":1},{"value":"http请求","url":"#http请求","depth":1},{"value":"智能闲聊web页面","url":"#智能闲聊web页面","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"接入腾讯AI智能闲聊API接口","datePublished":"2021-05-20T00:00:00.000Z","dateModified":"2021-05-20T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210520080220"}},{"title":"Python批量替换博客中七牛云图片地址","date":"2021-05-20T00:00:00.000Z","tags":["Python"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.76,"time":105600,"words":352},"slug":"2021/20210520144710","path":"blog/2021/20210520144710","filePath":"blog/2021/20210520144710.mdx","toc":[{"value":"替换图片地址","url":"#替换图片地址","depth":1},{"value":"步骤","url":"#步骤","depth":1},{"value":"代码","url":"#代码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python批量替换博客中七牛云图片地址","datePublished":"2021-05-20T00:00:00.000Z","dateModified":"2021-05-20T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210520144710"}},{"title":"Go 实现简单端口扫描","date":"2021-05-14T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.295,"time":197700,"words":659},"slug":"2021/20210514171404","path":"blog/2021/20210514171404","filePath":"blog/2021/20210514171404.mdx","toc":[{"value":"主结构","url":"#主结构","depth":1},{"value":"扫描单个端口","url":"#扫描单个端口","depth":1},{"value":"批量扫描端口","url":"#批量扫描端口","depth":1},{"value":"完整代码","url":"#完整代码","depth":1},{"value":"使用","url":"#使用","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go 实现简单端口扫描","datePublished":"2021-05-14T00:00:00.000Z","dateModified":"2021-05-14T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210514171404"}},{"title":"Go 使用zip压缩文件目录","date":"2021-05-12T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.585,"time":95100,"words":317},"slug":"2021/20210512093728","path":"blog/2021/20210512093728","filePath":"blog/2021/20210512093728.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go 使用zip压缩文件目录","datePublished":"2021-05-12T00:00:00.000Z","dateModified":"2021-05-12T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210512093728"}},{"title":"Go 使用gomail发送邮件，包括附件","date":"2021-05-12T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.7,"time":162000,"words":540},"slug":"2021/20210512100158","path":"blog/2021/20210512100158","filePath":"blog/2021/20210512100158.mdx","toc":[{"value":"准备","url":"#准备","depth":1},{"value":"写邮件","url":"#写邮件","depth":1},{"value":"压缩目录","url":"#压缩目录","depth":1},{"value":"源码","url":"#源码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go 使用gomail发送邮件，包括附件","datePublished":"2021-05-12T00:00:00.000Z","dateModified":"2021-05-12T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210512100158"}},{"title":"截图软件窗口自动识别实现","date":"2021-05-10T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"7 min read","minutes":6.1,"time":366000,"words":1220},"slug":"2021/20210510143220","path":"blog/2021/20210510143220","filePath":"blog/2021/20210510143220.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"截图软件窗口自动识别实现","datePublished":"2021-05-10T00:00:00.000Z","dateModified":"2021-05-10T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210510143220"}},{"title":"推送消息版本号的设计与使用问题","date":"2021-04-23T00:00:00.000Z","tags":["Design"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.925,"time":295500,"words":985},"slug":"2021/20210423181836","path":"blog/2021/20210423181836","filePath":"blog/2021/20210423181836.mdx","toc":[{"value":"为什么要推送的版本号","url":"#为什么要推送的版本号","depth":1},{"value":"客户端接收推送消息版本号处理","url":"#客户端接收推送消息版本号处理","depth":1},{"value":"服务端推送消息","url":"#服务端推送消息","depth":1},{"value":"请求应答和推送带来的问题","url":"#请求应答和推送带来的问题","depth":1},{"value":"问题一","url":"#问题一","depth":2},{"value":"问题二","url":"#问题二","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"推送消息版本号的设计与使用问题","datePublished":"2021-04-23T00:00:00.000Z","dateModified":"2021-04-23T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210423181836"}},{"title":"Qt 绘制简单QPixmap","date":"2021-04-19T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.115,"time":126900,"words":423},"slug":"2021/20210419115211","path":"blog/2021/20210419115211","filePath":"blog/2021/20210419115211.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt 绘制简单QPixmap","datePublished":"2021-04-19T00:00:00.000Z","dateModified":"2021-04-19T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210419115211"}},{"title":"Qt 更改Object Name显示指定的样式","date":"2021-04-13T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.355,"time":141300,"words":471},"slug":"2021/20210413141122","path":"blog/2021/20210413141122","filePath":"blog/2021/20210413141122.mdx","toc":[{"value":"背景","url":"#背景","depth":1},{"value":"需求","url":"#需求","depth":1},{"value":"代码","url":"#代码","depth":1},{"value":"结论","url":"#结论","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt 更改Object Name显示指定的样式","datePublished":"2021-04-13T00:00:00.000Z","dateModified":"2021-04-13T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210413141122"}},{"title":"DLL注入和卸载","date":"2021-04-08T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.565,"time":213900,"words":713},"slug":"2021/20210408103516","path":"blog/2021/20210408103516","filePath":"blog/2021/20210408103516.mdx","toc":[{"value":"注入程序","url":"#注入程序","depth":1},{"value":"使用方法","url":"#使用方法","depth":1},{"value":"dll测试代码","url":"#dll测试代码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"DLL注入和卸载","datePublished":"2021-04-08T00:00:00.000Z","dateModified":"2021-04-08T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210408103516"}},{"title":"界面之下：还原真实的 MVC、MVP、MVVM 模式","date":"2021-03-30T00:00:00.000Z","tags":["Design"],"draft":false,"summary":"文章介绍了 MVC、MVP、MVVM 模式，从历史背景、依赖关系、调用关系、优缺点等方面进行阐述。MVC 有 Controller 层，通过观察者模式同步 View 和 Model；MVP 用 Presenter 替代 Controller，View 提供接口给 Presenter 同步；MVVM 是特殊的 MVP，用双向数据绑定的 Binder 自动同步 View 和 Model，各有优劣，可提高可维护性和简化测试。 \r","type":"Blog","readingTime":{"text":"20 min read","minutes":19.475,"time":1168500,"words":3895},"slug":"2021/20210330103210","path":"blog/2021/20210330103210","filePath":"blog/2021/20210330103210.mdx","toc":[{"value":"前言","url":"#前言","depth":1},{"value":"GUI程序所面临的问题","url":"#gui程序所面临的问题","depth":1},{"value":"Smalltalk-80 MVC","url":"#smalltalk-80-mvc","depth":1},{"value":"历史背景","url":"#历史背景","depth":2},{"value":"MVC的依赖关系","url":"#mvc的依赖关系","depth":2},{"value":"MVC的调用关系","url":"#mvc的调用关系","depth":2},{"value":"MVC的优缺点","url":"#mvc的优缺点","depth":2},{"value":"MVC Model 2","url":"#mvc-model-2","depth":2},{"value":"MVP","url":"#mvp","depth":1},{"value":"历史背景","url":"#历史背景-1","depth":2},{"value":"MVP（Passive View）的依赖关系","url":"#mvppassive-view的依赖关系","depth":2},{"value":"MVP（Passive View）的调用关系","url":"#mvppassive-view的调用关系","depth":2},{"value":"MVP（Passive View）的优缺点","url":"#mvppassive-view的优缺点","depth":2},{"value":"MVP（Supervising Controller）","url":"#mvpsupervising-controller","depth":2},{"value":"MVVM","url":"#mvvm","depth":1},{"value":"历史背景","url":"#历史背景-2","depth":2},{"value":"ViewModel","url":"#viewmodel","depth":2},{"value":"MVVM的依赖","url":"#mvvm的依赖","depth":2},{"value":"MVVM的调用关系","url":"#mvvm的调用关系","depth":2},{"value":"MVVM的优缺点","url":"#mvvm的优缺点","depth":2},{"value":"结语","url":"#结语","depth":1},{"value":"参考","url":"#参考","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"界面之下：还原真实的 MVC、MVP、MVVM 模式","datePublished":"2021-03-30T00:00:00.000Z","dateModified":"2021-03-30T00:00:00.000Z","description":"文章介绍了 MVC、MVP、MVVM 模式，从历史背景、依赖关系、调用关系、优缺点等方面进行阐述。MVC 有 Controller 层，通过观察者模式同步 View 和 Model；MVP 用 Presenter 替代 Controller，View 提供接口给 Presenter 同步；MVVM 是特殊的 MVP，用双向数据绑定的 Binder 自动同步 View 和 Model，各有优劣，可提高可维护性和简化测试。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210330103210"}},{"title":"Go寻找最长不含有重复字符的子串","date":"2021-03-27T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.555,"time":93300,"words":311},"slug":"2021/20210327191951","path":"blog/2021/20210327191951","filePath":"blog/2021/20210327191951.mdx","toc":[{"value":"思路","url":"#思路","depth":1},{"value":"算法","url":"#算法","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go寻找最长不含有重复字符的子串","datePublished":"2021-03-27T00:00:00.000Z","dateModified":"2021-03-27T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210327191951"}},{"title":"Go竞态检测","date":"2021-03-23T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.24,"time":314400,"words":1048},"slug":"2021/20210323141842","path":"blog/2021/20210323141842","filePath":"blog/2021/20210323141842.mdx","toc":[{"value":"介绍","url":"#介绍","depth":1},{"value":"工作原理","url":"#工作原理","depth":1},{"value":"使用竞态检测","url":"#使用竞态检测","depth":1},{"value":"示例1，Timer.Reset","url":"#示例1timerreset","depth":1},{"value":"示例2，ioutil.Discard","url":"#示例2ioutildiscard","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go竞态检测","datePublished":"2021-03-23T00:00:00.000Z","dateModified":"2021-03-23T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210323141842"}},{"title":"Go Buffer重用，避免频繁内存分配","date":"2021-03-23T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.525,"time":91500,"words":305},"slug":"2021/20210323150755","path":"blog/2021/20210323150755","filePath":"blog/2021/20210323150755.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go Buffer重用，避免频繁内存分配","datePublished":"2021-03-23T00:00:00.000Z","dateModified":"2021-03-23T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210323150755"}},{"title":"Golang pipeline模式","date":"2021-03-22T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.74,"time":224400,"words":748},"slug":"2021/20210322151528","path":"blog/2021/20210322151528","filePath":"blog/2021/20210322151528.mdx","toc":[{"value":"什么是质数","url":"#什么是质数","depth":1},{"value":"C++代码实现","url":"#c代码实现","depth":1},{"value":"Golang pipeline实现","url":"#golang-pipeline实现","depth":1},{"value":"Golang 并行实现","url":"#golang-并行实现","depth":1},{"value":"结论","url":"#结论","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang pipeline模式","datePublished":"2021-03-22T00:00:00.000Z","dateModified":"2021-03-22T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210322151528"}},{"title":"gorm写入数据库后时间差8小时","date":"2021-03-19T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.665,"time":39900,"words":133},"slug":"2021/20210319110107","path":"blog/2021/20210319110107","filePath":"blog/2021/20210319110107.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"gorm写入数据库后时间差8小时","datePublished":"2021-03-19T00:00:00.000Z","dateModified":"2021-03-19T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210319110107"}},{"title":"Qt QTextEdit文本高亮","date":"2021-03-16T00:00:00.000Z","tags":["Qt","C/C++"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.015,"time":60900,"words":203},"slug":"2021/20210316051349","path":"blog/2021/20210316051349","filePath":"blog/2021/20210316051349.mdx","toc":[{"value":"需求","url":"#需求","depth":1},{"value":"实现","url":"#实现","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt QTextEdit文本高亮","datePublished":"2021-03-16T00:00:00.000Z","dateModified":"2021-03-16T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210316051349"}},{"title":"博客文章增加TOC","date":"2021-03-05T00:00:00.000Z","tags":["Web","Javascript","Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.435,"time":206100,"words":687},"slug":"2021/20210305020100","path":"blog/2021/20210305020100","filePath":"blog/2021/20210305020100.mdx","toc":[{"value":"获取所有h1标签","url":"#获取所有h1标签","depth":1},{"value":"拼装成html文本","url":"#拼装成html文本","depth":1},{"value":"引入CSS","url":"#引入css","depth":1},{"value":"结果","url":"#结果","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"博客文章增加TOC","datePublished":"2021-03-05T00:00:00.000Z","dateModified":"2021-03-05T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210305020100"}},{"title":"Chrome简单插件开发，自动初始化gitalk评论","date":"2021-03-02T00:00:00.000Z","tags":["Web","Javascript"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.045,"time":182700,"words":609},"slug":"2021/20210302105125","path":"blog/2021/20210302105125","filePath":"blog/2021/20210302105125.mdx","toc":[{"value":"gitalk增加手动初始化评论","url":"#gitalk增加手动初始化评论","depth":1},{"value":"怎样给所有以前的文章初始化评论","url":"#怎样给所有以前的文章初始化评论","depth":1},{"value":"Chrome插件编写","url":"#chrome插件编写","depth":1},{"value":"加载Chrome插件","url":"#加载chrome插件","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Chrome简单插件开发，自动初始化gitalk评论","datePublished":"2021-03-02T00:00:00.000Z","dateModified":"2021-03-02T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210302105125"}},{"title":"golang设计模式-命令模式","date":"2021-02-26T00:00:00.000Z","tags":["Go","Design"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.38,"time":202800,"words":676},"slug":"2021/20210226013534","path":"blog/2021/20210226013534","filePath":"blog/2021/20210226013534.mdx","toc":[{"value":"介绍","url":"#介绍","depth":1},{"value":"例子","url":"#例子","depth":1},{"value":"代码","url":"#代码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang设计模式-命令模式","datePublished":"2021-02-26T00:00:00.000Z","dateModified":"2021-02-26T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210226013534"}},{"title":"常用端口号","date":"2021-02-26T00:00:00.000Z","tags":["Tips"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.845,"time":50700,"words":169},"slug":"2021/20210226015636","path":"blog/2021/20210226015636","filePath":"blog/2021/20210226015636.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"常用端口号","datePublished":"2021-02-26T00:00:00.000Z","dateModified":"2021-02-26T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210226015636"}},{"title":"QWebEngineView支持https","date":"2021-02-26T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.585,"time":35100,"words":117},"slug":"2021/20210226021104","path":"blog/2021/20210226021104","filePath":"blog/2021/20210226021104.mdx","toc":[{"value":"问题","url":"#问题","depth":1},{"value":"解决","url":"#解决","depth":1},{"value":"代码","url":"#代码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QWebEngineView支持https","datePublished":"2021-02-26T00:00:00.000Z","dateModified":"2021-02-26T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210226021104"}},{"title":"C++ 多线程有序锁和无序锁","date":"2021-02-26T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.655,"time":219300,"words":731},"slug":"2021/20210226084531","path":"blog/2021/20210226084531","filePath":"blog/2021/20210226084531.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 多线程有序锁和无序锁","datePublished":"2021-02-26T00:00:00.000Z","dateModified":"2021-02-26T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210226084531"}},{"title":"Redis常见问题和解答","date":"2021-02-26T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"本文全面介绍了 Redis 的诸多方面，包括持久化机制（RDB 和 AOF）、常见问题及解决办法（如缓存雪崩、穿透等）、数据类型及使用场景、内部结构、过期策略及内存淘汰机制、线程模型、集群方案、性能问题及解决方案等，还讲解了 Redis 事务和实现分布式锁的方法，是 Redis 知识的全面汇总。 \r","type":"Blog","readingTime":{"text":"33 min read","minutes":32.855,"time":1971300,"words":6571},"slug":"2021/20210226095124","path":"blog/2021/20210226095124","filePath":"blog/2021/20210226095124.mdx","toc":[{"value":"Redis 持久化机制","url":"#redis-持久化机制","depth":1},{"value":"缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题","url":"#缓存雪崩缓存穿透缓存预热缓存更新缓存降级等问题","depth":1},{"value":"缓存雪崩","url":"#缓存雪崩","depth":2},{"value":"解决办法：","url":"#解决办法","depth":3},{"value":"缓存穿透","url":"#缓存穿透","depth":2},{"value":"解决办法：","url":"#解决办法-1","depth":3},{"value":"缓存穿透与缓存击穿的区别","url":"#缓存穿透与缓存击穿的区别","depth":3},{"value":"三、缓存预热","url":"#三缓存预热","depth":2},{"value":"四、缓存更新","url":"#四缓存更新","depth":2},{"value":"五、缓存降级","url":"#五缓存降级","depth":2},{"value":"热点数据和冷数据是什么","url":"#热点数据和冷数据是什么","depth":1},{"value":"Memcache与Redis的区别都有哪些？","url":"#memcache与redis的区别都有哪些","depth":1},{"value":"单线程的redis为什么这么快","url":"#单线程的redis为什么这么快","depth":1},{"value":"redis的数据类型，以及每种数据类型的使用场景","url":"#redis的数据类型以及每种数据类型的使用场景","depth":1},{"value":"(一)String","url":"#一string","depth":3},{"value":"(二)hash","url":"#二hash","depth":3},{"value":"(三)list","url":"#三list","depth":3},{"value":"(四)set","url":"#四set","depth":3},{"value":"(五)sorted set","url":"#五sorted-set","depth":3},{"value":"Redis 内部结构","url":"#redis-内部结构","depth":1},{"value":"redis的过期策略以及内存淘汰机制","url":"#redis的过期策略以及内存淘汰机制","depth":1},{"value":"Redis 为什么是单线程的","url":"#redis-为什么是单线程的","depth":1},{"value":"Redis 集群方案应该怎么做？都有哪些方案？","url":"#redis-集群方案应该怎么做都有哪些方案","depth":1},{"value":"有没有尝试进行多机redis 的部署？如何保证数据一致的？","url":"#有没有尝试进行多机redis-的部署如何保证数据一致的","depth":1},{"value":"对于大量的请求怎么样处理","url":"#对于大量的请求怎么样处理","depth":1},{"value":"Redis 常见性能问题和解决方案？","url":"#redis-常见性能问题和解决方案","depth":1},{"value":"讲解下Redis线程模型","url":"#讲解下redis线程模型","depth":1},{"value":"为什么Redis的操作是原子性的，怎么保证原子性的？","url":"#为什么redis的操作是原子性的怎么保证原子性的","depth":1},{"value":"Redis事务","url":"#redis事务","depth":1},{"value":"Redis实现分布式锁","url":"#redis实现分布式锁","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis常见问题和解答","datePublished":"2021-02-26T00:00:00.000Z","dateModified":"2021-02-26T00:00:00.000Z","description":"本文全面介绍了 Redis 的诸多方面，包括持久化机制（RDB 和 AOF）、常见问题及解决办法（如缓存雪崩、穿透等）、数据类型及使用场景、内部结构、过期策略及内存淘汰机制、线程模型、集群方案、性能问题及解决方案等，还讲解了 Redis 事务和实现分布式锁的方法，是 Redis 知识的全面汇总。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210226095124"}},{"title":"golang读取excel文档转换成json","date":"2021-02-25T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.22,"time":73200,"words":244},"slug":"2021/20210225053432","path":"blog/2021/20210225053432","filePath":"blog/2021/20210225053432.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang读取excel文档转换成json","datePublished":"2021-02-25T00:00:00.000Z","dateModified":"2021-02-25T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210225053432"}},{"title":"golang上传图片文件","date":"2021-02-25T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.675,"time":160500,"words":535},"slug":"2021/20210225092937","path":"blog/2021/20210225092937","filePath":"blog/2021/20210225092937.mdx","toc":[{"value":"服务端","url":"#服务端","depth":1},{"value":"服务端路由","url":"#服务端路由","depth":2},{"value":"服务端保存上传的图片","url":"#服务端保存上传的图片","depth":2},{"value":"服务端应答","url":"#服务端应答","depth":2},{"value":"客户端","url":"#客户端","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang上传图片文件","datePublished":"2021-02-25T00:00:00.000Z","dateModified":"2021-02-25T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210225092937"}},{"title":"Qt启动第三方控制台程序并读取输出内容","date":"2021-02-25T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.62,"time":37200,"words":124},"slug":"2021/20210225094206","path":"blog/2021/20210225094206","filePath":"blog/2021/20210225094206.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt启动第三方控制台程序并读取输出内容","datePublished":"2021-02-25T00:00:00.000Z","dateModified":"2021-02-25T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210225094206"}},{"title":"ntscreenshot截图工具马赛克功能实现","date":"2021-02-10T00:00:00.000Z","tags":["Windows","Qt"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.075,"time":124500,"words":415},"slug":"2021/20210210032823","path":"blog/2021/20210210032823","filePath":"blog/2021/20210210032823.mdx","toc":[{"value":"实现原理","url":"#实现原理","depth":1},{"value":"将鼠标的轨迹转化为各个色块","url":"#将鼠标的轨迹转化为各个色块","depth":1},{"value":"绘制","url":"#绘制","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ntscreenshot截图工具马赛克功能实现","datePublished":"2021-02-10T00:00:00.000Z","dateModified":"2021-02-10T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210210032823"}},{"title":"MacBook突然没网","date":"2021-02-06T00:00:00.000Z","tags":["Mac"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.445,"time":26700,"words":89},"slug":"2021/20210206111336","path":"blog/2021/20210206111336","filePath":"blog/2021/20210206111336.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"MacBook突然没网","datePublished":"2021-02-06T00:00:00.000Z","dateModified":"2021-02-06T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210206111336"}},{"title":"golang 日志文件切割、保存最大文件数","date":"2021-01-29T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.615,"time":36900,"words":123},"slug":"2021/20210129091436","path":"blog/2021/20210129091436","filePath":"blog/2021/20210129091436.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang 日志文件切割、保存最大文件数","datePublished":"2021-01-29T00:00:00.000Z","dateModified":"2021-01-29T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210129091436"}},{"title":"win32应用程序内存不足","date":"2021-01-08T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.84,"time":50400,"words":168},"slug":"2021/20210108021501","path":"blog/2021/20210108021501","filePath":"blog/2021/20210108021501.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"win32应用程序内存不足","datePublished":"2021-01-08T00:00:00.000Z","dateModified":"2021-01-08T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2021/20210108021501"}},{"title":"golang 中介者模式","date":"2020-12-10T00:00:00.000Z","tags":["Go","Design"],"draft":false,"summary":"中介者模式通过创建中介对象避免对象间直接交互。以铁路系统为例，站长充当调停者，旅客列车和货物列车通过站长交互。代码中展示了旅客列车和货物列车实现列车接口，站长实现中介者接口，通过互斥锁控制站台使用。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.595,"time":155700,"words":519},"slug":"2020/20201210083733","path":"blog/2020/20201210083733","filePath":"blog/2020/20201210083733.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang 中介者模式","datePublished":"2020-12-10T00:00:00.000Z","dateModified":"2020-12-10T00:00:00.000Z","description":"中介者模式通过创建中介对象避免对象间直接交互。以铁路系统为例，站长充当调停者，旅客列车和货物列车通过站长交互。代码中展示了旅客列车和货物列车实现列车接口，站长实现中介者接口，通过互斥锁控制站台使用。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201210083733"}},{"title":"golang 单例模式","date":"2020-12-10T00:00:00.000Z","tags":["Go","Design"],"draft":false,"summary":"总结：文章介绍 golang 单例模式，属创建型模式，提供创建对象最佳方式，通过 sync.Once 保证线程安全，示例代码展示获取单例及打印地址，多个 goroutine 打印结果相同。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.55,"time":33000,"words":110},"slug":"2020/20201210085057","path":"blog/2020/20201210085057","filePath":"blog/2020/20201210085057.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang 单例模式","datePublished":"2020-12-10T00:00:00.000Z","dateModified":"2020-12-10T00:00:00.000Z","description":"总结：文章介绍 golang 单例模式，属创建型模式，提供创建对象最佳方式，通过 sync.Once 保证线程安全，示例代码展示获取单例及打印地址，多个 goroutine 打印结果相同。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201210085057"}},{"title":"CentOS7 debuginfo-install","date":"2020-12-09T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"CentOS7 的 debuginfo-install 步骤：先允许 debuginfo 源（改 /etc/yum.repos.d/CentOS-Debuginfo.repo 中 enabled 为 1），再安装 glibc-debuginfo 和 yum-utils，最后安装调式信息包及依赖（如 libgcc 等）。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.21,"time":12600,"words":42},"slug":"2020/20201209073749","path":"blog/2020/20201209073749","filePath":"blog/2020/20201209073749.mdx","toc":[{"value":"允许debuginfo源","url":"#允许debuginfo源","depth":1},{"value":"安装debuginfo-install","url":"#安装debuginfo-install","depth":1},{"value":"安装调式信息包和依赖","url":"#安装调式信息包和依赖","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"CentOS7 debuginfo-install","datePublished":"2020-12-09T00:00:00.000Z","dateModified":"2020-12-09T00:00:00.000Z","description":"CentOS7 的 debuginfo-install 步骤：先允许 debuginfo 源（改 /etc/yum.repos.d/CentOS-Debuginfo.repo 中 enabled 为 1），再安装 glibc-debuginfo 和 yum-utils，最后安装调式信息包及依赖（如 libgcc 等）。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201209073749"}},{"title":"CentOS7 systemctl service","date":"2020-12-09T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"CentOS7 系统的 systemctl 服务介绍及示例。配置文件有[Unit]、[Service]、[Install]区块，分别用于定义元数据、服务配置和启动设置。给出两个服务配置示例及相关脚本，最后通过 systemctl daemon-reload 使其生效。 \r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.035,"time":302100,"words":1007},"slug":"2020/20201209075503","path":"blog/2020/20201209075503","filePath":"blog/2020/20201209075503.mdx","toc":[{"value":"配置简介","url":"#配置简介","depth":1},{"value":"例子","url":"#例子","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"CentOS7 systemctl service","datePublished":"2020-12-09T00:00:00.000Z","dateModified":"2020-12-09T00:00:00.000Z","description":"CentOS7 系统的 systemctl 服务介绍及示例。配置文件有[Unit]、[Service]、[Install]区块，分别用于定义元数据、服务配置和启动设置。给出两个服务配置示例及相关脚本，最后通过 systemctl daemon-reload 使其生效。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201209075503"}},{"title":"CentOS7 U盘安装  No Caching mode page found","date":"2020-12-08T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"CentOS7 优盘安装时出现“[sda] No Caching mode page found”，需耐心等待超时输出错误信息，找到 U 盘位置（如 sda4），修改安装选项第二行，将 inst.stage2 改为 hd:/dev/sda4:/，按 Ctrl+X 安装，安装后启动网络。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.76,"time":105600,"words":352},"slug":"2020/20201208024136","path":"blog/2020/20201208024136","filePath":"blog/2020/20201208024136.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"CentOS7 U盘安装  No Caching mode page found","datePublished":"2020-12-08T00:00:00.000Z","dateModified":"2020-12-08T00:00:00.000Z","description":"CentOS7 优盘安装时出现“[sda] No Caching mode page found”，需耐心等待超时输出错误信息，找到 U 盘位置（如 sda4），修改安装选项第二行，将 inst.stage2 改为 hd:/dev/sda4:/，按 Ctrl+X 安装，安装后启动网络。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201208024136"}},{"title":"CentOS6 yum The requested URL returned error  404 Not Found","date":"2020-12-07T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"CentOS6 is end-of-life with no more updates. Its online yum repos are archived. Options for running it include reinstalling with a newer version, converting to RHEL6, choosing a different distro. Doing nothing risks being hacked. Don't delay, migrate today. \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.365,"time":81900,"words":273},"slug":"2020/20201210085103","path":"blog/2020/20201210085103","filePath":"blog/2020/20201210085103.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"CentOS6 yum The requested URL returned error  404 Not Found","datePublished":"2020-12-07T00:00:00.000Z","dateModified":"2020-12-07T00:00:00.000Z","description":"CentOS6 is end-of-life with no more updates. Its online yum repos are archived. Options for running it include reinstalling with a newer version, converting to RHEL6, choosing a different distro. Doing nothing risks being hacked. Don't delay, migrate today. \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201210085103"}},{"title":"jemalloc C++实践","date":"2020-11-27T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍 jemalloc C++实践，包括下载、解压、编译安装，给出 c++ 测试源码及 CMakeLists，展示编译测试过程和链接 jemalloc 的情况，还可通过环境变量配置满足特殊要求，相关内容可参考[https://github.com/jemalloc/jemalloc/blob/dev/TUNING.md] \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.49,"time":89400,"words":298},"slug":"2020/20201127101303","path":"blog/2020/20201127101303","filePath":"blog/2020/20201127101303.mdx","toc":[{"value":"下载源码","url":"#下载源码","depth":1},{"value":"解压","url":"#解压","depth":1},{"value":"编译安装","url":"#编译安装","depth":1},{"value":"测试","url":"#测试","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"jemalloc C++实践","datePublished":"2020-11-27T00:00:00.000Z","dateModified":"2020-11-27T00:00:00.000Z","description":"介绍 jemalloc C++实践，包括下载、解压、编译安装，给出 c++ 测试源码及 CMakeLists，展示编译测试过程和链接 jemalloc 的情况，还可通过环境变量配置满足特殊要求，相关内容可参考[https://github.com/jemalloc/jemalloc/blob/dev/TUNING.md] \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201127101303"}},{"title":"C++11 实现defer","date":"2020-11-25T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"文章介绍 C++11 实现的 defer 功能，内部 lambda 表达式捕获引用，同一作用域先定义后执行。通过 define 及连接符使局部变量名唯一，使用起来方便，给出源码及用法示例，如在不同函数中使用 defer 输出特定信息。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.725,"time":103500,"words":345},"slug":"2020/20201125015634","path":"blog/2020/20201125015634","filePath":"blog/2020/20201125015634.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++11 实现defer","datePublished":"2020-11-25T00:00:00.000Z","dateModified":"2020-11-25T00:00:00.000Z","description":"文章介绍 C++11 实现的 defer 功能，内部 lambda 表达式捕获引用，同一作用域先定义后执行。通过 define 及连接符使局部变量名唯一，使用起来方便，给出源码及用法示例，如在不同函数中使用 defer 输出特定信息。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201125015634"}},{"title":"微信本地图片格式转化","date":"2020-11-21T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"PC 端微信本地图片为.dat 格式且经简单加密，可通过特定 golang 算法还原成 jpg、gif、png 格式。先读文件判断前两字符，找到对应异或值 v 后对文件字符异或还原，有 github 源码可下载转换程序。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.465,"time":207900,"words":693},"slug":"2020/20201121145256","path":"blog/2020/20201121145256","filePath":"blog/2020/20201121145256.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"微信本地图片格式转化","datePublished":"2020-11-21T00:00:00.000Z","dateModified":"2020-11-21T00:00:00.000Z","description":"PC 端微信本地图片为.dat 格式且经简单加密，可通过特定 golang 算法还原成 jpg、gif、png 格式。先读文件判断前两字符，找到对应异或值 v 后对文件字符异或还原，有 github 源码可下载转换程序。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201121145256"}},{"title":"golang vscode launch.json配置","date":"2020-11-20T00:00:00.000Z","tags":["others"],"draft":false,"summary":"文章介绍 golang vscode launch.json 配置，每次调试运行需先打开 main.go 麻烦，增加配置后可直接点击左侧 debug 按钮运行，给出了具体配置内容。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.725,"time":43500,"words":145},"slug":"2020/20201120130754","path":"blog/2020/20201120130754","filePath":"blog/2020/20201120130754.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang vscode launch.json配置","datePublished":"2020-11-20T00:00:00.000Z","dateModified":"2020-11-20T00:00:00.000Z","description":"文章介绍 golang vscode launch.json 配置，每次调试运行需先打开 main.go 麻烦，增加配置后可直接点击左侧 debug 按钮运行，给出了具体配置内容。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201120130754"}},{"title":"gin多模板、模板嵌套使用方法","date":"2020-11-14T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"介绍 gin 多模板及模板嵌套使用方法，多个页面共用主模板 frame.html，不同页面如 index.html、post.html 等在渲染时只需渲染具体页面。通过路由和模板定义及载入实现，清晰展示页面结构和内容组合。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.71,"time":162600,"words":542},"slug":"2020/20201114113612","path":"blog/2020/20201114113612","filePath":"blog/2020/20201114113612.mdx","toc":[{"value":"路由","url":"#路由","depth":1},{"value":"模板","url":"#模板","depth":1},{"value":"载入","url":"#载入","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"gin多模板、模板嵌套使用方法","datePublished":"2020-11-14T00:00:00.000Z","dateModified":"2020-11-14T00:00:00.000Z","description":"介绍 gin 多模板及模板嵌套使用方法，多个页面共用主模板 frame.html，不同页面如 index.html、post.html 等在渲染时只需渲染具体页面。通过路由和模板定义及载入实现，清晰展示页面结构和内容组合。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201114113612"}},{"title":"Qt 正确的显示窗口","date":"2020-11-06T00:00:00.000Z","tags":["Windows","Qt"],"draft":false,"summary":"文章主要讲 Qt 正确显示窗口，有多种展示情况及常见做法，如`widget->show(); widget->raise();`但存在窗口最小化后出不来等问题，给出`GraceShowWidget`函数代码可解决，测试无问题。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.175,"time":70500,"words":235},"slug":"2020/20201106064759","path":"blog/2020/20201106064759","filePath":"blog/2020/20201106064759.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt 正确的显示窗口","datePublished":"2020-11-06T00:00:00.000Z","dateModified":"2020-11-06T00:00:00.000Z","description":"文章主要讲 Qt 正确显示窗口，有多种展示情况及常见做法，如`widget->show(); widget->raise();`但存在窗口最小化后出不来等问题，给出`GraceShowWidget`函数代码可解决，测试无问题。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201106064759"}},{"title":"golang接口型函数作用","date":"2020-11-04T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"Golang 中 http.Handle 用到接口型函数，定义了 ServeHTTP 接口及实现它的 HandlerFunc 函数。通过示例展示用户使用灵活，有 struct 对象、匿名函数、普通函数三种方式，清楚体现其好处。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.415,"time":84900,"words":283},"slug":"2020/20201104034649","path":"blog/2020/20201104034649","filePath":"blog/2020/20201104034649.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang接口型函数作用","datePublished":"2020-11-04T00:00:00.000Z","dateModified":"2020-11-04T00:00:00.000Z","description":"Golang 中 http.Handle 用到接口型函数，定义了 ServeHTTP 接口及实现它的 HandlerFunc 函数。通过示例展示用户使用灵活，有 struct 对象、匿名函数、普通函数三种方式，清楚体现其好处。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201104034649"}},{"title":"QTableWidget整行高亮去虚线，样式定制","date":"2020-10-15T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"文章介绍了 QTableWidget 整行高亮去虚线及样式定制方法。定义接口类存储 hovered 行和 split 行，表格绘制代理类实现 item 定制绘制，包括去掉焦点虚线框、hover 整行高亮等。table 具体应用结合两部分实现需求，通过 mouseMoveEvent 设 hovered 行，此分层方式灵活且易扩充功能。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.235,"time":194100,"words":647},"slug":"2020/20201015025612","path":"blog/2020/20201015025612","filePath":"blog/2020/20201015025612.mdx","toc":[{"value":"定义接口类","url":"#定义接口类","depth":1},{"value":"表格绘制代理类delegate","url":"#表格绘制代理类delegate","depth":1},{"value":"table的具体应用","url":"#table的具体应用","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QTableWidget整行高亮去虚线，样式定制","datePublished":"2020-10-15T00:00:00.000Z","dateModified":"2020-10-15T00:00:00.000Z","description":"文章介绍了 QTableWidget 整行高亮去虚线及样式定制方法。定义接口类存储 hovered 行和 split 行，表格绘制代理类实现 item 定制绘制，包括去掉焦点虚线框、hover 整行高亮等。table 具体应用结合两部分实现需求，通过 mouseMoveEvent 设 hovered 行，此分层方式灵活且易扩充功能。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201015025612"}},{"title":"Qt json文件读写","date":"2020-09-22T00:00:00.000Z","tags":["Qt","C/C++"],"draft":false,"summary":"介绍 Qt 中 JSON 读写，提供便捷 C++ API。封装 json 字符串与 QVariantMap 转换函数。展示读取和写入 json 文件的代码，注意写入时需指定 utf8 编码，避免中文转换失败。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.21,"time":132600,"words":442},"slug":"2020/20200922024839","path":"blog/2020/20200922024839","filePath":"blog/2020/20200922024839.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt json文件读写","datePublished":"2020-09-22T00:00:00.000Z","dateModified":"2020-09-22T00:00:00.000Z","description":"介绍 Qt 中 JSON 读写，提供便捷 C++ API。封装 json 字符串与 QVariantMap 转换函数。展示读取和写入 json 文件的代码，注意写入时需指定 utf8 编码，避免中文转换失败。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200922024839"}},{"title":"字符编码的故事","date":"2020-09-13T00:00:00.000Z","tags":["Life"],"draft":false,"summary":"文章讲述字符编码故事，从 ASCII 到 GB2312 等多种编码，后 ISO 制定 UNICODE 统一所有字符，UTF 标准用于网络传输。还介绍了 Ansi、Unicode、UTF8 字符串特点及相互转换代码，如 Ansi 转 Unicode 用 MultiByteToWideChar 等函数，UTF8 转 Unicode 用 WideCharToMultiByte 等函数。  \r","type":"Blog","readingTime":{"text":"24 min read","minutes":23.87,"time":1432200,"words":4774},"slug":"2020/20200913134027","path":"blog/2020/20200913134027","filePath":"blog/2020/20200913134027.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"字符编码的故事","datePublished":"2020-09-13T00:00:00.000Z","dateModified":"2020-09-13T00:00:00.000Z","description":"文章讲述字符编码故事，从 ASCII 到 GB2312 等多种编码，后 ISO 制定 UNICODE 统一所有字符，UTF 标准用于网络传输。还介绍了 Ansi、Unicode、UTF8 字符串特点及相互转换代码，如 Ansi 转 Unicode 用 MultiByteToWideChar 等函数，UTF8 转 Unicode 用 WideCharToMultiByte 等函数。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200913134027"}},{"title":"qt.network.ssl  QSslSocket Qt支持SSL https","date":"2020-09-08T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"Qt 的 qt.network.ssl 中 QSslSocket 支持 SSL https。使用 QNetworkAccessManager 类默认不支持 https 协议，需增加openssl动态库，且新版本和老版本所需库名不同，老为 libeay32.dll、ssleay32.dll，新为 libcrypto - 1_1.dll、libssl - 1_1.dll，可在 QtCreator 包中找。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.37,"time":22200,"words":74},"slug":"2020/20201210085108","path":"blog/2020/20201210085108","filePath":"blog/2020/20201210085108.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"qt.network.ssl  QSslSocket Qt支持SSL https","datePublished":"2020-09-08T00:00:00.000Z","dateModified":"2020-09-08T00:00:00.000Z","description":"Qt 的 qt.network.ssl 中 QSslSocket 支持 SSL https。使用 QNetworkAccessManager 类默认不支持 https 协议，需增加openssl动态库，且新版本和老版本所需库名不同，老为 libeay32.dll、ssleay32.dll，新为 libcrypto - 1_1.dll、libssl - 1_1.dll，可在 QtCreator 包中找。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201210085108"}},{"title":"腾讯OCR文字识别API调用","date":"2020-09-04T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"该 Go 代码实现腾讯 OCR 文字识别 API 调用，通过上传图像获取识别字段信息。定义相关结构体和函数，包括获取请求数据、生成签名等。在 main 函数中发起 POST 请求并处理响应，将识别结果输出。代码可从指定链接获取更多信息。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.135,"time":128100,"words":427},"slug":"2020/20200904101203","path":"blog/2020/20200904101203","filePath":"blog/2020/20200904101203.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"腾讯OCR文字识别API调用","datePublished":"2020-09-04T00:00:00.000Z","dateModified":"2020-09-04T00:00:00.000Z","description":"该 Go 代码实现腾讯 OCR 文字识别 API 调用，通过上传图像获取识别字段信息。定义相关结构体和函数，包括获取请求数据、生成签名等。在 main 函数中发起 POST 请求并处理响应，将识别结果输出。代码可从指定链接获取更多信息。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200904101203"}},{"title":"QtCharts使用","date":"2020-09-03T00:00:00.000Z","tags":["Qt","C/C++"],"draft":false,"summary":"介绍 QtCharts 使用，其在 Qt5.7 后包含，包含重要类如 QChart 等。给出 demo 截图及相关源码，包含 MyChart 类的定义和实现，用于展示图表等功能。  \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.365,"time":201900,"words":673},"slug":"2020/20200903013817","path":"blog/2020/20200903013817","filePath":"blog/2020/20200903013817.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QtCharts使用","datePublished":"2020-09-03T00:00:00.000Z","dateModified":"2020-09-03T00:00:00.000Z","description":"介绍 QtCharts 使用，其在 Qt5.7 后包含，包含重要类如 QChart 等。给出 demo 截图及相关源码，包含 MyChart 类的定义和实现，用于展示图表等功能。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200903013817"}},{"title":"删除数据库中没有使用到的图片","date":"2020-09-03T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍了删除数据库中未使用图片的程序。先连接数据库，读取 web/upload 目录下图片，根据图片名在数据库查找，未找到则删除。通过 Go 代码实现，遍历目录，根据图片名在数据库中筛选，找到无对应文章的图片并删除。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.13,"time":67800,"words":226},"slug":"2020/20200903060431","path":"blog/2020/20200903060431","filePath":"blog/2020/20200903060431.mdx","toc":[{"value":"步骤","url":"#步骤","depth":1},{"value":"源码","url":"#源码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"删除数据库中没有使用到的图片","datePublished":"2020-09-03T00:00:00.000Z","dateModified":"2020-09-03T00:00:00.000Z","description":"文章介绍了删除数据库中未使用图片的程序。先连接数据库，读取 web/upload 目录下图片，根据图片名在数据库查找，未找到则删除。通过 Go 代码实现，遍历目录，根据图片名在数据库中筛选，找到无对应文章的图片并删除。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200903060431"}},{"title":"Expression  _BLOCK_TYPE_IS_VALID(pHead->nBlockUse)","date":"2020-08-31T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"用新 visual studio 编译老代码，Debug 时 QString 的 toStdString 和 toStdWString 触发“Expression _BLOCK_TYPE_IS_VALID(pHead->nBlockUse)”错误，换成特定转换函数就没事，原因可能与内存有关，需分析 QString 源码。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.62,"time":37200,"words":124},"slug":"2020/20201210085105","path":"blog/2020/20201210085105","filePath":"blog/2020/20201210085105.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Expression  _BLOCK_TYPE_IS_VALID(pHead->nBlockUse)","datePublished":"2020-08-31T00:00:00.000Z","dateModified":"2020-08-31T00:00:00.000Z","description":"用新 visual studio 编译老代码，Debug 时 QString 的 toStdString 和 toStdWString 触发“Expression _BLOCK_TYPE_IS_VALID(pHead->nBlockUse)”错误，换成特定转换函数就没事，原因可能与内存有关，需分析 QString 源码。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201210085105"}},{"title":"sqlite3 安装、开发","date":"2020-08-25T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"SQLite 是世界常用数据库引擎，提供下载链接及可视化工具。可通过命令生成 lib，还给出 sqlite3 开发包目录结构及相关编码，包括类 Sqlite 的各种操作函数，如打开、关闭、查询、执行等。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.62,"time":157200,"words":524},"slug":"2020/20200825030147","path":"blog/2020/20200825030147","filePath":"blog/2020/20200825030147.mdx","toc":[{"value":"下载","url":"#下载","depth":1},{"value":"def生成lib","url":"#def生成lib","depth":1},{"value":"sqlite3开发包","url":"#sqlite3开发包","depth":1},{"value":"编码","url":"#编码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"sqlite3 安装、开发","datePublished":"2020-08-25T00:00:00.000Z","dateModified":"2020-08-25T00:00:00.000Z","description":"SQLite 是世界常用数据库引擎，提供下载链接及可视化工具。可通过命令生成 lib，还给出 sqlite3 开发包目录结构及相关编码，包括类 Sqlite 的各种操作函数，如打开、关闭、查询、执行等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200825030147"}},{"title":"log4cxx OutputDebugString DebugView","date":"2020-08-12T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"文章介绍 log4cxx 的常用 appender 及在 GUI 程序中用 OutputDebugString 看日志。提到可通过配置 log4cxx.properties 实现向 OutputDebugString 输出日志，用 vs 输出窗口或 DebugView 工具实时查看。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.665,"time":39900,"words":133},"slug":"2020/20200812024238","path":"blog/2020/20200812024238","filePath":"blog/2020/20200812024238.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"log4cxx OutputDebugString DebugView","datePublished":"2020-08-12T00:00:00.000Z","dateModified":"2020-08-12T00:00:00.000Z","description":"文章介绍 log4cxx 的常用 appender 及在 GUI 程序中用 OutputDebugString 看日志。提到可通过配置 log4cxx.properties 实现向 OutputDebugString 输出日志，用 vs 输出窗口或 DebugView 工具实时查看。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200812024238"}},{"title":"多线程锁key处理","date":"2020-07-30T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"主要目的是保证多线程处理同一 key 消息的线程安全和顺序性。通过缓存消息、解析 key、分配线程等步骤实现，关键在于递减索引数和等待索引为 0 以保证顺序执行，代码包含多种类如 MessagePack、NetMessageCache 等，外部调用 init 和 dispatchMessage 函数。 \r","type":"Blog","readingTime":{"text":"11 min read","minutes":10.235,"time":614100,"words":2047},"slug":"2020/20200730023808","path":"blog/2020/20200730023808","filePath":"blog/2020/20200730023808.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"多线程锁key处理","datePublished":"2020-07-30T00:00:00.000Z","dateModified":"2020-07-30T00:00:00.000Z","description":"主要目的是保证多线程处理同一 key 消息的线程安全和顺序性。通过缓存消息、解析 key、分配线程等步骤实现，关键在于递减索引数和等待索引为 0 以保证顺序执行，代码包含多种类如 MessagePack、NetMessageCache 等，外部调用 init 和 dispatchMessage 函数。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200730023808"}},{"title":"golang 控制goroutine调度顺序","date":"2020-07-29T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍 golang 控制 goroutine 调度顺序，用 go 启动 goroutine 执行顺序不保证，通过 event 包中的 Event 结构及相关函数可按需求调度。如多个 goroutine 按特定顺序执行及 a、b、c、d 倒序执行的代码示例等。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.18,"time":130800,"words":436},"slug":"2020/20200729055424","path":"blog/2020/20200729055424","filePath":"blog/2020/20200729055424.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang 控制goroutine调度顺序","datePublished":"2020-07-29T00:00:00.000Z","dateModified":"2020-07-29T00:00:00.000Z","description":"文章介绍 golang 控制 goroutine 调度顺序，用 go 启动 goroutine 执行顺序不保证，通过 event 包中的 Event 结构及相关函数可按需求调度。如多个 goroutine 按特定顺序执行及 a、b、c、d 倒序执行的代码示例等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200729055424"}},{"title":"快速遍历磁盘","date":"2020-07-23T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"介绍快速遍历磁盘方法，不用遍历每个目录，用 DeviceIoControl 函数需管理员权限，还可通过命令行工具“dir c:\\*.* /b /s /a-d >>c:\\allfile.txt”。给出 C++代码可遍历磁盘文件及目录信息。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.805,"time":168300,"words":561},"slug":"2020/20200723022614","path":"blog/2020/20200723022614","filePath":"blog/2020/20200723022614.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"快速遍历磁盘","datePublished":"2020-07-23T00:00:00.000Z","dateModified":"2020-07-23T00:00:00.000Z","description":"介绍快速遍历磁盘方法，不用遍历每个目录，用 DeviceIoControl 函数需管理员权限，还可通过命令行工具“dir c:\\*.* /b /s /a-d >>c:\\allfile.txt”。给出 C++代码可遍历磁盘文件及目录信息。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200723022614"}},{"title":"localtime线程不安全造成的线上问题","date":"2020-07-23T00:00:00.000Z","tags":["Linux","C/C++","Bug"],"draft":false,"summary":"线上出现日期赋值异常，经调查确定是 localtime 函数线程不安全导致。通过 demo 模拟，多个线程运行时 t2 的时间会误赋值给 t1。应使用线程安全的 localtime，如在 windows 下直接使用 localtime，linux 下使用 localtime_r。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.645,"time":158700,"words":529},"slug":"2020/20200723081837","path":"blog/2020/20200723081837","filePath":"blog/2020/20200723081837.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"localtime线程不安全造成的线上问题","datePublished":"2020-07-23T00:00:00.000Z","dateModified":"2020-07-23T00:00:00.000Z","description":"线上出现日期赋值异常，经调查确定是 localtime 函数线程不安全导致。通过 demo 模拟，多个线程运行时 t2 的时间会误赋值给 t1。应使用线程安全的 localtime，如在 windows 下直接使用 localtime，linux 下使用 localtime_r。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200723081837"}},{"title":"编程语录","date":"2020-07-06T00:00:00.000Z","tags":["Tips"],"draft":false,"summary":"总结：纠错前先思考，若直接扎进问题，仅解决当前代码，先思考错误及引入方式，能发现并纠正高层次问题，改进系统设计，防止更多 bug 出现。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.435,"time":26100,"words":87},"slug":"2020/20200706133846","path":"blog/2020/20200706133846","filePath":"blog/2020/20200706133846.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"编程语录","datePublished":"2020-07-06T00:00:00.000Z","dateModified":"2020-07-06T00:00:00.000Z","description":"总结：纠错前先思考，若直接扎进问题，仅解决当前代码，先思考错误及引入方式，能发现并纠正高层次问题，改进系统设计，防止更多 bug 出现。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200706133846"}},{"title":"golang设置桌面壁纸","date":"2020-07-04T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"本文介绍用 golang 设置桌面壁纸，提供 github 源码地址及编译好的程序地址。程序可通过命令设置不同日期壁纸或随机切换，还展示了 golang 调用 windows API 的相关代码，如加载动态链接库、查找函数等操作。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.445,"time":86700,"words":289},"slug":"2020/20200704132117","path":"blog/2020/20200704132117","filePath":"blog/2020/20200704132117.mdx","toc":[{"value":"golang调用windows API","url":"#golang调用windows-api","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang设置桌面壁纸","datePublished":"2020-07-04T00:00:00.000Z","dateModified":"2020-07-04T00:00:00.000Z","description":"本文介绍用 golang 设置桌面壁纸，提供 github 源码地址及编译好的程序地址。程序可通过命令设置不同日期壁纸或随机切换，还展示了 golang 调用 windows API 的相关代码，如加载动态链接库、查找函数等操作。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200704132117"}},{"title":"QWidget QLabel没有响应keyEvent键盘事件","date":"2020-06-23T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"在 Qt 中，常通过重写虚函数实现按键事件。但 QWidget、QLabel 有时无法触发，可能被父窗口截获或无焦点。可通过鼠标点击和 tab 键获取焦点，像它们即使鼠标点上也无焦点，需设置焦点获取策略如 setFocusPolicy(Qt::StrongFocus)，获取焦点才能响应按键事件。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.04,"time":62400,"words":208},"slug":"2020/20200623064259","path":"blog/2020/20200623064259","filePath":"blog/2020/20200623064259.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QWidget QLabel没有响应keyEvent键盘事件","datePublished":"2020-06-23T00:00:00.000Z","dateModified":"2020-06-23T00:00:00.000Z","description":"在 Qt 中，常通过重写虚函数实现按键事件。但 QWidget、QLabel 有时无法触发，可能被父窗口截获或无焦点。可通过鼠标点击和 tab 键获取焦点，像它们即使鼠标点上也无焦点，需设置焦点获取策略如 setFocusPolicy(Qt::StrongFocus)，获取焦点才能响应按键事件。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200623064259"}},{"title":"Mac安装国内版homebrew","date":"2020-06-12T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"HomeBrew 是 macOS 和 linux 包管理工具，官方版本下载慢，此文介绍国内版安装方法。粘贴脚本到终端回车安装，选 1，安装过程若需安装 xcode 工具按提示操作，安装完成后截图如下，速度快。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.835,"time":50100,"words":167},"slug":"2020/20200612154855","path":"blog/2020/20200612154855","filePath":"blog/2020/20200612154855.mdx","toc":[{"value":"安装方法","url":"#安装方法","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Mac安装国内版homebrew","datePublished":"2020-06-12T00:00:00.000Z","dateModified":"2020-06-12T00:00:00.000Z","description":"HomeBrew 是 macOS 和 linux 包管理工具，官方版本下载慢，此文介绍国内版安装方法。粘贴脚本到终端回车安装，选 1，安装过程若需安装 xcode 工具按提示操作，安装完成后截图如下，速度快。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200612154855"}},{"title":"malloc_trim和SetProcessWorkingSetSize两个神奇的内存相关函数","date":"2020-06-11T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍了 malloc_trim 和 SetProcessWorkingSetSize 两个内存相关函数。malloc_trim 是 linux 平台函数，可释放堆上可用内存；SetProcessWorkingSetSize 是 windows 平台函数，可设置进程工作集大小，将不使用内存交换到虚拟内存，频繁调用会降低性能。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":2.005,"time":120300,"words":401},"slug":"2020/20200611092655","path":"blog/2020/20200611092655","filePath":"blog/2020/20200611092655.mdx","toc":[{"value":"malloc_trim","url":"#malloc_trim","depth":1},{"value":"SetProcessWorkingSetSize","url":"#setprocessworkingsetsize","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"malloc_trim和SetProcessWorkingSetSize两个神奇的内存相关函数","datePublished":"2020-06-11T00:00:00.000Z","dateModified":"2020-06-11T00:00:00.000Z","description":"介绍了 malloc_trim 和 SetProcessWorkingSetSize 两个内存相关函数。malloc_trim 是 linux 平台函数，可释放堆上可用内存；SetProcessWorkingSetSize 是 windows 平台函数，可设置进程工作集大小，将不使用内存交换到虚拟内存，频繁调用会降低性能。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200611092655"}},{"title":"编写 Bash Shell 脚本的最佳实践","date":"2020-06-06T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"介绍编写 Bash Shell 脚本的最佳实践，包括代码风格规范（开头有“蛇棒”、有注释、参数规范等）、编码细节规范（代码有效率等）、巧用 main 函数等，还提及静态检查工具 shellcheck，方便保证脚本质量，作者 Myths 分享经验。\r","type":"Blog","readingTime":{"text":"25 min read","minutes":24.96,"time":1497600,"words":4992},"slug":"2020/20200606132433","path":"blog/2020/20200606132433","filePath":"blog/2020/20200606132433.mdx","toc":[{"value":"前言","url":"#前言","depth":2},{"value":"代码风格规范","url":"#代码风格规范","depth":2},{"value":"开头有“蛇棒”","url":"#开头有蛇棒","depth":3},{"value":"代码有注释","url":"#代码有注释","depth":3},{"value":"参数要规范","url":"#参数要规范","depth":3},{"value":"变量和魔数","url":"#变量和魔数","depth":3},{"value":"缩进有规矩","url":"#缩进有规矩","depth":3},{"value":"命名有标准","url":"#命名有标准","depth":3},{"value":"编码要统一","url":"#编码要统一","depth":3},{"value":"权限记得加","url":"#权限记得加","depth":3},{"value":"日志和回显","url":"#日志和回显","depth":3},{"value":"密码要移除","url":"#密码要移除","depth":3},{"value":"太长要分行","url":"#太长要分行","depth":3},{"value":"编码细节规范","url":"#编码细节规范","depth":2},{"value":"代码有效率","url":"#代码有效率","depth":3},{"value":"勤用双引号","url":"#勤用双引号","depth":3},{"value":"巧用main函数","url":"#巧用main函数","depth":3},{"value":"考虑作用域","url":"#考虑作用域","depth":3},{"value":"函数返回值","url":"#函数返回值","depth":3},{"value":"间接引用值","url":"#间接引用值","depth":3},{"value":"巧用heredocs","url":"#巧用heredocs","depth":3},{"value":"学会查路径","url":"#学会查路径","depth":3},{"value":"代码要简短","url":"#代码要简短","depth":3},{"value":"命令并行化","url":"#命令并行化","depth":3},{"value":"全文本检索","url":"#全文本检索","depth":3},{"value":"使用新写法","url":"#使用新写法","depth":3},{"value":"其他小tip","url":"#其他小tip","depth":3},{"value":"静态检查工具shellcheck","url":"#静态检查工具shellcheck","depth":2},{"value":"概述","url":"#概述","depth":3},{"value":"安装","url":"#安装","depth":3},{"value":"集成","url":"#集成","depth":3},{"value":"样例","url":"#样例","depth":3},{"value":"本质","url":"#本质","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"编写 Bash Shell 脚本的最佳实践","datePublished":"2020-06-06T00:00:00.000Z","dateModified":"2020-06-06T00:00:00.000Z","description":"介绍编写 Bash Shell 脚本的最佳实践，包括代码风格规范（开头有“蛇棒”、有注释、参数规范等）、编码细节规范（代码有效率等）、巧用 main 函数等，还提及静态检查工具 shellcheck，方便保证脚本质量，作者 Myths 分享经验。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200606132433"}},{"title":"netcat网络诊断","date":"2020-06-06T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"Netcat 功能灵活，体积小，默认安装于各大发行版。可用于网络诊断，如端口测试、传输测试、UDP 会话测试、文件传输、网速吞吐量测试及创建系统后门等。搭配管道可实现多样功能，虽复杂用法难记，但可作为备份手段，在极端环境下发挥作用。 \r","type":"Blog","readingTime":{"text":"15 min read","minutes":14.405,"time":864300,"words":2881},"slug":"2020/20200606140916","path":"blog/2020/20200606140916","filePath":"blog/2020/20200606140916.mdx","toc":[{"value":"端口测试","url":"#端口测试","depth":2},{"value":"传输测试","url":"#传输测试","depth":2},{"value":"测试 UDP 会话","url":"#测试-udp-会话","depth":2},{"value":"文件传输","url":"#文件传输","depth":2},{"value":"网速吞吐量测试","url":"#网速吞吐量测试","depth":2},{"value":"系统后门","url":"#系统后门","depth":2},{"value":"结束","url":"#结束","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"netcat网络诊断","datePublished":"2020-06-06T00:00:00.000Z","dateModified":"2020-06-06T00:00:00.000Z","description":"Netcat 功能灵活，体积小，默认安装于各大发行版。可用于网络诊断，如端口测试、传输测试、UDP 会话测试、文件传输、网速吞吐量测试及创建系统后门等。搭配管道可实现多样功能，虽复杂用法难记，但可作为备份手段，在极端环境下发挥作用。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200606140916"}},{"title":"vim常用技巧","date":"2020-06-06T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"文章介绍 vim 常用技巧，研发线上常用 vi 编辑器，vim 有按键系统等特点。别用 vim 打开大文件，常用操作如漫游、复制、剪切、删除、粘贴等，还有可视化模式、命令模式、查找字符串、宏录制等功能，以及其他如 r、ggVG 等功能，最后介绍退出编辑器的方式，门槛高但用多了难释手。 \r","type":"Blog","readingTime":{"text":"9 min read","minutes":8.675,"time":520500,"words":1735},"slug":"2020/20200606141715","path":"blog/2020/20200606141715","filePath":"blog/2020/20200606141715.mdx","toc":[{"value":"-----------------------    研发线上使用最多的编辑器，就是vi。无论是最快查看某个文件内容，还是快速编辑某个文件，vi都能帮上忙。    软件世界貌似有一些非常长寿的东西，vi算是一个。本篇文章聚焦的是研发线上最常用的一些...","url":"#---------------------------研发线上使用最多的编辑器就是vi无论是最快查看某个文件内容还是快速编辑某个文件vi都能帮上忙----软件世界貌似有一些非常长寿的东西vi算是一个本篇文章聚焦的是研发线上最常用的一些","depth":2},{"value":"Linux生产环境上，最常用的一套“vim“技巧原创","url":"#linux生产环境上最常用的一套vim技巧原创","depth":2},{"value":"养成习惯","url":"#养成习惯","depth":1},{"value":"不要添乱","url":"#不要添乱","depth":1},{"value":"常用操作","url":"#常用操作","depth":1},{"value":"以下操作在普通模式下执行，连续按键","url":"#以下操作在普通模式下执行连续按键","depth":4},{"value":"漫游","url":"#漫游","depth":2},{"value":"复制：y","url":"#复制y","depth":2},{"value":"剪切: x","url":"#剪切-x","depth":2},{"value":"删除：d","url":"#删除d","depth":2},{"value":"粘贴: p","url":"#粘贴-p","depth":2},{"value":"可视化模式","url":"#可视化模式","depth":1},{"value":"v 行模式，选择一些内容","url":"#v行模式选择一些内容","depth":3},{"value":"ctrl+v 块模式","url":"#ctrlv块模式","depth":3},{"value":"查找字符串","url":"#查找字符串","depth":1},{"value":"宏录制","url":"#宏录制","depth":1},{"value":"其他","url":"#其他","depth":1},{"value":"退出编辑器","url":"#退出编辑器","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"vim常用技巧","datePublished":"2020-06-06T00:00:00.000Z","dateModified":"2020-06-06T00:00:00.000Z","description":"文章介绍 vim 常用技巧，研发线上常用 vi 编辑器，vim 有按键系统等特点。别用 vim 打开大文件，常用操作如漫游、复制、剪切、删除、粘贴等，还有可视化模式、命令模式、查找字符串、宏录制等功能，以及其他如 r、ggVG 等功能，最后介绍退出编辑器的方式，门槛高但用多了难释手。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200606141715"}},{"title":"如何在Ubuntu 14.04上使用Corosync Pacemaker和浮动IP构建高可用服务","date":"2020-06-03T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"本文介绍在 Ubuntu 14.04 上用 Corosync、Pacemaker 和浮动 IP 构建高可用服务，包括创建 Droplets、配置 Corosync 和 Pacemaker、设置浮动 IP 重新分配等步骤，还可添加 Nginx 资源等，最终实现主动/被动高可用设置，可进一步用反向代理负载平衡器替换 Nginx 设置。 \r","type":"Blog","readingTime":{"text":"33 min read","minutes":32.405,"time":1944300,"words":6481},"slug":"2020/20201210085101","path":"blog/2020/20201210085101","filePath":"blog/2020/20201210085101.mdx","toc":[{"value":"介绍","url":"#介绍","depth":3},{"value":"目标","url":"#目标","depth":2},{"value":"先决条件","url":"#先决条件","depth":2},{"value":"创建Droplets","url":"#创建droplets","depth":2},{"value":"创建浮动IP","url":"#创建浮动ip","depth":2},{"value":"配置DNS（可选）","url":"#配置dns可选","depth":2},{"value":"配置时间同步","url":"#配置时间同步","depth":2},{"value":"配置防火墙","url":"#配置防火墙","depth":2},{"value":"安装Corosync和Pacemaker","url":"#安装corosync和pacemaker","depth":2},{"value":"配置Corosync","url":"#配置corosync","depth":2},{"value":"创建集群授权密钥","url":"#创建集群授权密钥","depth":3},{"value":"配置Corosync群集","url":"#配置corosync群集","depth":3},{"value":"启动并配置Pacemaker","url":"#启动并配置pacemaker","depth":2},{"value":"启用并启动Pacemaker","url":"#启用并启动pacemaker","depth":3},{"value":"配置集群属性","url":"#配置集群属性","depth":3},{"value":"创建浮动IP重新分配资源代理","url":"#创建浮动ip重新分配资源代理","depth":2},{"value":"下载assign-ip脚本","url":"#下载assign-ip脚本","depth":3},{"value":"下载FloatIP OCF资源代理","url":"#下载floatip-ocf资源代理","depth":3},{"value":"添加FloatIP资源","url":"#添加floatip资源","depth":2},{"value":"测试高可用性","url":"#测试高可用性","depth":2},{"value":"对故障转移进行故障排除（可选）","url":"#对故障转移进行故障排除可选","depth":2},{"value":"疑难解答的有用命令","url":"#疑难解答的有用命令","depth":3},{"value":"其他CRM命令","url":"#其他crm命令","depth":3},{"value":"添加Nginx资源（可选）","url":"#添加nginx资源可选","depth":2},{"value":"结论","url":"#结论","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何在Ubuntu 14.04上使用Corosync Pacemaker和浮动IP构建高可用服务","datePublished":"2020-06-03T00:00:00.000Z","dateModified":"2020-06-03T00:00:00.000Z","description":"本文介绍在 Ubuntu 14.04 上用 Corosync、Pacemaker 和浮动 IP 构建高可用服务，包括创建 Droplets、配置 Corosync 和 Pacemaker、设置浮动 IP 重新分配等步骤，还可添加 Nginx 资源等，最终实现主动/被动高可用设置，可进一步用反向代理负载平衡器替换 Nginx 设置。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201210085101"}},{"title":"golang调用Windows API","date":"2020-06-01T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍 golang 可调用 Windows API 及换壁纸 demo。准备两张 bmp 图片，每 3 秒换一次。先通过 dll 获取 api 并缓存，注意参数写法及释放句柄。代码展示了相关函数调用，如显示消息和设置壁纸等，在 main 函数中循环设置壁纸。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.385,"time":83100,"words":277},"slug":"2020/20200601083849","path":"blog/2020/20200601083849","filePath":"blog/2020/20200601083849.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang调用Windows API","datePublished":"2020-06-01T00:00:00.000Z","dateModified":"2020-06-01T00:00:00.000Z","description":"文章介绍 golang 可调用 Windows API 及换壁纸 demo。准备两张 bmp 图片，每 3 秒换一次。先通过 dll 获取 api 并缓存，注意参数写法及释放句柄。代码展示了相关函数调用，如显示消息和设置壁纸等，在 main 函数中循环设置壁纸。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200601083849"}},{"title":"外网访问mysql","date":"2020-05-16T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"将 mysql 部署在 Centos7 云服务器上，需登录控制台添加入站规则，开放防火墙端口，在 mysql 配置文件中修改设置并重启，最后进入命令行给用户授权，完成外网访问 mysql 的操作。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.82,"time":49200,"words":164},"slug":"2020/20200516084920","path":"blog/2020/20200516084920","filePath":"blog/2020/20200516084920.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"外网访问mysql","datePublished":"2020-05-16T00:00:00.000Z","dateModified":"2020-05-16T00:00:00.000Z","description":"将 mysql 部署在 Centos7 云服务器上，需登录控制台添加入站规则，开放防火墙端口，在 mysql 配置文件中修改设置并重启，最后进入命令行给用户授权，完成外网访问 mysql 的操作。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200516084920"}},{"title":"MySQL基础操作快速入门","date":"2020-05-15T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"本文介绍 MySQL 基础操作，包括安装（Ubuntu、Centos）、使用 shell 访问、创建删除数据库（创建如“events”，删除命令）、使用数据库（先指定再查看表）、创建表（如“potluck”表结构）、插入数据、更新数据（改“Sandy”确认状态）、添加删除列、删除行等基本用法，对初学者有帮助。 \r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.715,"time":342900,"words":1143},"slug":"2020/20200515080420","path":"blog/2020/20200515080420","filePath":"blog/2020/20200515080420.mdx","toc":[{"value":"关于MySQL","url":"#关于mysql","depth":1},{"value":"MySQL安装","url":"#mysql安装","depth":1},{"value":"使用shell访问MySQL","url":"#使用shell访问mysql","depth":1},{"value":"创建删除数据库","url":"#创建删除数据库","depth":1},{"value":"怎样使用数据库","url":"#怎样使用数据库","depth":1},{"value":"创建表","url":"#创建表","depth":1},{"value":"向表中插入数据","url":"#向表中插入数据","depth":1},{"value":"更新表中数据","url":"#更新表中数据","depth":1},{"value":"添加删除列","url":"#添加删除列","depth":1},{"value":"删除行","url":"#删除行","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL基础操作快速入门","datePublished":"2020-05-15T00:00:00.000Z","dateModified":"2020-05-15T00:00:00.000Z","description":"本文介绍 MySQL 基础操作，包括安装（Ubuntu、Centos）、使用 shell 访问、创建删除数据库（创建如“events”，删除命令）、使用数据库（先指定再查看表）、创建表（如“potluck”表结构）、插入数据、更新数据（改“Sandy”确认状态）、添加删除列、删除行等基本用法，对初学者有帮助。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200515080420"}},{"title":"mysql忘了密码 重置密码","date":"2020-05-14T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"忘记 MySQL 密码可通过编辑配置文件、重启 MySQL 后登录修改密码。先在[mysqld]下加 skip-grant-tables，重启后用特定命令修改密码，若仍有问题可再加两个操作，最后改回配置文件重启用新密码登录。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.67,"time":40200,"words":134},"slug":"2020/20201210085107","path":"blog/2020/20201210085107","filePath":"blog/2020/20201210085107.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"mysql忘了密码 重置密码","datePublished":"2020-05-14T00:00:00.000Z","dateModified":"2020-05-14T00:00:00.000Z","description":"忘记 MySQL 密码可通过编辑配置文件、重启 MySQL 后登录修改密码。先在[mysqld]下加 skip-grant-tables，重启后用特定命令修改密码，若仍有问题可再加两个操作，最后改回配置文件重启用新密码登录。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201210085107"}},{"title":"解决ssh登录远程服务器慢的问题","date":"2020-05-12T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.49,"time":89400,"words":298},"slug":"2020/20200512074350","path":"blog/2020/20200512074350","filePath":"blog/2020/20200512074350.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"解决ssh登录远程服务器慢的问题","datePublished":"2020-05-12T00:00:00.000Z","dateModified":"2020-05-12T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200512074350"}},{"title":"goland2020.1含激活","date":"2020-05-05T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"这是关于 goland2020.1 激活的内容，提供下载地址、激活方式等，还介绍了 Post 结构体及相关数据库操作，先获取 jetbrains-agent.jar 并按步骤操作激活，支持两种注册方式，且适用于 Jetbrains 全系列版本，升级后可能需重启 IDE。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.015,"time":240900,"words":803},"slug":"2020/20200505083328","path":"blog/2020/20200505083328","filePath":"blog/2020/20200505083328.mdx","toc":[{"value":"================================================================    Jetbrains Activation Code And License Server Crack    ==============                     https://zhile.io                                              ==============              v3.2.0, Build Date: 2020-04-10                            =======","url":"#----jetbrains-activation-code-and-license-server-crack-------------------------httpszhileio------------------------------------------------------------v320-build-date-2020-04-10----------------------------","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"goland2020.1含激活","datePublished":"2020-05-05T00:00:00.000Z","dateModified":"2020-05-05T00:00:00.000Z","description":"这是关于 goland2020.1 激活的内容，提供下载地址、激活方式等，还介绍了 Post 结构体及相关数据库操作，先获取 jetbrains-agent.jar 并按步骤操作激活，支持两种注册方式，且适用于 Jetbrains 全系列版本，升级后可能需重启 IDE。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200505083328"}},{"title":"golang html、template模板继承（嵌套）实例","date":"2020-05-04T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"介绍 golang html、template 模板继承实例，定义 base.tmpl 基础模板及子模板 title、content 默认值，index.tmpl 和 post.tmpl 为其扩展，给出渲染接口及测试代码，本地测试时不同地址对应不同输出。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.015,"time":240900,"words":803},"slug":"2020/20201210085106","path":"blog/2020/20201210085106","filePath":"blog/2020/20201210085106.mdx","toc":[{"value":"base.tmpl","url":"#basetmpl","depth":1},{"value":"index.tmpl","url":"#indextmpl","depth":1},{"value":"post.tmpl","url":"#posttmpl","depth":1},{"value":"渲染接口","url":"#渲染接口","depth":1},{"value":"测试","url":"#测试","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang html、template模板继承（嵌套）实例","datePublished":"2020-05-04T00:00:00.000Z","dateModified":"2020-05-04T00:00:00.000Z","description":"介绍 golang html、template 模板继承实例，定义 base.tmpl 基础模板及子模板 title、content 默认值，index.tmpl 和 post.tmpl 为其扩展，给出渲染接口及测试代码，本地测试时不同地址对应不同输出。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201210085106"}},{"title":"使用group by来统计每天产生的数据量","date":"2020-04-30T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"文章介绍使用 group by 统计每天流水表产生的数据量。通过截取 modify_time 的前 10 位作为日期，进行 group by 操作并按每天条数倒序排序，sql 写法如给出示例。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.68,"time":40800,"words":136},"slug":"2020/20200430101645","path":"blog/2020/20200430101645","filePath":"blog/2020/20200430101645.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用group by来统计每天产生的数据量","datePublished":"2020-04-30T00:00:00.000Z","dateModified":"2020-04-30T00:00:00.000Z","description":"文章介绍使用 group by 统计每天流水表产生的数据量。通过截取 modify_time 的前 10 位作为日期，进行 group by 操作并按每天条数倒序排序，sql 写法如给出示例。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200430101645"}},{"title":"golang与qpid broker通信","date":"2020-04-29T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍 golang 与 qpid broker 通信，使用 github.com/Azure/go-amqp 库，演示 sender 和 receiver 简单例子，还包括请求应答示例，通过 New 函数创建 handler 处理发送和接收消息，最后展示发送消息并处理应答的代码。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.415,"time":264900,"words":883},"slug":"2020/20200429013314","path":"blog/2020/20200429013314","filePath":"blog/2020/20200429013314.mdx","toc":[{"value":"receiver","url":"#receiver","depth":1},{"value":"sender","url":"#sender","depth":1},{"value":"请求应答","url":"#请求应答","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang与qpid broker通信","datePublished":"2020-04-29T00:00:00.000Z","dateModified":"2020-04-29T00:00:00.000Z","description":"文章介绍 golang 与 qpid broker 通信，使用 github.com/Azure/go-amqp 库，演示 sender 和 receiver 简单例子，还包括请求应答示例，通过 New 函数创建 handler 处理发送和接收消息，最后展示发送消息并处理应答的代码。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200429013314"}},{"title":"sync.WaitGroup增加timeout","date":"2020-04-29T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍了使用 sync.WaitGroup 增加 timeout 的方法。通过封装 WaitGroup 实现超时机制，给出代码示例，测试时若超时时间大于任务时间则任务正常完成退出，小于则未执行完就退出。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.92,"time":55200,"words":184},"slug":"2020/20200429075202","path":"blog/2020/20200429075202","filePath":"blog/2020/20200429075202.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"sync.WaitGroup增加timeout","datePublished":"2020-04-29T00:00:00.000Z","dateModified":"2020-04-29T00:00:00.000Z","description":"文章介绍了使用 sync.WaitGroup 增加 timeout 的方法。通过封装 WaitGroup 实现超时机制，给出代码示例，测试时若超时时间大于任务时间则任务正常完成退出，小于则未执行完就退出。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200429075202"}},{"title":"获取本地IP地址","date":"2020-04-28T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍获取本地 IP 地址的方法，C/C++中 Windows 和 Linux 平台都支持的代码，先通过不同方式获取，再给出 Qt 的写法，代码清爽，可获取本地 IP 地址。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.28,"time":76800,"words":256},"slug":"2020/20200428023807","path":"blog/2020/20200428023807","filePath":"blog/2020/20200428023807.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"获取本地IP地址","datePublished":"2020-04-28T00:00:00.000Z","dateModified":"2020-04-28T00:00:00.000Z","description":"介绍获取本地 IP 地址的方法，C/C++中 Windows 和 Linux 平台都支持的代码，先通过不同方式获取，再给出 Qt 的写法，代码清爽，可获取本地 IP 地址。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200428023807"}},{"title":"amqp connection framing-error  Expected AMQP protocol header","date":"2020-04-23T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"解决连接 qqpidd 时报错的问题\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.255,"time":75300,"words":251},"slug":"2020/20201210085102","path":"blog/2020/20201210085102","filePath":"blog/2020/20201210085102.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"amqp connection framing-error  Expected AMQP protocol header","datePublished":"2020-04-23T00:00:00.000Z","dateModified":"2020-04-23T00:00:00.000Z","description":"解决连接 qqpidd 时报错的问题\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201210085102"}},{"title":"给mongodb服务增加认证","date":"2020-04-19T00:00:00.000Z","tags":["MongoDB"],"draft":false,"summary":"文章介绍给 mongodb 服务增加认证的方法。先将数据库配置为 noauth:true 启动，创建用户并设置权限，再改为 auth:true 启动，客户端连接可通过 go 语言 mgo 框架或 Studio 3T 工具，需设置用户名、密码和认证数据库。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.635,"time":38100,"words":127},"slug":"2020/20200419043118","path":"blog/2020/20200419043118","filePath":"blog/2020/20200419043118.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"给mongodb服务增加认证","datePublished":"2020-04-19T00:00:00.000Z","dateModified":"2020-04-19T00:00:00.000Z","description":"文章介绍给 mongodb 服务增加认证的方法。先将数据库配置为 noauth:true 启动，创建用户并设置权限，再改为 auth:true 启动，客户端连接可通过 go 语言 mgo 框架或 Studio 3T 工具，需设置用户名、密码和认证数据库。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200419043118"}},{"title":"go channel缓冲的作用","date":"2020-04-19T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍 go channel 缓冲作用，make chan 第二个参数设缓冲区大小，无缓冲时同步，有缓冲可提高数据传输效率。通过代码示例展示无缓冲、缓冲大小为 1 和大于 1 的情况及执行结果，强调要合理设置缓冲大小。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.45,"time":147000,"words":490},"slug":"2020/20200419061739","path":"blog/2020/20200419061739","filePath":"blog/2020/20200419061739.mdx","toc":[{"value":"无缓冲","url":"#无缓冲","depth":1},{"value":"缓冲大小为1","url":"#缓冲大小为1","depth":1},{"value":"缓冲大小大于1","url":"#缓冲大小大于1","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go channel缓冲的作用","datePublished":"2020-04-19T00:00:00.000Z","dateModified":"2020-04-19T00:00:00.000Z","description":"文章介绍 go channel 缓冲作用，make chan 第二个参数设缓冲区大小，无缓冲时同步，有缓冲可提高数据传输效率。通过代码示例展示无缓冲、缓冲大小为 1 和大于 1 的情况及执行结果，强调要合理设置缓冲大小。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200419061739"}},{"title":"用脚本启停我的go程序","date":"2020-04-19T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"介绍用脚本启停 go 程序，程序用 go 语言编写并使用 go-daemon 库让进程后台运行，脚本取名为 bootstrap，可实现 build、start、stop、restart 等功能，通过 cat 获取 pid 进行相应操作。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.74,"time":44400,"words":148},"slug":"2020/20200419120109","path":"blog/2020/20200419120109","filePath":"blog/2020/20200419120109.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"用脚本启停我的go程序","datePublished":"2020-04-19T00:00:00.000Z","dateModified":"2020-04-19T00:00:00.000Z","description":"介绍用脚本启停 go 程序，程序用 go 语言编写并使用 go-daemon 库让进程后台运行，脚本取名为 bootstrap，可实现 build、start、stop、restart 等功能，通过 cat 获取 pid 进行相应操作。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200419120109"}},{"title":"ERROR  child process failed, exited with error number 62","date":"2020-04-19T00:00:00.000Z","tags":["MongoDB"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.605,"time":36300,"words":121},"slug":"2020/20201210085104","path":"blog/2020/20201210085104","filePath":"blog/2020/20201210085104.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ERROR  child process failed, exited with error number 62","datePublished":"2020-04-19T00:00:00.000Z","dateModified":"2020-04-19T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20201210085104"}},{"title":"go拓扑排序","date":"2020-03-01T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"拓扑排序用于确定依赖关系集中事物的发生顺序。文中以计算机课程学习为例，通过`topoSort`函数对课程前置关系进行排序，输出了学习课程的顺序，展示了拓扑排序在实际中的应用。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.77,"time":166200,"words":554},"slug":"2020/20200301011533","path":"blog/2020/20200301011533","filePath":"blog/2020/20200301011533.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go拓扑排序","datePublished":"2020-03-01T00:00:00.000Z","dateModified":"2020-03-01T00:00:00.000Z","description":"拓扑排序用于确定依赖关系集中事物的发生顺序。文中以计算机课程学习为例，通过`topoSort`函数对课程前置关系进行排序，输出了学习课程的顺序，展示了拓扑排序在实际中的应用。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200301011533"}},{"title":"go模拟命令行文件拷贝命令","date":"2020-02-23T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"本文介绍用 Go 模拟命令行文件拷贝命令，提及熟悉 flag、bufio 等包及函数，代码实现了文件是否存在判断、创建拷贝文件等功能，通过 main 函数和测试示例展示了普通拷贝和强制拷贝的操作。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.42,"time":85200,"words":284},"slug":"2020/20200223014251","path":"blog/2020/20200223014251","filePath":"blog/2020/20200223014251.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go模拟命令行文件拷贝命令","datePublished":"2020-02-23T00:00:00.000Z","dateModified":"2020-02-23T00:00:00.000Z","description":"本文介绍用 Go 模拟命令行文件拷贝命令，提及熟悉 flag、bufio 等包及函数，代码实现了文件是否存在判断、创建拷贝文件等功能，通过 main 函数和测试示例展示了普通拷贝和强制拷贝的操作。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200223014251"}},{"title":"go反射","date":"2020-02-23T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"介绍了 Go 语言的反射相关内容。通过示例展示了打印结构体信息、修改结构体字段值等操作，如打印 User 结构体的字段和方法，修改 User 结构体中 Name 字段的值等，还展示了对基本变量的修改，体现了反射的强大功能。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.705,"time":102300,"words":341},"slug":"2020/20200223155423","path":"blog/2020/20200223155423","filePath":"blog/2020/20200223155423.mdx","toc":[{"value":"简单结构","url":"#简单结构","depth":1},{"value":"复杂结构","url":"#复杂结构","depth":1},{"value":"修改变量","url":"#修改变量","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go反射","datePublished":"2020-02-23T00:00:00.000Z","dateModified":"2020-02-23T00:00:00.000Z","description":"介绍了 Go 语言的反射相关内容。通过示例展示了打印结构体信息、修改结构体字段值等操作，如打印 User 结构体的字段和方法，修改 User 结构体中 Name 字段的值等，还展示了对基本变量的修改，体现了反射的强大功能。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2020/20200223155423"}},{"title":"keepalived实现服务高可用","date":"2019-12-10T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"文章介绍 keepalived 实现服务高可用，两台服务器部署同一程序，主服务挂则从服务接替，keepalived 提供虚拟 IP 让客户端无感知。文中给出两台机器配置 keepalived 及相关脚本等步骤，并通过访问不同 IP 验证，还提到可根据需求通过脚本自动处理服务切换等情况。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.675,"time":280500,"words":935},"slug":"2019/20191210091455","path":"blog/2019/20191210091455","filePath":"blog/2019/20191210091455.mdx","toc":[{"value":"目标","url":"#目标","depth":1},{"value":"问题","url":"#问题","depth":1},{"value":"解决方案","url":"#解决方案","depth":1},{"value":"验证","url":"#验证","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"keepalived实现服务高可用","datePublished":"2019-12-10T00:00:00.000Z","dateModified":"2019-12-10T00:00:00.000Z","description":"文章介绍 keepalived 实现服务高可用，两台服务器部署同一程序，主服务挂则从服务接替，keepalived 提供虚拟 IP 让客户端无感知。文中给出两台机器配置 keepalived 及相关脚本等步骤，并通过访问不同 IP 验证，还提到可根据需求通过脚本自动处理服务切换等情况。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191210091455"}},{"title":"git github代理","date":"2019-12-06T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"家里电脑下载 github 代码慢，用蓝灯。找到其 http proxy 地址 127.0.0.1:50705，通过 open_github_proxy.sh 和 close_github_proxy.sh 脚本可打开或关闭 github 代理，方便下载代码。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.545,"time":32700,"words":109},"slug":"2019/20191206143913","path":"blog/2019/20191206143913","filePath":"blog/2019/20191206143913.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"git github代理","datePublished":"2019-12-06T00:00:00.000Z","dateModified":"2019-12-06T00:00:00.000Z","description":"家里电脑下载 github 代码慢，用蓝灯。找到其 http proxy 地址 127.0.0.1:50705，通过 open_github_proxy.sh 和 close_github_proxy.sh 脚本可打开或关闭 github 代理，方便下载代码。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191206143913"}},{"title":"双击exe阻止程序启动","date":"2019-12-03T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"文章介绍双击 exe 阻止程序启动的方法，不依赖传参，通过获取父进程 ID 判断是否为 explorer.exe 进程 ID 来实现。给出获取进程信息、按名称获取进程 ID、获取父进程 ID 的函数及示例代码。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.37,"time":82200,"words":274},"slug":"2019/20191203092256","path":"blog/2019/20191203092256","filePath":"blog/2019/20191203092256.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"双击exe阻止程序启动","datePublished":"2019-12-03T00:00:00.000Z","dateModified":"2019-12-03T00:00:00.000Z","description":"文章介绍双击 exe 阻止程序启动的方法，不依赖传参，通过获取父进程 ID 判断是否为 explorer.exe 进程 ID 来实现。给出获取进程信息、按名称获取进程 ID、获取父进程 ID 的函数及示例代码。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191203092256"}},{"title":"device-mapper-libs安装docker失败","date":"2019-11-15T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"在 centos7 安装 docker 所需包（如 device-mapper-libs 等）时失败，经删除旧包再安装等操作后成功，还设置了存储仓库并安装了社区版 docker 引擎，启动后验证正常。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.755,"time":105300,"words":351},"slug":"2019/20191115052202","path":"blog/2019/20191115052202","filePath":"blog/2019/20191115052202.mdx","toc":[{"value":"安装基础包失败解决方法","url":"#安装基础包失败解决方法","depth":1},{"value":"安装社区版docker引擎","url":"#安装社区版docker引擎","depth":1},{"value":"启动docker，验证","url":"#启动docker验证","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"device-mapper-libs安装docker失败","datePublished":"2019-11-15T00:00:00.000Z","dateModified":"2019-11-15T00:00:00.000Z","description":"在 centos7 安装 docker 所需包（如 device-mapper-libs 等）时失败，经删除旧包再安装等操作后成功，还设置了存储仓库并安装了社区版 docker 引擎，启动后验证正常。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191115052202"}},{"title":"go mod graph 图表","date":"2019-11-14T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"通过“go mod graph”可输出工程模块依赖图，为更清晰展示用 Graphviz 工具生成图表。步骤为获取依赖关系、转换成 dot 文件、生成图表。文中展示了开发网站的模块依赖及实现源码，可找到本地图表或生成新图表。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.78,"time":226800,"words":756},"slug":"2019/20191114114311","path":"blog/2019/20191114114311","filePath":"blog/2019/20191114114311.mdx","toc":[{"value":"实现步骤","url":"#实现步骤","depth":1},{"value":"演示","url":"#演示","depth":1},{"value":"实现源码","url":"#实现源码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go mod graph 图表","datePublished":"2019-11-14T00:00:00.000Z","dateModified":"2019-11-14T00:00:00.000Z","description":"通过“go mod graph”可输出工程模块依赖图，为更清晰展示用 Graphviz 工具生成图表。步骤为获取依赖关系、转换成 dot 文件、生成图表。文中展示了开发网站的模块依赖及实现源码，可找到本地图表或生成新图表。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191114114311"}},{"title":"go 获取bing壁纸地址","date":"2019-11-13T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍通过 Go 语言获取必应壁纸地址，必应首页背景图每天更新且无直接下载处，需分析网页源代码。提供获取地址、下载及记录历史信息的代码，包含相关函数如 GetImageName 等，可实现获取壁纸并下载到本地。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.68,"time":220800,"words":736},"slug":"2019/20191113025657","path":"blog/2019/20191113025657","filePath":"blog/2019/20191113025657.mdx","toc":[{"value":"获取bing每日壁纸地址和标题","url":"#获取bing每日壁纸地址和标题","depth":1},{"value":"下载bing背景图","url":"#下载bing背景图","depth":1},{"value":"记录下载的历史信息","url":"#记录下载的历史信息","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go 获取bing壁纸地址","datePublished":"2019-11-13T00:00:00.000Z","dateModified":"2019-11-13T00:00:00.000Z","description":"文章介绍通过 Go 语言获取必应壁纸地址，必应首页背景图每天更新且无直接下载处，需分析网页源代码。提供获取地址、下载及记录历史信息的代码，包含相关函数如 GetImageName 等，可实现获取壁纸并下载到本地。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191113025657"}},{"title":"golang Options可变参数接口设计","date":"2019-11-05T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍 golang 中使用...Options 作为接口参数，以新建 exchange 为例，说明其优点是参数灵活、意义清晰，缺点是每个可选参数需提供函数，第一眼难明白怎么填，适合参数多的接口。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.27,"time":76200,"words":254},"slug":"2019/20191105052304","path":"blog/2019/20191105052304","filePath":"blog/2019/20191105052304.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang Options可变参数接口设计","datePublished":"2019-11-05T00:00:00.000Z","dateModified":"2019-11-05T00:00:00.000Z","description":"文章介绍 golang 中使用...Options 作为接口参数，以新建 exchange 为例，说明其优点是参数灵活、意义清晰，缺点是每个可选参数需提供函数，第一眼难明白怎么填，适合参数多的接口。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191105052304"}},{"title":"VritualBox centos NAT、Host-Only网络配置","date":"2019-10-10T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"文章介绍了 VirtualBox centos 的 NAT、Host-Only 网络配置。包括虚拟机安装步骤及相关截图，网络设置中 NAT 模式可外网访问和 ping 通主机但虚拟机间不通，Host-Only 模式需注意相关设置及重启，还提到通过 NAT 端口转发实现主机访问虚拟机。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.18,"time":70800,"words":236},"slug":"2019/20191010073544","path":"blog/2019/20191010073544","filePath":"blog/2019/20191010073544.mdx","toc":[{"value":"虚拟机安装","url":"#虚拟机安装","depth":1},{"value":"网络设置","url":"#网络设置","depth":1},{"value":"主机访问虚拟机","url":"#主机访问虚拟机","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"VritualBox centos NAT、Host-Only网络配置","datePublished":"2019-10-10T00:00:00.000Z","dateModified":"2019-10-10T00:00:00.000Z","description":"文章介绍了 VirtualBox centos 的 NAT、Host-Only 网络配置。包括虚拟机安装步骤及相关截图，网络设置中 NAT 模式可外网访问和 ping 通主机但虚拟机间不通，Host-Only 模式需注意相关设置及重启，还提到通过 NAT 端口转发实现主机访问虚拟机。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191010073544"}},{"title":"centos rpm使用方法","date":"2019-10-08T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"CentOS RPM 用于 Linux 软件管理，有五种操作模式。可通过多种命令进行安装（如 rpm -i）、查询（如 rpm -q）、卸载（如 rpm -e）、升级（如 rpm -U）和验证（如 rpm -V）。默认安装路径及其他命令也有介绍。 \r","type":"Blog","readingTime":{"text":"9 min read","minutes":8.225,"time":493500,"words":1645},"slug":"2019/20191008034421","path":"blog/2019/20191008034421","filePath":"blog/2019/20191008034421.mdx","toc":[{"value":"RPM 安装操作","url":"#rpm-安装操作","depth":1},{"value":"RPM 查询操作","url":"#rpm-查询操作","depth":1},{"value":"RPM 卸载操作","url":"#rpm-卸载操作","depth":1},{"value":"RPM 升级操作","url":"#rpm-升级操作","depth":1},{"value":"RPM 验证操作","url":"#rpm-验证操作","depth":1},{"value":"RPM 的其他附加命令","url":"#rpm-的其他附加命令","depth":1},{"value":"RPM包默认安装路径","url":"#rpm包默认安装路径","depth":1},{"value":"RPM 包的安装","url":"#rpm-包的安装","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"centos rpm使用方法","datePublished":"2019-10-08T00:00:00.000Z","dateModified":"2019-10-08T00:00:00.000Z","description":"CentOS RPM 用于 Linux 软件管理，有五种操作模式。可通过多种命令进行安装（如 rpm -i）、查询（如 rpm -q）、卸载（如 rpm -e）、升级（如 rpm -U）和验证（如 rpm -V）。默认安装路径及其他命令也有介绍。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191008034421"}},{"title":"centos基础环境准备","date":"2019-09-29T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"本文介绍 centos 基础环境准备，包括 ifconfig 网卡设置、crontab 编辑、hostname 修改、jdk 环境变量、ntp 时间同步、ulimit 修改、安装 vsftpd 及添加用户等操作，还涉及修改网络内核参数。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.125,"time":127500,"words":425},"slug":"2019/20190929081026","path":"blog/2019/20190929081026","filePath":"blog/2019/20190929081026.mdx","toc":[{"value":"ifconfig发现没有网卡","url":"#ifconfig发现没有网卡","depth":1},{"value":"crontab编辑","url":"#crontab编辑","depth":1},{"value":"hostname修改","url":"#hostname修改","depth":1},{"value":"jdk环境变量","url":"#jdk环境变量","depth":1},{"value":"ntp时间同步","url":"#ntp时间同步","depth":1},{"value":"ulimit修改","url":"#ulimit修改","depth":1},{"value":"安装vsftpd","url":"#安装vsftpd","depth":1},{"value":"添加用户，如：tujiaw","url":"#添加用户如tujiaw","depth":1},{"value":"修改网络内核参数","url":"#修改网络内核参数","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"centos基础环境准备","datePublished":"2019-09-29T00:00:00.000Z","dateModified":"2019-09-29T00:00:00.000Z","description":"本文介绍 centos 基础环境准备，包括 ifconfig 网卡设置、crontab 编辑、hostname 修改、jdk 环境变量、ntp 时间同步、ulimit 修改、安装 vsftpd 及添加用户等操作，还涉及修改网络内核参数。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190929081026"}},{"title":"QNetworkAccessManager http请求","date":"2019-09-27T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"文章介绍使用 QNetworkAccessManager 发起 http 请求，列举 get、post（表单形式）、post 上传文件三种场景及代码，包括设置请求头、构建请求数据等，还给出完整的 HttpRequest 类代码及相关信号槽。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.88,"time":112800,"words":376},"slug":"2019/20190927090437","path":"blog/2019/20190927090437","filePath":"blog/2019/20190927090437.mdx","toc":[{"value":"get请求","url":"#get请求","depth":1},{"value":"post请求","url":"#post请求","depth":1},{"value":"post上传文件","url":"#post上传文件","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QNetworkAccessManager http请求","datePublished":"2019-09-27T00:00:00.000Z","dateModified":"2019-09-27T00:00:00.000Z","description":"文章介绍使用 QNetworkAccessManager 发起 http 请求，列举 get、post（表单形式）、post 上传文件三种场景及代码，包括设置请求头、构建请求数据等，还给出完整的 HttpRequest 类代码及相关信号槽。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190927090437"}},{"title":"go 分批读取http应答数据","date":"2019-09-06T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"本文介绍 go 分批读取 http 应答数据的方法。通常用`ioutil.ReadAll`，但大文件时内存大且慢，需分批读。给出代码`ReadChunk`，注意读到`io.EOF`时继续读，用`chan`可单独开启 goroutine 下载并处理数据。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.07,"time":64200,"words":214},"slug":"2019/20190906093810","path":"blog/2019/20190906093810","filePath":"blog/2019/20190906093810.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go 分批读取http应答数据","datePublished":"2019-09-06T00:00:00.000Z","dateModified":"2019-09-06T00:00:00.000Z","description":"本文介绍 go 分批读取 http 应答数据的方法。通常用`ioutil.ReadAll`，但大文件时内存大且慢，需分批读。给出代码`ReadChunk`，注意读到`io.EOF`时继续读，用`chan`可单独开启 goroutine 下载并处理数据。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190906093810"}},{"title":"linux C++进程CPU占用100%排查","date":"2019-09-04T00:00:00.000Z","tags":["Linux","C/C++"],"draft":false,"summary":"文章主要介绍 linux C++进程 CPU 占用 100%的排查方法。先通过 top -c 查看进程，若日志无异常则找到出现问题的线程 ID，用 gdb attach 目标进程，通过 info threads 找到对应线程，输入 thread 及编号后 bt 查看信息，最后 detach 退出调试。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.48,"time":88800,"words":296},"slug":"2019/20190904074229","path":"blog/2019/20190904074229","filePath":"blog/2019/20190904074229.mdx","toc":[{"value":"现象","url":"#现象","depth":1},{"value":"出现问题的线程","url":"#出现问题的线程","depth":1},{"value":"使用gdb attach目标进程","url":"#使用gdb-attach目标进程","depth":1},{"value":"退出调试","url":"#退出调试","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"linux C++进程CPU占用100%排查","datePublished":"2019-09-04T00:00:00.000Z","dateModified":"2019-09-04T00:00:00.000Z","description":"文章主要介绍 linux C++进程 CPU 占用 100%的排查方法。先通过 top -c 查看进程，若日志无异常则找到出现问题的线程 ID，用 gdb attach 目标进程，通过 info threads 找到对应线程，输入 thread 及编号后 bt 查看信息，最后 detach 退出调试。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190904074229"}},{"title":"linux C++内存优化","date":"2019-08-30T00:00:00.000Z","tags":["Linux","C/C++"],"draft":false,"summary":"总结：linux C++内存释放后进程内存未降，因系统内存分配原理，mmap释放后归还给系统，brk释放后若高地址内存块未释放则低地址内存块不还。可用 malloc_trim(0)强制归还给系统，还可通过 mallopt 优化内存。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.19,"time":131400,"words":438},"slug":"2019/20190830024228","path":"blog/2019/20190830024228","filePath":"blog/2019/20190830024228.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"linux C++内存优化","datePublished":"2019-08-30T00:00:00.000Z","dateModified":"2019-08-30T00:00:00.000Z","description":"总结：linux C++内存释放后进程内存未降，因系统内存分配原理，mmap释放后归还给系统，brk释放后若高地址内存块未释放则低地址内存块不还。可用 malloc_trim(0)强制归还给系统，还可通过 mallopt 优化内存。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190830024228"}},{"title":"mysql备份、恢复表","date":"2019-08-23T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"本文介绍了 mysql 备份、恢复表的方法。包括备份单个表的不同方式（如普通 dump、远程 dump）及恢复语句，还提及备份恢复压缩表的相关操作（dump 时压缩、restore 时解压），方便用户进行数据库表管理。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.45,"time":27000,"words":90},"slug":"2019/20190823052129","path":"blog/2019/20190823052129","filePath":"blog/2019/20190823052129.mdx","toc":[{"value":"备份恢复单个表","url":"#备份恢复单个表","depth":1},{"value":"dump","url":"#dump","depth":2},{"value":"远程dump","url":"#远程dump","depth":2},{"value":"恢复","url":"#恢复","depth":2},{"value":"备份恢复压缩表","url":"#备份恢复压缩表","depth":1},{"value":"dump","url":"#dump-1","depth":2},{"value":"restore","url":"#restore","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"mysql备份、恢复表","datePublished":"2019-08-23T00:00:00.000Z","dateModified":"2019-08-23T00:00:00.000Z","description":"本文介绍了 mysql 备份、恢复表的方法。包括备份单个表的不同方式（如普通 dump、远程 dump）及恢复语句，还提及备份恢复压缩表的相关操作（dump 时压缩、restore 时解压），方便用户进行数据库表管理。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190823052129"}},{"title":"centos7监控网卡流量","date":"2019-08-14T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"介绍 centos7 监控网卡流量的方法，需安装 iftop 后，通过 iftop -i eth0 查看网卡流量，还可监控特定 ip 流量（如 iftop -i eth0 -B -F 182.92.***.20），用 q 退出，界面说明清晰，eth0 为网卡。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.825,"time":49500,"words":165},"slug":"2019/20190814080522","path":"blog/2019/20190814080522","filePath":"blog/2019/20190814080522.mdx","toc":[{"value":"安装","url":"#安装","depth":1},{"value":"查看网卡流量","url":"#查看网卡流量","depth":1},{"value":"监控特定ip的流量","url":"#监控特定ip的流量","depth":1},{"value":"退出","url":"#退出","depth":1},{"value":"显示界面说明：","url":"#显示界面说明","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"centos7监控网卡流量","datePublished":"2019-08-14T00:00:00.000Z","dateModified":"2019-08-14T00:00:00.000Z","description":"介绍 centos7 监控网卡流量的方法，需安装 iftop 后，通过 iftop -i eth0 查看网卡流量，还可监控特定 ip 流量（如 iftop -i eth0 -B -F 182.92.***.20），用 q 退出，界面说明清晰，eth0 为网卡。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190814080522"}},{"title":"C++ 智能指针简单实现","date":"2019-08-05T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"这是 C++ 智能指针简单实现代码，仅用于学习，生产勿用。通过模板类`SmartPtr`及内部结构`Counter`实现计数功能。测试代码展示了其基本用法，包括对象创建、赋值和销毁等操作。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.155,"time":69300,"words":231},"slug":"2019/20190805060206","path":"blog/2019/20190805060206","filePath":"blog/2019/20190805060206.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 智能指针简单实现","datePublished":"2019-08-05T00:00:00.000Z","dateModified":"2019-08-05T00:00:00.000Z","description":"这是 C++ 智能指针简单实现代码，仅用于学习，生产勿用。通过模板类`SmartPtr`及内部结构`Counter`实现计数功能。测试代码展示了其基本用法，包括对象创建、赋值和销毁等操作。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190805060206"}},{"title":"goquery基本用法","date":"2019-07-16T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"介绍 goquery 基本用法，用于处理网络拿到的网页文本数据。通过示例代码截取网页中 table 内容并转换为 markdown 格式，展示其便捷性，代码可从特定地址获取，运行后输出相应 markdown 内容。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.675,"time":100500,"words":335},"slug":"2019/20190716072136","path":"blog/2019/20190716072136","filePath":"blog/2019/20190716072136.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"goquery基本用法","datePublished":"2019-07-16T00:00:00.000Z","dateModified":"2019-07-16T00:00:00.000Z","description":"介绍 goquery 基本用法，用于处理网络拿到的网页文本数据。通过示例代码截取网页中 table 内容并转换为 markdown 格式，展示其便捷性，代码可从特定地址获取，运行后输出相应 markdown 内容。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190716072136"}},{"title":"什么是云计算，大数据，人工智能","date":"2019-07-16T00:00:00.000Z","tags":["Product"],"draft":false,"summary":"文章详细介绍了云计算、大数据、人工智能。云计算最初实现资源管理灵活性，历经物理机、虚拟化等阶段发展到云计算，分为私有云和公有云；云计算不光管资源还管应用，通过 PaaS 层实现应用弹性；大数据拥抱云计算，从数据收集到处理分析等步骤，需聚合多台机器力量；人工智能拥抱大数据，从让机器懂人心到模拟大脑工作方式，神经网络需大数据平台计算。最终三者整合，在云计算平台上相互融合。 \r","type":"Blog","readingTime":{"text":"68 min read","minutes":67.08,"time":4024800,"words":13416},"slug":"2019/20190716103252","path":"blog/2019/20190716103252","filePath":"blog/2019/20190716103252.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"什么是云计算，大数据，人工智能","datePublished":"2019-07-16T00:00:00.000Z","dateModified":"2019-07-16T00:00:00.000Z","description":"文章详细介绍了云计算、大数据、人工智能。云计算最初实现资源管理灵活性，历经物理机、虚拟化等阶段发展到云计算，分为私有云和公有云；云计算不光管资源还管应用，通过 PaaS 层实现应用弹性；大数据拥抱云计算，从数据收集到处理分析等步骤，需聚合多台机器力量；人工智能拥抱大数据，从让机器懂人心到模拟大脑工作方式，神经网络需大数据平台计算。最终三者整合，在云计算平台上相互融合。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190716103252"}},{"title":"golang slice切片作为函数参数时的陷阱","date":"2019-07-02T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"Golang 中 slice 作为函数参数易掉陷阱。例 1 说明传参时 slice 被拷贝，函数内修改会影响原 slice；例 2 因 append 超出 cap 导致底层内存重分配及数据拷贝。正确方法是遵守规则，无返回参数不修改 slice，要修改则通过返回值返回，如需修改又不想改外值应深拷贝后再修改。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.24,"time":254400,"words":848},"slug":"2019/20190702103038","path":"blog/2019/20190702103038","filePath":"blog/2019/20190702103038.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang slice切片作为函数参数时的陷阱","datePublished":"2019-07-02T00:00:00.000Z","dateModified":"2019-07-02T00:00:00.000Z","description":"Golang 中 slice 作为函数参数易掉陷阱。例 1 说明传参时 slice 被拷贝，函数内修改会影响原 slice；例 2 因 append 超出 cap 导致底层内存重分配及数据拷贝。正确方法是遵守规则，无返回参数不修改 slice，要修改则通过返回值返回，如需修改又不想改外值应深拷贝后再修改。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190702103038"}},{"title":"linux expect scp自动输入密码","date":"2019-06-27T00:00:00.000Z","tags":["Linux","Shell"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.205,"time":72300,"words":241},"slug":"2019/20190627092616","path":"blog/2019/20190627092616","filePath":"blog/2019/20190627092616.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"linux expect scp自动输入密码","datePublished":"2019-06-27T00:00:00.000Z","dateModified":"2019-06-27T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190627092616"}},{"title":"zookeeper单机集群部署","date":"2019-06-26T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"Apache ZooKeeper 是用于集群协调的服务，提供多种常见服务。单机集群部署需准备、配置文件（在 /usr/local 下新建 zkcluster 目录及相关文件），然后启动三个服务（./zkServer.sh start 对应配置文件），myid 为服务唯一标识，server 格式包含通信和选举端口。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.13,"time":187800,"words":626},"slug":"2019/20190626064254","path":"blog/2019/20190626064254","filePath":"blog/2019/20190626064254.mdx","toc":[{"value":"什么是Apache ZooKeeper","url":"#什么是apache-zookeeper","depth":1},{"value":"单机集群部署","url":"#单机集群部署","depth":1},{"value":"准备","url":"#准备","depth":2},{"value":"配置文件","url":"#配置文件","depth":2},{"value":"启动三个服务","url":"#启动三个服务","depth":2},{"value":"解释","url":"#解释","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"zookeeper单机集群部署","datePublished":"2019-06-26T00:00:00.000Z","dateModified":"2019-06-26T00:00:00.000Z","description":"Apache ZooKeeper 是用于集群协调的服务，提供多种常见服务。单机集群部署需准备、配置文件（在 /usr/local 下新建 zkcluster 目录及相关文件），然后启动三个服务（./zkServer.sh start 对应配置文件），myid 为服务唯一标识，server 格式包含通信和选举端口。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190626064254"}},{"title":"zookeeper c client封装","date":"2019-06-26T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"该文章实现了 zookeeper c 客户端封装，仅实现 master 选举及收到 master 切换通知、注册服务信息的需求。代码中定义了 ZKNode 类，包含创建节点、设置回调函数等操作的相关函数，通过 zookeeper 相关接口实现与 zookeeper 的交互。 \r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.82,"time":349200,"words":1164},"slug":"2019/20190626072056","path":"blog/2019/20190626072056","filePath":"blog/2019/20190626072056.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"zookeeper c client封装","datePublished":"2019-06-26T00:00:00.000Z","dateModified":"2019-06-26T00:00:00.000Z","description":"该文章实现了 zookeeper c 客户端封装，仅实现 master 选举及收到 master 切换通知、注册服务信息的需求。代码中定义了 ZKNode 类，包含创建节点、设置回调函数等操作的相关函数，通过 zookeeper 相关接口实现与 zookeeper 的交互。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190626072056"}},{"title":"go showapi.com接口","date":"2019-06-17T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"介绍 go showapi.com 接口，用 go 封装其提供的三个接口，获取组装后的 url、http 请求返回字符串及 json。给出示例代码，如获取文本笑话的用法。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.97,"time":118200,"words":394},"slug":"2019/20190617145947","path":"blog/2019/20190617145947","filePath":"blog/2019/20190617145947.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go showapi.com接口","datePublished":"2019-06-17T00:00:00.000Z","dateModified":"2019-06-17T00:00:00.000Z","description":"介绍 go showapi.com 接口，用 go 封装其提供的三个接口，获取组装后的 url、http 请求返回字符串及 json。给出示例代码，如获取文本笑话的用法。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190617145947"}},{"title":"go http get post json","date":"2019-06-15T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"本文介绍 go 中 get 和 post 请求的 json 格式封装。get 用 HttpGetJson 函数，post 较复杂用 HttpPostJson 函数，都通过 marshal 处理数据，用法举例清晰，注意 resp 为根据 json 应答定义的 struct 。  \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.17,"time":70200,"words":234},"slug":"2019/20190615160126","path":"blog/2019/20190615160126","filePath":"blog/2019/20190615160126.mdx","toc":[{"value":"get请求","url":"#get请求","depth":1},{"value":"post请求","url":"#post请求","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go http get post json","datePublished":"2019-06-15T00:00:00.000Z","dateModified":"2019-06-15T00:00:00.000Z","description":"本文介绍 go 中 get 和 post 请求的 json 格式封装。get 用 HttpGetJson 函数，post 较复杂用 HttpPostJson 函数，都通过 marshal 处理数据，用法举例清晰，注意 resp 为根据 json 应答定义的 struct 。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190615160126"}},{"title":"corosync + pacemaker高可用部署","date":"2019-06-12T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"本文介绍了 corosync + pacemaker 高可用部署，包括两者简介、基础环境准备（主机名设置、防火墙关闭等）、集群部署（安装相关软件、修改配置文件等）及 CRM 配置（增加虚拟 IP 资源、服务资源及分组等），通过这些步骤可实现高可用服务。  \r","type":"Blog","readingTime":{"text":"8 min read","minutes":7.175,"time":430500,"words":1435},"slug":"2019/20190612102936","path":"blog/2019/20190612102936","filePath":"blog/2019/20190612102936.mdx","toc":[{"value":"corosync简介","url":"#corosync简介","depth":1},{"value":"pacemaker简介","url":"#pacemaker简介","depth":1},{"value":"基础环境准备","url":"#基础环境准备","depth":1},{"value":"主机名设置","url":"#主机名设置","depth":2},{"value":"修改验证主机名","url":"#修改验证主机名","depth":2},{"value":"关闭防火墙","url":"#关闭防火墙","depth":2},{"value":"集群部署","url":"#集群部署","depth":1},{"value":"本地安装corosync pacemaker crmsh","url":"#本地安装corosync-pacemaker-crmsh","depth":2},{"value":"修改corosync.conf配置文件","url":"#修改corosyncconf配置文件","depth":2},{"value":"生成密钥","url":"#生成密钥","depth":2},{"value":"同步密钥和配置","url":"#同步密钥和配置","depth":2},{"value":"启动服务","url":"#启动服务","depth":2},{"value":"验证","url":"#验证","depth":2},{"value":"CRM配置","url":"#crm配置","depth":1},{"value":"进入crm管理命令窗口","url":"#进入crm管理命令窗口","depth":2},{"value":"查看状态","url":"#查看状态","depth":2},{"value":"配置参数","url":"#配置参数","depth":2},{"value":"增加虚拟IP资源","url":"#增加虚拟ip资源","depth":2},{"value":"增加我的服务资源","url":"#增加我的服务资源","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"corosync + pacemaker高可用部署","datePublished":"2019-06-12T00:00:00.000Z","dateModified":"2019-06-12T00:00:00.000Z","description":"本文介绍了 corosync + pacemaker 高可用部署，包括两者简介、基础环境准备（主机名设置、防火墙关闭等）、集群部署（安装相关软件、修改配置文件等）及 CRM 配置（增加虚拟 IP 资源、服务资源及分组等），通过这些步骤可实现高可用服务。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190612102936"}},{"title":"linux 解压缩（.tar .tar.gz .gz .rar .zip）","date":"2019-06-11T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"文章介绍 linux 解压缩（.tar.tgz.gz.rar.zip），给出 tar 命令及参数，如 -c 建包、-x 解压等，还列举多种压缩格式（如 tar、gz、bz2 等）及相应解压命令，方便用户在 linux 系统中进行文件压缩解压操作。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.17,"time":190200,"words":634},"slug":"2019/20190611010546","path":"blog/2019/20190611010546","filePath":"blog/2019/20190611010546.mdx","toc":[{"value":"tar","url":"#tar","depth":1},{"value":"压缩","url":"#压缩","depth":1},{"value":"解压","url":"#解压","depth":1},{"value":"总结","url":"#总结","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"linux 解压缩（.tar .tar.gz .gz .rar .zip）","datePublished":"2019-06-11T00:00:00.000Z","dateModified":"2019-06-11T00:00:00.000Z","description":"文章介绍 linux 解压缩（.tar.tgz.gz.rar.zip），给出 tar 命令及参数，如 -c 建包、-x 解压等，还列举多种压缩格式（如 tar、gz、bz2 等）及相应解压命令，方便用户在 linux 系统中进行文件压缩解压操作。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190611010546"}},{"title":"go 第三方github登录","date":"2019-06-08T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍了 go 第三方 github 登录的实现步骤。先在 github 新建 oauth app 获相关信息，通过 html 标签和路由实现点击 github 登录，再处理 github 登录成功后的回调，获取 access token 及用户信息，判断并处理用户，将 token 保存在 session 中，还定义了 github 返回的 json 应答结构体。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.905,"time":174300,"words":581},"slug":"2019/20190608154134","path":"blog/2019/20190608154134","filePath":"blog/2019/20190608154134.mdx","toc":[{"value":"在github上新建oauth app","url":"#在github上新建oauth-app","depth":1},{"value":"点击github登录","url":"#点击github登录","depth":1},{"value":"github登录成功后回调","url":"#github登录成功后回调","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go 第三方github登录","datePublished":"2019-06-08T00:00:00.000Z","dateModified":"2019-06-08T00:00:00.000Z","description":"文章介绍了 go 第三方 github 登录的实现步骤。先在 github 新建 oauth app 获相关信息，通过 html 标签和路由实现点击 github 登录，再处理 github 登录成功后的回调，获取 access token 及用户信息，判断并处理用户，将 token 保存在 session 中，还定义了 github 返回的 json 应答结构体。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190608154134"}},{"title":"Redis 的各项功能解决了哪些问题？","date":"2019-06-01T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"Redis 是基于 BSD 开源项目，可作数据库等使用，支持多种数据类型及多种功能。从简单缓存到服务端 Redis（含持久化、哨兵和复制、集群等），再到客户端 Redis（数据类型、事务等），逐步进化为高可用、分布式存储系统，各功能旨在解决不同场景下的问题。 \r","type":"Blog","readingTime":{"text":"18 min read","minutes":17.755,"time":1065300,"words":3551},"slug":"2019/20190601030144","path":"blog/2019/20190601030144","filePath":"blog/2019/20190601030144.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis 的各项功能解决了哪些问题？","datePublished":"2019-06-01T00:00:00.000Z","dateModified":"2019-06-01T00:00:00.000Z","description":"Redis 是基于 BSD 开源项目，可作数据库等使用，支持多种数据类型及多种功能。从简单缓存到服务端 Redis（含持久化、哨兵和复制、集群等），再到客户端 Redis（数据类型、事务等），逐步进化为高可用、分布式存储系统，各功能旨在解决不同场景下的问题。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190601030144"}},{"title":"让你提高效率的Linux技巧","date":"2019-06-01T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"文章介绍了让 Linux 效率提升的技巧，包括命令编辑（如用 ^a、^e、^w 操作光标等）、使用别名登录远程机器、冻结解冻终端界面、复用命令（通过历史缓冲区等）、查看日志并动态显示更新、寻求帮助（加 --help 选项）、谨慎删除文件（设别名确认）、关闭别名、使用 sudo 及更复杂技巧（编写脚本或函数）等，配合这些可获更好体验。 \r","type":"Blog","readingTime":{"text":"9 min read","minutes":8.665,"time":519900,"words":1733},"slug":"2019/20190601054113","path":"blog/2019/20190601054113","filePath":"blog/2019/20190601054113.mdx","toc":[{"value":"命令编辑","url":"#命令编辑","depth":2},{"value":"使用远程机器的名称登录到机器上","url":"#使用远程机器的名称登录到机器上","depth":2},{"value":"冻结、解冻终端界面","url":"#冻结解冻终端界面","depth":2},{"value":"复用命令","url":"#复用命令","depth":2},{"value":"查看日志文件并动态显示更新内容","url":"#查看日志文件并动态显示更新内容","depth":2},{"value":"寻求帮助","url":"#寻求帮助","depth":2},{"value":"谨慎删除文件","url":"#谨慎删除文件","depth":2},{"value":"关闭别名","url":"#关闭别名","depth":2},{"value":"使用 sudo","url":"#使用-sudo","depth":2},{"value":"更复杂的技巧","url":"#更复杂的技巧","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"让你提高效率的Linux技巧","datePublished":"2019-06-01T00:00:00.000Z","dateModified":"2019-06-01T00:00:00.000Z","description":"文章介绍了让 Linux 效率提升的技巧，包括命令编辑（如用 ^a、^e、^w 操作光标等）、使用别名登录远程机器、冻结解冻终端界面、复用命令（通过历史缓冲区等）、查看日志并动态显示更新、寻求帮助（加 --help 选项）、谨慎删除文件（设别名确认）、关闭别名、使用 sudo 及更复杂技巧（编写脚本或函数）等，配合这些可获更好体验。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190601054113"}},{"title":"git常用命令","date":"2019-06-01T00:00:00.000Z","tags":["Tools","Tips"],"draft":false,"summary":"总结：介绍 git 常用命令，包括分支操作（如 push、pull、checkout 等）、暂存操作、回退操作、常规操作、创建项目仓库、忽略及取消忽略文件、拉取上传免密码等，详细列举各操作的具体命令及用法。 \r","type":"Blog","readingTime":{"text":"7 min read","minutes":6.375,"time":382500,"words":1275},"slug":"2019/20190601055825","path":"blog/2019/20190601055825","filePath":"blog/2019/20190601055825.mdx","toc":[{"value":"分支操作","url":"#分支操作","depth":2},{"value":"暂存操作","url":"#暂存操作","depth":2},{"value":"回退操作","url":"#回退操作","depth":2},{"value":"常规操作","url":"#常规操作","depth":2},{"value":"git创建项目仓库","url":"#git创建项目仓库","depth":2},{"value":"忽略已加入到版本库中的文件","url":"#忽略已加入到版本库中的文件","depth":2},{"value":"取消忽略文件","url":"#取消忽略文件","depth":2},{"value":"拉取、上传免密码","url":"#拉取上传免密码","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"git常用命令","datePublished":"2019-06-01T00:00:00.000Z","dateModified":"2019-06-01T00:00:00.000Z","description":"总结：介绍 git 常用命令，包括分支操作（如 push、pull、checkout 等）、暂存操作、回退操作、常规操作、创建项目仓库、忽略及取消忽略文件、拉取上传免密码等，详细列举各操作的具体命令及用法。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190601055825"}},{"title":"超实用的 Nginx 极简教程，覆盖了常用场景","date":"2019-06-01T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"这是超实用 Nginx 极简教程，覆盖常用场景。介绍了 Nginx 相关知识，包括安装使用、配置实战（如 http 反向代理、负载均衡、多 webapp 配置等）、https 反向代理、静态站点配置、搭建文件服务器及跨域解决方案等，内容详细且实用。 \r","type":"Blog","readingTime":{"text":"16 min read","minutes":15.915,"time":954900,"words":3183},"slug":"2019/20190601060615","path":"blog/2019/20190601060615","filePath":"blog/2019/20190601060615.mdx","toc":[{"value":"概述","url":"#概述","depth":2},{"value":"安装与使用","url":"#安装与使用","depth":2},{"value":"安装","url":"#安装","depth":3},{"value":"使用","url":"#使用","depth":3},{"value":"nginx 配置实战","url":"#nginx-配置实战","depth":2},{"value":"http 反向代理配置","url":"#http-反向代理配置","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"超实用的 Nginx 极简教程，覆盖了常用场景","datePublished":"2019-06-01T00:00:00.000Z","dateModified":"2019-06-01T00:00:00.000Z","description":"这是超实用 Nginx 极简教程，覆盖常用场景。介绍了 Nginx 相关知识，包括安装使用、配置实战（如 http 反向代理、负载均衡、多 webapp 配置等）、https 反向代理、静态站点配置、搭建文件服务器及跨域解决方案等，内容详细且实用。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190601060615"}},{"title":"vi、vim键盘图","date":"2019-06-01T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"2019 年 6 月 1 日的“vi、vim 键盘图”文章，含简体中文版、英文版、程序员定制版图片，若图片未显示可右键选“复制图片链接”粘贴至浏览器地址栏查看。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.265,"time":15900,"words":53},"slug":"2019/20191210091504","path":"blog/2019/20191210091504","filePath":"blog/2019/20191210091504.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"vi、vim键盘图","datePublished":"2019-06-01T00:00:00.000Z","dateModified":"2019-06-01T00:00:00.000Z","description":"2019 年 6 月 1 日的“vi、vim 键盘图”文章，含简体中文版、英文版、程序员定制版图片，若图片未显示可右键选“复制图片链接”粘贴至浏览器地址栏查看。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191210091504"}},{"title":"VirtualBox Centos6 安装增强功能设置共享文件夹","date":"2019-05-21T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"介绍 VirtualBox Centos6 安装增强功能及设置共享文件夹步骤：先安装必要工具、重启虚拟机，选 VBoxGuestAdditions.iso 挂载光驱，运行安装脚本，设置共享文件夹并挂载，若遇错误可执行特定命令，最后查看共享目录。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.3,"time":78000,"words":260},"slug":"2019/20190521013636","path":"blog/2019/20190521013636","filePath":"blog/2019/20190521013636.mdx","toc":[{"value":"安装必要的工具","url":"#安装必要的工具","depth":2},{"value":"重启虚拟机","url":"#重启虚拟机","depth":2},{"value":"选择VBoxGuestAdditions.iso文件","url":"#选择vboxguestadditionsiso文件","depth":2},{"value":"挂载光驱","url":"#挂载光驱","depth":2},{"value":"设置共享文件夹","url":"#设置共享文件夹","depth":2},{"value":"挂载","url":"#挂载","depth":2},{"value":"查看linux上的共享目录","url":"#查看linux上的共享目录","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"VirtualBox Centos6 安装增强功能设置共享文件夹","datePublished":"2019-05-21T00:00:00.000Z","dateModified":"2019-05-21T00:00:00.000Z","description":"介绍 VirtualBox Centos6 安装增强功能及设置共享文件夹步骤：先安装必要工具、重启虚拟机，选 VBoxGuestAdditions.iso 挂载光驱，运行安装脚本，设置共享文件夹并挂载，若遇错误可执行特定命令，最后查看共享目录。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190521013636"}},{"title":"go代理 golang代理 GOPROXY","date":"2019-05-19T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍了 go 代理相关内容，包括用 dep ensure 安装第三方库失败需设置代理，可使用微软代理或 Shadowsocks-X 软件代理，设置命令行代理需注意相关环境变量及端口等，还介绍了 linux 版本的设置步骤。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.985,"time":299100,"words":997},"slug":"2019/20190519155441","path":"blog/2019/20190519155441","filePath":"blog/2019/20190519155441.mdx","toc":[{"value":"前提条件","url":"#前提条件","depth":1},{"value":"mac版本：","url":"#mac版本","depth":1},{"value":"windows版本：","url":"#windows版本","depth":1},{"value":"linux版本","url":"#linux版本","depth":1},{"value":"安装shadowsocks linux版","url":"#安装shadowsocks-linux版","depth":2},{"value":"创建shadowsocks配置文件","url":"#创建shadowsocks配置文件","depth":2},{"value":"启动 Shadowsocks","url":"#启动-shadowsocks","depth":2},{"value":"socks5代理","url":"#socks5代理","depth":2},{"value":"dep ensure","url":"#dep-ensure","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go代理 golang代理 GOPROXY","datePublished":"2019-05-19T00:00:00.000Z","dateModified":"2019-05-19T00:00:00.000Z","description":"文章介绍了 go 代理相关内容，包括用 dep ensure 安装第三方库失败需设置代理，可使用微软代理或 Shadowsocks-X 软件代理，设置命令行代理需注意相关环境变量及端口等，还介绍了 linux 版本的设置步骤。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190519155441"}},{"title":"go logger","date":"2019-05-12T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"简单封装 go log ，有四个日志等级，可满足基本业务需求。通过 github.com/robfig/cron 每天生成新日志文件，示例代码展示了初始化和使用方法。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.67,"time":100200,"words":334},"slug":"2019/20190512094328","path":"blog/2019/20190512094328","filePath":"blog/2019/20190512094328.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go logger","datePublished":"2019-05-12T00:00:00.000Z","dateModified":"2019-05-12T00:00:00.000Z","description":"简单封装 go log ，有四个日志等级，可满足基本业务需求。通过 github.com/robfig/cron 每天生成新日志文件，示例代码展示了初始化和使用方法。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190512094328"}},{"title":"go json解析","date":"2019-05-12T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍 go 解析 json 需先定义结构体，以获取豆瓣电影信息接口为例，定义了相应结构体 Response 并给出完整代码，通过 http.Get 获取接口数据，用 json.NewDecoder 解码后可获取并打印所需字段值，如 res.Subject[0].Rating 等。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.965,"time":177900,"words":593},"slug":"2019/20190512154307","path":"blog/2019/20190512154307","filePath":"blog/2019/20190512154307.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go json解析","datePublished":"2019-05-12T00:00:00.000Z","dateModified":"2019-05-12T00:00:00.000Z","description":"文章介绍 go 解析 json 需先定义结构体，以获取豆瓣电影信息接口为例，定义了相应结构体 Response 并给出完整代码，通过 http.Get 获取接口数据，用 json.NewDecoder 解码后可获取并打印所需字段值，如 res.Subject[0].Rating 等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190512154307"}},{"title":"go 连接池","date":"2019-05-11T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍了 go 的连接池，包括使用场景、创建及相关操作函数。如 New 函数创建池子，Acquire 获取资源，Release 归还资源，Close 关闭池子。通过 main 函数中模拟数据库连接操作展示了连接池的使用。  \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.985,"time":239100,"words":797},"slug":"2019/20190511021928","path":"blog/2019/20190511021928","filePath":"blog/2019/20190511021928.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go 连接池","datePublished":"2019-05-11T00:00:00.000Z","dateModified":"2019-05-11T00:00:00.000Z","description":"文章介绍了 go 的连接池，包括使用场景、创建及相关操作函数。如 New 函数创建池子，Acquire 获取资源，Release 归还资源，Close 关闭池子。通过 main 函数中模拟数据库连接操作展示了连接池的使用。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190511021928"}},{"title":"go queue","date":"2019-05-11T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍 go 语言实现的队列，元素用 interface ，有 Push、Pop、Front、Size 方法。通过代码展示了队列的基本操作，先压入四个元素，再循环取出，无元素时结束，代码简洁实用。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.22,"time":73200,"words":244},"slug":"2019/20190511045437","path":"blog/2019/20190511045437","filePath":"blog/2019/20190511045437.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go queue","datePublished":"2019-05-11T00:00:00.000Z","dateModified":"2019-05-11T00:00:00.000Z","description":"文章介绍 go 语言实现的队列，元素用 interface ，有 Push、Pop、Front、Size 方法。通过代码展示了队列的基本操作，先压入四个元素，再循环取出，无元素时结束，代码简洁实用。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190511045437"}},{"title":"go 工作池 连接池","date":"2019-05-11T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"介绍了 go 的工作池和连接池。工作池类似线程池，通过 chan 和 defer 封装，可不断丢任务让多个线程处理；连接池用于管理数据库连接等，创建销毁代价大，通过特定结构和方法实现获取、关闭和释放连接。示例代码清晰展示其用法。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.895,"time":173700,"words":579},"slug":"2019/20190511103820","path":"blog/2019/20190511103820","filePath":"blog/2019/20190511103820.mdx","toc":[{"value":"工作池","url":"#工作池","depth":1},{"value":"连接池","url":"#连接池","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go 工作池 连接池","datePublished":"2019-05-11T00:00:00.000Z","dateModified":"2019-05-11T00:00:00.000Z","description":"介绍了 go 的工作池和连接池。工作池类似线程池，通过 chan 和 defer 封装，可不断丢任务让多个线程处理；连接池用于管理数据库连接等，创建销毁代价大，通过特定结构和方法实现获取、关闭和释放连接。示例代码清晰展示其用法。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190511103820"}},{"title":"go常见排序方法","date":"2019-05-10T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"文章介绍 golang 常见排序方法，包括整型、字符串和结构体。整型和字符串有简洁排序写法，结构体可通过切片函数按名字或年龄排序及倒序排序，展示了不同类型排序的示例及结果。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.165,"time":129900,"words":433},"slug":"2019/20190510090111","path":"blog/2019/20190510090111","filePath":"blog/2019/20190510090111.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go常见排序方法","datePublished":"2019-05-10T00:00:00.000Z","dateModified":"2019-05-10T00:00:00.000Z","description":"文章介绍 golang 常见排序方法，包括整型、字符串和结构体。整型和字符串有简洁排序写法，结构体可通过切片函数按名字或年龄排序及倒序排序，展示了不同类型排序的示例及结果。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190510090111"}},{"title":"go学习代码片段","date":"2019-05-08T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"本文包含多个 Go 学习代码片段，如斐波那契数列的闭包、非闭包和递归实现，IP 地址格式输出，简单 HTTP 服务器及路由，go chan defer 组合、超时任务处理和访问 MySQL 等，展示了 Go 语言的多种特性和用法。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.57,"time":274200,"words":914},"slug":"2019/20190508083405","path":"blog/2019/20190508083405","filePath":"blog/2019/20190508083405.mdx","toc":[{"value":"斐波纳契闭包、非闭包、递归三种实现方法","url":"#斐波纳契闭包非闭包递归三种实现方法","depth":2},{"value":"IP地址格式输出","url":"#ip地址格式输出","depth":2},{"value":"简单http服务器","url":"#简单http服务器","depth":2},{"value":"http服务路由","url":"#http服务路由","depth":2},{"value":"go chan defer组合","url":"#go-chan-defer组合","depth":2},{"value":"在超时时间内完成任务","url":"#在超时时间内完成任务","depth":2},{"value":"访问mysql","url":"#访问mysql","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"go学习代码片段","datePublished":"2019-05-08T00:00:00.000Z","dateModified":"2019-05-08T00:00:00.000Z","description":"本文包含多个 Go 学习代码片段，如斐波那契数列的闭包、非闭包和递归实现，IP 地址格式输出，简单 HTTP 服务器及路由，go chan defer 组合、超时任务处理和访问 MySQL 等，展示了 Go 语言的多种特性和用法。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190508083405"}},{"title":"vscode go插件安装失败","date":"2019-05-07T00:00:00.000Z","tags":["Go"],"draft":false,"summary":"vscode go 插件安装失败，因本地无 golang tools 致其他插件安装也失败。可手动从 github 下载，先查看 GOPATH 目录，再在 go/src 下新建 golang.org 目录并 clone tools，之后安装插件可能成功，有诸多开发便利。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.73,"time":43800,"words":146},"slug":"2019/20190507093145","path":"blog/2019/20190507093145","filePath":"blog/2019/20190507093145.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"vscode go插件安装失败","datePublished":"2019-05-07T00:00:00.000Z","dateModified":"2019-05-07T00:00:00.000Z","description":"vscode go 插件安装失败，因本地无 golang tools 致其他插件安装也失败。可手动从 github 下载，先查看 GOPATH 目录，再在 go/src 下新建 golang.org 目录并 clone tools，之后安装插件可能成功，有诸多开发便利。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190507093145"}},{"title":"MySQL的查询优化","date":"2019-05-05T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"MySQL 查询优化包括架构理解、查询过程及各阶段细节，如客户端/服务端通信协议、查询缓存等。还给出性能优化建议，如 Scheme 设计与数据类型优化、创建高性能索引（介绍 B+Tree 等相关数据结构和算法及高性能策略）、特定类型查询优化（COUNT()、关联查询、LIMIT 分页、UNION 等）。最后留两个思考题，参考资料丰富。 \r","type":"Blog","readingTime":{"text":"57 min read","minutes":56.43,"time":3385800,"words":11286},"slug":"2019/20190505090953","path":"blog/2019/20190505090953","filePath":"blog/2019/20190505090953.mdx","toc":[{"value":"MySQL逻辑架构","url":"#mysql逻辑架构","depth":3},{"value":"MySQL查询过程","url":"#mysql查询过程","depth":3},{"value":"客户端/服务端通信协议","url":"#客户端服务端通信协议","depth":4},{"value":"查询缓存","url":"#查询缓存","depth":4},{"value":"语法解析和预处理","url":"#语法解析和预处理","depth":4},{"value":"查询优化","url":"#查询优化","depth":4},{"value":"查询执行引擎","url":"#查询执行引擎","depth":4},{"value":"返回结果给客户端","url":"#返回结果给客户端","depth":4},{"value":"性能优化建议","url":"#性能优化建议","depth":3},{"value":"Scheme设计与数据类型优化","url":"#scheme设计与数据类型优化","depth":4},{"value":"创建高性能索引","url":"#创建高性能索引","depth":4},{"value":"索引相关的数据结构和算法","url":"#索引相关的数据结构和算法","depth":5},{"value":"高性能策略","url":"#高性能策略","depth":5},{"value":"1、MySQL不会使用索引的情况：非独立的列","url":"#1mysql不会使用索引的情况非独立的列","depth":6},{"value":"2、前缀索引","url":"#2前缀索引","depth":6},{"value":"3、多列索引和索引顺序","url":"#3多列索引和索引顺序","depth":6},{"value":"4、避免多个范围条件","url":"#4避免多个范围条件","depth":6},{"value":"5、覆盖索引","url":"#5覆盖索引","depth":6},{"value":"6、使用索引扫描来排序","url":"#6使用索引扫描来排序","depth":6},{"value":"7、冗余和重复索引","url":"#7冗余和重复索引","depth":6},{"value":"8、删除长期未使用的索引","url":"#8删除长期未使用的索引","depth":6},{"value":"特定类型查询优化","url":"#特定类型查询优化","depth":4},{"value":"优化COUNT()查询","url":"#优化count查询","depth":5},{"value":"优化关联查询","url":"#优化关联查询","depth":5},{"value":"优化LIMIT分页","url":"#优化limit分页","depth":5},{"value":"优化UNION","url":"#优化union","depth":5},{"value":"结语","url":"#结语","depth":4},{"value":"参考资料","url":"#参考资料","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL的查询优化","datePublished":"2019-05-05T00:00:00.000Z","dateModified":"2019-05-05T00:00:00.000Z","description":"MySQL 查询优化包括架构理解、查询过程及各阶段细节，如客户端/服务端通信协议、查询缓存等。还给出性能优化建议，如 Scheme 设计与数据类型优化、创建高性能索引（介绍 B+Tree 等相关数据结构和算法及高性能策略）、特定类型查询优化（COUNT()、关联查询、LIMIT 分页、UNION 等）。最后留两个思考题，参考资料丰富。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190505090953"}},{"title":"有什么你一看到就蹦起来找本子摘抄的句子或台词？","date":"2019-05-02T00:00:00.000Z","tags":["Life"],"draft":false,"summary":"这是 100 句让人一看到就想找本子摘抄的句子或台词，涵盖生活、爱情、哲理等多个方面，如“我啊，长到这么大，特别想回到过去，抱抱那个小时候自己”“能够让你后悔的，从来不是你做过的事，而是你想做却没有去做的事”等，表达细腻且富有深意。 \r","type":"Blog","readingTime":{"text":"18 min read","minutes":17.095,"time":1025700,"words":3419},"slug":"2019/20190502164323","path":"blog/2019/20190502164323","filePath":"blog/2019/20190502164323.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"有什么你一看到就蹦起来找本子摘抄的句子或台词？","datePublished":"2019-05-02T00:00:00.000Z","dateModified":"2019-05-02T00:00:00.000Z","description":"这是 100 句让人一看到就想找本子摘抄的句子或台词，涵盖生活、爱情、哲理等多个方面，如“我啊，长到这么大，特别想回到过去，抱抱那个小时候自己”“能够让你后悔的，从来不是你做过的事，而是你想做却没有去做的事”等，表达细腻且富有深意。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190502164323"}},{"title":"C++ 的门门道道","date":"2019-05-02T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"C++是系统级语言，易学难精。文章介绍其高级特性、常见误解及易错点，如全局变量构造析构顺序、局部变量初始化、std::sort 比较函数等，还涉及 vector 底层实现等 32 个方面，帮助提升对 C++的了解与编程效率。 \r","type":"Blog","readingTime":{"text":"25 min read","minutes":24.81,"time":1488600,"words":4962},"slug":"2019/20191210091503","path":"blog/2019/20191210091503","filePath":"blog/2019/20191210091503.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 的门门道道","datePublished":"2019-05-02T00:00:00.000Z","dateModified":"2019-05-02T00:00:00.000Z","description":"C++是系统级语言，易学难精。文章介绍其高级特性、常见误解及易错点，如全局变量构造析构顺序、局部变量初始化、std::sort 比较函数等，还涉及 vector 底层实现等 32 个方面，帮助提升对 C++的了解与编程效率。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191210091503"}},{"title":"nginx清理缓存","date":"2019-04-25T00:00:00.000Z","tags":["Web","Linux"],"draft":false,"summary":"更新 js 文件后不生效，怀疑 nginx，重启仍有问题。放弃 nginx_ngx_cache_purge 模块，采用清理服务器上 nginx 缓存目录的方法，找到缓存目录 /var/ngcache 并删除，同时可重启 nginx 或强制杀死进程后启动，最后清理浏览器缓存即可。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.5,"time":90000,"words":300},"slug":"2019/20190425054539","path":"blog/2019/20190425054539","filePath":"blog/2019/20190425054539.mdx","toc":[{"value":"nginx_ngx_cache_purge","url":"#nginx_ngx_cache_purge","depth":1},{"value":"清理服务器上nginx缓存目录","url":"#清理服务器上nginx缓存目录","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"nginx清理缓存","datePublished":"2019-04-25T00:00:00.000Z","dateModified":"2019-04-25T00:00:00.000Z","description":"更新 js 文件后不生效，怀疑 nginx，重启仍有问题。放弃 nginx_ngx_cache_purge 模块，采用清理服务器上 nginx 缓存目录的方法，找到缓存目录 /var/ngcache 并删除，同时可重启 nginx 或强制杀死进程后启动，最后清理浏览器缓存即可。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190425054539"}},{"title":"C++保证指针对象正确的销毁","date":"2019-04-19T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"C++中保证指针对象正确销毁，可通过 RAII 惯用法或 std::unique_ptr。RAII 需自定义类保证对象在作用域结束时销毁，std::unique_ptr 可自动管理对象并在离开作用域时释放，还可自定义销毁函数，能更方便地处理资源管理。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.465,"time":207900,"words":693},"slug":"2019/20190419020910","path":"blog/2019/20190419020910","filePath":"blog/2019/20190419020910.mdx","toc":[{"value":"RAII惯用法","url":"#raii惯用法","depth":1},{"value":"std::unique_ptr","url":"#stdunique_ptr","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++保证指针对象正确的销毁","datePublished":"2019-04-19T00:00:00.000Z","dateModified":"2019-04-19T00:00:00.000Z","description":"C++中保证指针对象正确销毁，可通过 RAII 惯用法或 std::unique_ptr。RAII 需自定义类保证对象在作用域结束时销毁，std::unique_ptr 可自动管理对象并在离开作用域时释放，还可自定义销毁函数，能更方便地处理资源管理。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190419020910"}},{"title":"boost asio获取本机IP地址","date":"2019-04-19T00:00:00.000Z","tags":["C/C++","Boost"],"draft":false,"summary":"文章介绍 boost asio 获取本机 IP 地址的代码，只获取 IPV4 地址且多个用分号间隔。在 Linux 上原方法可能失败，给出 Linux 上获取本地 IP 的代码，通过遍历 ifaddrs 获取 IPv4 和 IPv6 地址。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.245,"time":74700,"words":249},"slug":"2019/20190419025218","path":"blog/2019/20190419025218","filePath":"blog/2019/20190419025218.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"boost asio获取本机IP地址","datePublished":"2019-04-19T00:00:00.000Z","dateModified":"2019-04-19T00:00:00.000Z","description":"文章介绍 boost asio 获取本机 IP 地址的代码，只获取 IPV4 地址且多个用分号间隔。在 Linux 上原方法可能失败，给出 Linux 上获取本地 IP 的代码，通过遍历 ifaddrs 获取 IPv4 和 IPv6 地址。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190419025218"}},{"title":"本站鼠标滑动效果（仙尘光标）","date":"2019-04-14T00:00:00.000Z","tags":["Javascript","Web"],"draft":false,"summary":"本文介绍本站的仙尘光标鼠标滑动效果，2019 年 4 月愚人节从 stackoverflow 看到后截取代码，html 标签为`<span class=\"js-cursor-container\"></span>`，js 代码可实现鼠标移动时产生粒子效果，代码中有相关函数及粒子属性设置。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.205,"time":132300,"words":441},"slug":"2019/20190414053939","path":"blog/2019/20190414053939","filePath":"blog/2019/20190414053939.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"本站鼠标滑动效果（仙尘光标）","datePublished":"2019-04-14T00:00:00.000Z","dateModified":"2019-04-14T00:00:00.000Z","description":"本文介绍本站的仙尘光标鼠标滑动效果，2019 年 4 月愚人节从 stackoverflow 看到后截取代码，html 标签为`<span class=\"js-cursor-container\"></span>`，js 代码可实现鼠标移动时产生粒子效果，代码中有相关函数及粒子属性设置。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190414053939"}},{"title":"linux 简单服务启动、关闭脚本","date":"2019-04-12T00:00:00.000Z","tags":["Linux","Shell"],"draft":false,"summary":"介绍了 linux 简单服务启动、关闭脚本，目录结构下有启动脚本 start.sh 和关闭脚本 stop.sh。start.sh 先检查进程，获取脚本目录、可执行程序目录和依赖库目录，设置环境后后台运行程序；stop.sh 直接 kill 进程。简单解释了获取进程 ID 等操作。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.315,"time":78900,"words":263},"slug":"2019/20190412093534","path":"blog/2019/20190412093534","filePath":"blog/2019/20190412093534.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"linux 简单服务启动、关闭脚本","datePublished":"2019-04-12T00:00:00.000Z","dateModified":"2019-04-12T00:00:00.000Z","description":"介绍了 linux 简单服务启动、关闭脚本，目录结构下有启动脚本 start.sh 和关闭脚本 stop.sh。start.sh 先检查进程，获取脚本目录、可执行程序目录和依赖库目录，设置环境后后台运行程序；stop.sh 直接 kill 进程。简单解释了获取进程 ID 等操作。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190412093534"}},{"title":"qpid C++接口简单封装","date":"2019-04-12T00:00:00.000Z","tags":["C/C++","MQ"],"draft":false,"summary":"介绍 qpid C++接口简单封装，处理队列、订阅消息，发送同步、异步、推送消息的方法及示例代码，简单易用，满足大部分场景，源码在[github 源码](https://github.com/tujiaw/qpid-example)。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.51,"time":90600,"words":302},"slug":"2019/20190412095721","path":"blog/2019/20190412095721","filePath":"blog/2019/20190412095721.mdx","toc":[{"value":"处理队列请求","url":"#处理队列请求","depth":1},{"value":"接收订阅消息","url":"#接收订阅消息","depth":1},{"value":"发送同步消息","url":"#发送同步消息","depth":1},{"value":"发送异步消息","url":"#发送异步消息","depth":1},{"value":"推送消息","url":"#推送消息","depth":1},{"value":"源码","url":"#源码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"qpid C++接口简单封装","datePublished":"2019-04-12T00:00:00.000Z","dateModified":"2019-04-12T00:00:00.000Z","description":"介绍 qpid C++接口简单封装，处理队列、订阅消息，发送同步、异步、推送消息的方法及示例代码，简单易用，满足大部分场景，源码在[github 源码](https://github.com/tujiaw/qpid-example)。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190412095721"}},{"title":"关于Node.js后端架构的一点后知后觉","date":"2019-04-02T00:00:00.000Z","tags":["Node.js"],"draft":false,"summary":"分享 Node.js 后端架构的后知后觉，与淘宝前端七念老师交流后获启发。后端服务需满足容错和可扩展特性，拓展分为 X、Y、Z 轴，文中重点阐述 X 轴拓展的多进程模式及相关细节，如负载均衡和状态共享，还介绍微服务架构解决单体架构问题，微服务是解耦思想实践，最后强调应学习前辈经验。 \r","type":"Blog","readingTime":{"text":"23 min read","minutes":22.035,"time":1322100,"words":4407},"slug":"2019/20190402103718","path":"blog/2019/20190402103718","filePath":"blog/2019/20190402103718.mdx","toc":[{"value":"前言","url":"#前言","depth":2},{"value":"正文","url":"#正文","depth":2},{"value":"实例拓展","url":"#实例拓展","depth":3},{"value":"功能拓展","url":"#功能拓展","depth":3},{"value":"总结","url":"#总结","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"关于Node.js后端架构的一点后知后觉","datePublished":"2019-04-02T00:00:00.000Z","dateModified":"2019-04-02T00:00:00.000Z","description":"分享 Node.js 后端架构的后知后觉，与淘宝前端七念老师交流后获启发。后端服务需满足容错和可扩展特性，拓展分为 X、Y、Z 轴，文中重点阐述 X 轴拓展的多进程模式及相关细节，如负载均衡和状态共享，还介绍微服务架构解决单体架构问题，微服务是解耦思想实践，最后强调应学习前辈经验。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190402103718"}},{"title":"Linux常用命令大全","date":"2019-04-01T00:00:00.000Z","tags":["Linux","Shell"],"draft":false,"summary":"介绍 Linux 常用命令，包括清理缓存、查看 OOM killer 等系统相关命令，以及 ls、cd、pwd 等目录操作命令，还有 touch、rm 等文件操作命令，及权限管理、用户操作等方面的命令，还提及帮助命令、查找命令、压缩解压等操作，以及关机重启、挂载网络等命令。 \r","type":"Blog","readingTime":{"text":"16 min read","minutes":15.575,"time":934500,"words":3115},"slug":"2019/20190401063851","path":"blog/2019/20190401063851","filePath":"blog/2019/20190401063851.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux常用命令大全","datePublished":"2019-04-01T00:00:00.000Z","dateModified":"2019-04-01T00:00:00.000Z","description":"介绍 Linux 常用命令，包括清理缓存、查看 OOM killer 等系统相关命令，以及 ls、cd、pwd 等目录操作命令，还有 touch、rm 等文件操作命令，及权限管理、用户操作等方面的命令，还提及帮助命令、查找命令、压缩解压等操作，以及关机重启、挂载网络等命令。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190401063851"}},{"title":"泪流满面的 11 个 Git 面试题","date":"2019-04-01T00:00:00.000Z","tags":["Tools"],"draft":false,"summary":"文章介绍了 11 个 Git 面试题及答案，包括 Git 复刻、分支、克隆等概念区别，拉取请求与分支区别，git pull 和 git fetch 差异，恢复先前提交方法，git cherry-pick 用途，Forking 工作流程优点，HEAD 等概念区别，Gitflow 工作流程，git stash 使用场景，删除文件不删系统文件方法，以及何时用 git rebase 代替 git merge 等，对 Git 相关知识进行了全面梳理。 \r","type":"Blog","readingTime":{"text":"13 min read","minutes":12.44,"time":746400,"words":2488},"slug":"2019/20190401065210","path":"blog/2019/20190401065210","filePath":"blog/2019/20190401065210.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"泪流满面的 11 个 Git 面试题","datePublished":"2019-04-01T00:00:00.000Z","dateModified":"2019-04-01T00:00:00.000Z","description":"文章介绍了 11 个 Git 面试题及答案，包括 Git 复刻、分支、克隆等概念区别，拉取请求与分支区别，git pull 和 git fetch 差异，恢复先前提交方法，git cherry-pick 用途，Forking 工作流程优点，HEAD 等概念区别，Gitflow 工作流程，git stash 使用场景，删除文件不删系统文件方法，以及何时用 git rebase 代替 git merge 等，对 Git 相关知识进行了全面梳理。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190401065210"}},{"title":"Apache Ignite c++ linux 编译安装","date":"2019-03-29T00:00:00.000Z","tags":["Linux","C/C++"],"draft":false,"summary":"介绍 Apache Ignite c++在 linux 下的编译安装，包括环境设置、编译过程（可能出现的多种错误及解决办法）、安装及验证，还给出了 demo 链接，需注意不要直接拉 github 代码编译，要从官网下载。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.905,"time":294300,"words":981},"slug":"2019/20190329044618","path":"blog/2019/20190329044618","filePath":"blog/2019/20190329044618.mdx","toc":[{"value":"环境","url":"#环境","depth":1},{"value":"官方DEVNOTES","url":"#官方devnotes","depth":1},{"value":"编译","url":"#编译","depth":1},{"value":"error: C++ source seen but 'CXX' is undefined","url":"#error-c-source-seen-but-cxx-is-undefined","depth":2},{"value":"cc1plus: error: unrecognized command line option \"-std=c++03\"","url":"#cc1plus-error-unrecognized-command-line-option--stdc03","depth":2},{"value":"no matching function for call to check_frwd","url":"#no-matching-function-for-call-to-check_frwd","depth":2},{"value":"undefined reference to `clock_gettime'","url":"#undefined-reference-to-clock_gettime","depth":2},{"value":"安装","url":"#安装","depth":1},{"value":"验证","url":"#验证","depth":1},{"value":"demo","url":"#demo","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Apache Ignite c++ linux 编译安装","datePublished":"2019-03-29T00:00:00.000Z","dateModified":"2019-03-29T00:00:00.000Z","description":"介绍 Apache Ignite c++在 linux 下的编译安装，包括环境设置、编译过程（可能出现的多种错误及解决办法）、安装及验证，还给出了 demo 链接，需注意不要直接拉 github 代码编译，要从官网下载。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190329044618"}},{"title":"QSortFilterProxyModel排序不正确","date":"2019-03-27T00:00:00.000Z","tags":["Windows","C/C++","Qt"],"draft":false,"summary":"客户端使用 QSortFilterProxyModel 时，频繁更新 model 致 table 行排序不正确。虽可手动调用 sort 及 invalidate，却在特定操作时会崩溃。可关 dynamicSortFilter 用 Timer 控制排序，通过相关函数控制触发间隔及在 model changed 槽函数启动 timer 来解决此问题。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.61,"time":96600,"words":322},"slug":"2019/20190327003450","path":"blog/2019/20190327003450","filePath":"blog/2019/20190327003450.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QSortFilterProxyModel排序不正确","datePublished":"2019-03-27T00:00:00.000Z","dateModified":"2019-03-27T00:00:00.000Z","description":"客户端使用 QSortFilterProxyModel 时，频繁更新 model 致 table 行排序不正确。虽可手动调用 sort 及 invalidate，却在特定操作时会崩溃。可关 dynamicSortFilter 用 Timer 控制排序，通过相关函数控制触发间隔及在 model changed 槽函数启动 timer 来解决此问题。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190327003450"}},{"title":"JavaScript 栈、队列","date":"2019-03-27T00:00:00.000Z","tags":["Javascript"],"draft":false,"summary":"介绍了 JavaScript 中的栈和队列，分别用代码实现其基本操作。还提到字符串拼接的常见问题及使用 join 方法解决，join 方法避免了过多中间字符串和连接操作，执行更快。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.18,"time":70800,"words":236},"slug":"2019/20190327061343","path":"blog/2019/20190327061343","filePath":"blog/2019/20190327061343.mdx","toc":[{"value":"Stack","url":"#stack","depth":1},{"value":"Queue","url":"#queue","depth":1},{"value":"String拼接","url":"#string拼接","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript 栈、队列","datePublished":"2019-03-27T00:00:00.000Z","dateModified":"2019-03-27T00:00:00.000Z","description":"介绍了 JavaScript 中的栈和队列，分别用代码实现其基本操作。还提到字符串拼接的常见问题及使用 join 方法解决，join 方法避免了过多中间字符串和连接操作，执行更快。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190327061343"}},{"title":"MAC WIFI连上了但是不能上网","date":"2019-03-16T00:00:00.000Z","tags":["Tips"],"draft":false,"summary":"更新系统后，MAC 的 WIFI 能连上却不能上网，重置网络和重启机器都无效。后找到可连接的 wifi 打开网页，再切换回原 wifi 又可使用，没可连 wifi 时用手机开热点连笔记本即可。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.78,"time":46800,"words":156},"slug":"2019/20190316120337","path":"blog/2019/20190316120337","filePath":"blog/2019/20190316120337.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"MAC WIFI连上了但是不能上网","datePublished":"2019-03-16T00:00:00.000Z","dateModified":"2019-03-16T00:00:00.000Z","description":"更新系统后，MAC 的 WIFI 能连上却不能上网，重置网络和重启机器都无效。后找到可连接的 wifi 打开网页，再切换回原 wifi 又可使用，没可连 wifi 时用手机开热点连笔记本即可。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190316120337"}},{"title":"Qt什么时候用activateWindow","date":"2019-03-05T00:00:00.000Z","tags":["Windows","Qt","C/C++"],"draft":false,"summary":"在 Qt 中，show 用于显示窗口，raise 可将窗口置于最前。但主窗口点击时子窗口可能遮挡，此时需用 activateWindow 和 raise 解决。show 显示窗口及子窗口，showNormal 恢复最大化或最小化窗口，raise 提升窗口，activateWindow 设置活动窗口并可与 raise 配合确保窗口置顶。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.205,"time":132300,"words":441},"slug":"2019/20190305090048","path":"blog/2019/20190305090048","filePath":"blog/2019/20190305090048.mdx","toc":[{"value":"void QWidget::show()","url":"#void-qwidgetshow","depth":1},{"value":"void QWidget::showNormal()","url":"#void-qwidgetshownormal","depth":1},{"value":"void QWidget::raise()","url":"#void-qwidgetraise","depth":1},{"value":"void QWidget::activateWindow()","url":"#void-qwidgetactivatewindow","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt什么时候用activateWindow","datePublished":"2019-03-05T00:00:00.000Z","dateModified":"2019-03-05T00:00:00.000Z","description":"在 Qt 中，show 用于显示窗口，raise 可将窗口置于最前。但主窗口点击时子窗口可能遮挡，此时需用 activateWindow 和 raise 解决。show 显示窗口及子窗口，showNormal 恢复最大化或最小化窗口，raise 提升窗口，activateWindow 设置活动窗口并可与 raise 配合确保窗口置顶。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190305090048"}},{"title":"mysql CPU一直占用过高","date":"2019-02-19T00:00:00.000Z","tags":["Linux","Database"],"draft":false,"summary":"文章主要讲 mysql CPU 一直占用过高及简单解决方法。先登录 mysql 显示处理列表，发现某个 Query 状态异常，kill 掉查询 ID 后 CPU 占用率下降，此为临时解决方法，具体原因需具体分析。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.53,"time":31800,"words":106},"slug":"2019/20190219032646","path":"blog/2019/20190219032646","filePath":"blog/2019/20190219032646.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"mysql CPU一直占用过高","datePublished":"2019-02-19T00:00:00.000Z","dateModified":"2019-02-19T00:00:00.000Z","description":"文章主要讲 mysql CPU 一直占用过高及简单解决方法。先登录 mysql 显示处理列表，发现某个 Query 状态异常，kill 掉查询 ID 后 CPU 占用率下降，此为临时解决方法，具体原因需具体分析。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190219032646"}},{"title":"解决多线程处理相同产品造成的数据错乱问题","date":"2019-02-18T00:00:00.000Z","tags":["C/C++","Linux"],"draft":false,"summary":"文章主要解决多线程处理相同产品数据错乱问题，介绍两种方法。方法一是将相同产品 ID 消息放同一线程处理，分配 n 个 Worker 按序执行；方法二是收到消息时上锁，只锁产品，相同产品只允许一个线程处理，代码分别给出两种方法的实现。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.57,"time":274200,"words":914},"slug":"2019/20191210091501","path":"blog/2019/20191210091501","filePath":"blog/2019/20191210091501.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"解决多线程处理相同产品造成的数据错乱问题","datePublished":"2019-02-18T00:00:00.000Z","dateModified":"2019-02-18T00:00:00.000Z","description":"文章主要解决多线程处理相同产品数据错乱问题，介绍两种方法。方法一是将相同产品 ID 消息放同一线程处理，分配 n 个 Worker 按序执行；方法二是收到消息时上锁，只锁产品，相同产品只允许一个线程处理，代码分别给出两种方法的实现。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191210091501"}},{"title":"C++保证函数能在超时时间内返回","date":"2019-01-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍 C++保证函数在超时时间内返回的方法。通过两个接口 execTimeout 实现，利用 shared_from_this 避免智能指针释放，启动新线程执行函数，demo 展示正常返回和超时返回，代码包含 TimeoutGuard 类的实现。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.38,"time":142800,"words":476},"slug":"2019/20190124103912","path":"blog/2019/20190124103912","filePath":"blog/2019/20190124103912.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++保证函数能在超时时间内返回","datePublished":"2019-01-24T00:00:00.000Z","dateModified":"2019-01-24T00:00:00.000Z","description":"介绍 C++保证函数在超时时间内返回的方法。通过两个接口 execTimeout 实现，利用 shared_from_this 避免智能指针释放，启动新线程执行函数，demo 展示正常返回和超时返回，代码包含 TimeoutGuard 类的实现。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20190124103912"}},{"title":"C、C++ 跨平台获取当前进程内存","date":"2019-01-17T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"文章介绍跨平台获取当前进程内存，“Resident set size”很重要。提供了获取进程峰值和当前驻留集大小的函数，在不同操作系统（如 Windows、Linux 等）有不同实现方式，给出了相应源码。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.545,"time":152700,"words":509},"slug":"2019/20191210091502","path":"blog/2019/20191210091502","filePath":"blog/2019/20191210091502.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C、C++ 跨平台获取当前进程内存","datePublished":"2019-01-17T00:00:00.000Z","dateModified":"2019-01-17T00:00:00.000Z","description":"文章介绍跨平台获取当前进程内存，“Resident set size”很重要。提供了获取进程峰值和当前驻留集大小的函数，在不同操作系统（如 Windows、Linux 等）有不同实现方式，给出了相应源码。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2019/20191210091502"}},{"title":"vi、vim常用功能键","date":"2018-12-23T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"总结：介绍 vi、vim 常用功能键，包括移动光标、翻页、跳转、搜索、删除复制粘贴、模式切换及 vim 环境变更等，如 h/j/k/l 移动，ctrl+f/b 翻页等，功能丰富实用。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.92,"time":235200,"words":784},"slug":"2018/20181223030336","path":"blog/2018/20181223030336","filePath":"blog/2018/20181223030336.mdx","toc":[{"value":"-----   h或向左方向键  光标向左移动一个字符   j或向下方向键  光标向下移动一个字符   k或向上方向键  光标向上移动一个字符   l或向有方向键  光标向右移动一个字母    翻页键  说明  --------   ctrl+f  屏幕向下移动一页...","url":"#--------h或向左方向键--光标向左移动一个字符---j或向下方向键--光标向下移动一个字符---k或向上方向键--光标向上移动一个字符---l或向有方向键--光标向右移动一个字母----翻页键--说明-------------ctrlf--屏幕向下移动一页","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"vi、vim常用功能键","datePublished":"2018-12-23T00:00:00.000Z","dateModified":"2018-12-23T00:00:00.000Z","description":"总结：介绍 vi、vim 常用功能键，包括移动光标、翻页、跳转、搜索、删除复制粘贴、模式切换及 vim 环境变更等，如 h/j/k/l 移动，ctrl+f/b 翻页等，功能丰富实用。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20181223030336"}},{"title":"STL容器循环erase迭代器失效","date":"2018-12-20T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"文章介绍 STL 容器循环 erase 迭代器失效，以 std::map 为例，给出 C++11 和 C++03 两种写法。C++03 中 iter++可避免迭代器失效，而 C++11 写法在某些 linux 编译器不支持，同时指出错误写法会造成崩溃。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.215,"time":72900,"words":243},"slug":"2018/20181220014221","path":"blog/2018/20181220014221","filePath":"blog/2018/20181220014221.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"STL容器循环erase迭代器失效","datePublished":"2018-12-20T00:00:00.000Z","dateModified":"2018-12-20T00:00:00.000Z","description":"文章介绍 STL 容器循环 erase 迭代器失效，以 std::map 为例，给出 C++11 和 C++03 两种写法。C++03 中 iter++可避免迭代器失效，而 C++11 写法在某些 linux 编译器不支持，同时指出错误写法会造成崩溃。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20181220014221"}},{"title":"qpid笔记","date":"2018-12-14T00:00:00.000Z","tags":["C/C++","MQ"],"draft":false,"summary":"介绍 qpid 相关笔记，包括查看队列及连接信息、删除队列、qpid-tool 用法、消息处理相关操作（如 session.acknowledge、session.sync）及不同类型 exchange（queue、topic）的特点和使用方式。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.995,"time":179700,"words":599},"slug":"2018/20181214105709","path":"blog/2018/20181214105709","filePath":"blog/2018/20181214105709.mdx","toc":[{"value":"查看所有队列包括消息的信息","url":"#查看所有队列包括消息的信息","depth":1},{"value":"查看指定队列信息","url":"#查看指定队列信息","depth":1},{"value":"查看连接信息，连接数、时间、消息数等","url":"#查看连接信息连接数时间消息数等","depth":1},{"value":"删除指定队列","url":"#删除指定队列","depth":1},{"value":"qpid-tool","url":"#qpid-tool","depth":1},{"value":"session.acknowledge","url":"#sessionacknowledge","depth":1},{"value":"session.sync(true)","url":"#sessionsynctrue","depth":1},{"value":"delete:always","url":"#deletealways","depth":1},{"value":"exchange","url":"#exchange","depth":1},{"value":"type为queue（direct模式）","url":"#type为queuedirect模式","depth":1},{"value":"type为topic（topic模式）","url":"#type为topictopic模式","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"qpid笔记","datePublished":"2018-12-14T00:00:00.000Z","dateModified":"2018-12-14T00:00:00.000Z","description":"介绍 qpid 相关笔记，包括查看队列及连接信息、删除队列、qpid-tool 用法、消息处理相关操作（如 session.acknowledge、session.sync）及不同类型 exchange（queue、topic）的特点和使用方式。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20181214105709"}},{"title":"linux实用命令备忘录","date":"2018-11-28T00:00:00.000Z","tags":["Linux","Shell"],"draft":false,"summary":"这是 linux 实用命令备忘录，包含查看进程是否存在、端口占用、端口连接数、进程线程数等命令，还有 nginx 相关操作及 shell 脚本获取当前路径等，以及查看运行进程所在目录和目录文件大小的命令。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.785,"time":107100,"words":357},"slug":"2018/20181128142804","path":"blog/2018/20181128142804","filePath":"blog/2018/20181128142804.mdx","toc":[{"value":"查看某个进程是否存在","url":"#查看某个进程是否存在","depth":3},{"value":"查看一个端口被什么进程占用","url":"#查看一个端口被什么进程占用","depth":3},{"value":"查看某个端口TCP的连接数","url":"#查看某个端口tcp的连接数","depth":3},{"value":"查看某个进程使用的线程数","url":"#查看某个进程使用的线程数","depth":3},{"value":"nginx","url":"#nginx","depth":3},{"value":"shell","url":"#shell","depth":3},{"value":"查看运行进程所在目录","url":"#查看运行进程所在目录","depth":1},{"value":"目录文件大小","url":"#目录文件大小","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"linux实用命令备忘录","datePublished":"2018-11-28T00:00:00.000Z","dateModified":"2018-11-28T00:00:00.000Z","description":"这是 linux 实用命令备忘录，包含查看进程是否存在、端口占用、端口连接数、进程线程数等命令，还有 nginx 相关操作及 shell 脚本获取当前路径等，以及查看运行进程所在目录和目录文件大小的命令。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20181128142804"}},{"title":"linux问题汇总","date":"2018-11-27T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.69,"time":41400,"words":138},"slug":"2018/20181127011300","path":"blog/2018/20181127011300","filePath":"blog/2018/20181127011300.mdx","toc":[{"value":"Unable to find remote helper for 'https'","url":"#unable-to-find-remote-helper-for-https","depth":3},{"value":"/bin/bash^M: bad interpreter: No such file or directory","url":"#binbashm-bad-interpreter-no-such-file-or-directory","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"linux问题汇总","datePublished":"2018-11-27T00:00:00.000Z","dateModified":"2018-11-27T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20181127011300"}},{"title":"qpid-cpp Windows编译","date":"2018-11-27T00:00:00.000Z","tags":["Windows","C/C++","MQ"],"draft":false,"summary":"介绍 qpid-cpp Windows 编译，需先安装 boost 等，下载源码解压后用 CMake 配置，因缺 boost 设 BOOST_ROOT 路径，后用 vs 编译 ALL_BUILD 和 INSTALL，即便有 setlocal 错误，qpid-cpp 也已安装在 C:\\Program Files (x86)\\qpid-cpp 目录下。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.585,"time":35100,"words":117},"slug":"2018/20181127052642","path":"blog/2018/20181127052642","filePath":"blog/2018/20181127052642.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"qpid-cpp Windows编译","datePublished":"2018-11-27T00:00:00.000Z","dateModified":"2018-11-27T00:00:00.000Z","description":"介绍 qpid-cpp Windows 编译，需先安装 boost 等，下载源码解压后用 CMake 配置，因缺 boost 设 BOOST_ROOT 路径，后用 vs 编译 ALL_BUILD 和 INSTALL，即便有 setlocal 错误，qpid-cpp 也已安装在 C:\\Program Files (x86)\\qpid-cpp 目录下。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20181127052642"}},{"title":"简单shell守护脚本——mongodb","date":"2018-10-22T00:00:00.000Z","tags":["Linux","Shell"],"draft":false,"summary":"本文展示了一个监控MongoDB进程并在崩溃时自动重启的Shell脚本实现。\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.7,"time":42000,"words":140},"slug":"2018/20181022020627","path":"blog/2018/20181022020627","filePath":"blog/2018/20181022020627.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"简单shell守护脚本——mongodb","datePublished":"2018-10-22T00:00:00.000Z","dateModified":"2018-10-22T00:00:00.000Z","description":"本文展示了一个监控MongoDB进程并在崩溃时自动重启的Shell脚本实现。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20181022020627"}},{"title":"中国诗词写入mongodb","date":"2018-10-19T00:00:00.000Z","tags":["Node.js","MongoDB"],"draft":false,"summary":"本文展示如何使用Mongoose将中国古诗词JSON数据导入MongoDB数据库，包含模型定义和数据处理过程。\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.045,"time":122700,"words":409},"slug":"2018/20181019103833","path":"blog/2018/20181019103833","filePath":"blog/2018/20181019103833.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"中国诗词写入mongodb","datePublished":"2018-10-19T00:00:00.000Z","dateModified":"2018-10-19T00:00:00.000Z","description":"本文展示如何使用Mongoose将中国古诗词JSON数据导入MongoDB数据库，包含模型定义和数据处理过程。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20181019103833"}},{"title":"Qt 客户端应用程序多开要注意的问题","date":"2018-10-15T00:00:00.000Z","tags":["C/C++","Qt","Windows"],"draft":false,"summary":"Qt 客户端多开需注意本地配置、进程名及全局信息。可通过 RunGuard 类保证同一程序仅运行一个进程，多开时要保证目录和进程名不同，若已有进程运行则打开其主窗口。  \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.06,"time":183600,"words":612},"slug":"2018/20181015092408","path":"blog/2018/20181015092408","filePath":"blog/2018/20181015092408.mdx","toc":[{"value":"本地配置","url":"#本地配置","depth":1},{"value":"进程名","url":"#进程名","depth":1},{"value":"全局信息","url":"#全局信息","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt 客户端应用程序多开要注意的问题","datePublished":"2018-10-15T00:00:00.000Z","dateModified":"2018-10-15T00:00:00.000Z","description":"Qt 客户端多开需注意本地配置、进程名及全局信息。可通过 RunGuard 类保证同一程序仅运行一个进程，多开时要保证目录和进程名不同，若已有进程运行则打开其主窗口。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20181015092408"}},{"title":"bug修复，浮点型计算","date":"2018-09-29T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"本文讨论C++浮点型计算的陷阱，特别是浮点型转整型时会丢失小数部分，并推荐使用C++11的std::lround函数来正确处理转换。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.56,"time":93600,"words":312},"slug":"2018/20180929061745","path":"blog/2018/20180929061745","filePath":"blog/2018/20180929061745.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"bug修复，浮点型计算","datePublished":"2018-09-29T00:00:00.000Z","dateModified":"2018-09-29T00:00:00.000Z","description":"本文讨论C++浮点型计算的陷阱，特别是浮点型转整型时会丢失小数部分，并推荐使用C++11的std::lround函数来正确处理转换。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180929061745"}},{"title":"koa2处理get,post参数的常见方式","date":"2018-09-28T00:00:00.000Z","tags":["Javascript","Node.js"],"draft":false,"summary":"koa2 处理 get、post 参数常见方式：url 传参通过路由和 ctx 获取；表单 post 用 ctx.request.body 获表单参数；ajax post 若 data 为对象可直接获取，若为字符串需解析。多种请求应答处理参数方法已列举。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.74,"time":104400,"words":348},"slug":"2018/20180928063457","path":"blog/2018/20180928063457","filePath":"blog/2018/20180928063457.mdx","toc":[{"value":"url显示传参","url":"#url显示传参","depth":1},{"value":"根据文章id获取这篇文章的内容","url":"#根据文章id获取这篇文章的内容","depth":2},{"value":"分页获取文章列表","url":"#分页获取文章列表","depth":2},{"value":"post提交表单","url":"#post提交表单","depth":1},{"value":"ajax post","url":"#ajax-post","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"koa2处理get,post参数的常见方式","datePublished":"2018-09-28T00:00:00.000Z","dateModified":"2018-09-28T00:00:00.000Z","description":"koa2 处理 get、post 参数常见方式：url 传参通过路由和 ctx 获取；表单 post 用 ctx.request.body 获表单参数；ajax post 若 data 为对象可直接获取，若为字符串需解析。多种请求应答处理参数方法已列举。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180928063457"}},{"title":"Qt connect函数参数Qt  ConnectionType的使用场景","date":"2018-09-25T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"Qt connect 函数的 Qt::ConnectionType 参数决定信号投递和槽函数执行方式。有 Auto、Direct、Queued、BlockingQueued、Unique 等值，分别对应不同线程下的信号槽处理情况，可根据需求选择使用。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.405,"time":144300,"words":481},"slug":"2018/20181223030338","path":"blog/2018/20181223030338","filePath":"blog/2018/20181223030338.mdx","toc":[{"value":"Qt::AutoConnection","url":"#qtautoconnection","depth":1},{"value":"Qt::DirectConnection","url":"#qtdirectconnection","depth":1},{"value":"Qt::QueuedConnection","url":"#qtqueuedconnection","depth":1},{"value":"Qt::BlockingQueuedConnection","url":"#qtblockingqueuedconnection","depth":1},{"value":"Qt::UniqueConnection","url":"#qtuniqueconnection","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt connect函数参数Qt  ConnectionType的使用场景","datePublished":"2018-09-25T00:00:00.000Z","dateModified":"2018-09-25T00:00:00.000Z","description":"Qt connect 函数的 Qt::ConnectionType 参数决定信号投递和槽函数执行方式。有 Auto、Direct、Queued、BlockingQueued、Unique 等值，分别对应不同线程下的信号槽处理情况，可根据需求选择使用。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20181223030338"}},{"title":"Javascript小技巧","date":"2018-09-05T00:00:00.000Z","tags":["Javascript"],"draft":false,"summary":"总结：介绍了多种 Javascript 技巧，如删除数组尾部元素、使用对象解构模拟命名参数等，还涵盖了在 Switch 语句中用范围值、await 多个 async 函数等内容，涵盖全面且实用。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.165,"time":249900,"words":833},"slug":"2018/20180905015332","path":"blog/2018/20180905015332","filePath":"blog/2018/20180905015332.mdx","toc":[{"value":"删除数组尾部元素","url":"#删除数组尾部元素","depth":1},{"value":"使用对象解构（object destructuring）来模拟命名参数","url":"#使用对象解构object-destructuring来模拟命名参数","depth":1},{"value":"使用对象解构来处理数组","url":"#使用对象解构来处理数组","depth":1},{"value":"在 Switch 语句中使用范围值","url":"#在-switch-语句中使用范围值","depth":1},{"value":"await多个async函数","url":"#await多个async函数","depth":1},{"value":"创建Pure objects","url":"#创建pure-objects","depth":1},{"value":"格式化JSON代码","url":"#格式化json代码","depth":1},{"value":"从数组中移除重复元素","url":"#从数组中移除重复元素","depth":1},{"value":"平铺多维数组","url":"#平铺多维数组","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Javascript小技巧","datePublished":"2018-09-05T00:00:00.000Z","dateModified":"2018-09-05T00:00:00.000Z","description":"总结：介绍了多种 Javascript 技巧，如删除数组尾部元素、使用对象解构模拟命名参数等，还涵盖了在 Switch 语句中用范围值、await 多个 async 函数等内容，涵盖全面且实用。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180905015332"}},{"title":"React session","date":"2018-09-03T00:00:00.000Z","tags":["React"],"draft":false,"summary":"介绍了 React session 的实现方式，包括服务端支持的请求及封装的 AuthService.js，用高阶组件 withAuth 方便组件使用，还给出了登录页面 Login.js 等示例，灵感来自 react-with-styles 且建议用 next-with-auth 库更好。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.83,"time":229800,"words":766},"slug":"2018/20180903091740","path":"blog/2018/20180903091740","filePath":"blog/2018/20180903091740.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"React session","datePublished":"2018-09-03T00:00:00.000Z","dateModified":"2018-09-03T00:00:00.000Z","description":"介绍了 React session 的实现方式，包括服务端支持的请求及封装的 AuthService.js，用高阶组件 withAuth 方便组件使用，还给出了登录页面 Login.js 等示例，灵感来自 react-with-styles 且建议用 next-with-auth 库更好。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180903091740"}},{"title":"比较QKeyEvent和shortcut的按键信息","date":"2018-09-03T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"文章主要比较 QKeyEvent 和 shortcut 的按键信息，通过 setShortcut 给 button 设置快捷方式，用 QKeyEvent 的 modifiers 和 key 函数获取按键，将其转换为 QKeySequence 后与 shortcut 比较，经处理使格式一致，常见组合键判断没问题但不排除特殊情况。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.165,"time":69900,"words":233},"slug":"2018/20180903093400","path":"blog/2018/20180903093400","filePath":"blog/2018/20180903093400.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"比较QKeyEvent和shortcut的按键信息","datePublished":"2018-09-03T00:00:00.000Z","dateModified":"2018-09-03T00:00:00.000Z","description":"文章主要比较 QKeyEvent 和 shortcut 的按键信息，通过 setShortcut 给 button 设置快捷方式，用 QKeyEvent 的 modifiers 和 key 函数获取按键，将其转换为 QKeySequence 后与 shortcut 比较，经处理使格式一致，常见组合键判断没问题但不排除特殊情况。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180903093400"}},{"title":"CMake简单用法","date":"2018-08-16T00:00:00.000Z","tags":["Tools"],"draft":false,"summary":"介绍 CMake 简单用法，包括静态库、动态库、可执行程序及多工程模板。静态库通过特定 CMakeLists.txt 编译生成 libstatic_math.a；动态库类似，将 STATIC 改为 SHARED；可执行程序使用静态库和动态库需添加头文件目录等；多工程模板有主 CMakeLists.txt 及各子工程 CMakeLists.txt。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.215,"time":132900,"words":443},"slug":"2018/20180816015746","path":"blog/2018/20180816015746","filePath":"blog/2018/20180816015746.mdx","toc":[{"value":"静态库","url":"#静态库","depth":1},{"value":"动态库","url":"#动态库","depth":1},{"value":"可执行程序","url":"#可执行程序","depth":1},{"value":"多工程模板","url":"#多工程模板","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"CMake简单用法","datePublished":"2018-08-16T00:00:00.000Z","dateModified":"2018-08-16T00:00:00.000Z","description":"介绍 CMake 简单用法，包括静态库、动态库、可执行程序及多工程模板。静态库通过特定 CMakeLists.txt 编译生成 libstatic_math.a；动态库类似，将 STATIC 改为 SHARED；可执行程序使用静态库和动态库需添加头文件目录等；多工程模板有主 CMakeLists.txt 及各子工程 CMakeLists.txt。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180816015746"}},{"title":"is_block_type_valid 断言错误","date":"2018-08-02T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.725,"time":43500,"words":145},"slug":"2018/20181223030337","path":"blog/2018/20181223030337","filePath":"blog/2018/20181223030337.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"is_block_type_valid 断言错误","datePublished":"2018-08-02T00:00:00.000Z","dateModified":"2018-08-02T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20181223030337"}},{"title":"JAVA8 十大新特性详解","date":"2018-07-16T00:00:00.000Z","tags":["Java"],"draft":false,"summary":"Java8 十大新特性详解：默认方法、Lambda 表达式、函数式接口、方法与构造函数引用、Lambda 作用域、Stream 接口等。新 API 如日期 API 更便捷，还支持多重注解，提升开发效率，有众多实用内容待发掘。 \r","type":"Blog","readingTime":{"text":"25 min read","minutes":24.13,"time":1447800,"words":4826},"slug":"2018/20180716074125","path":"blog/2018/20180716074125","filePath":"blog/2018/20180716074125.mdx","toc":[{"value":"1. 接口的默认方法","url":"#1-接口的默认方法","depth":1},{"value":"2. Lambda 表达式","url":"#2-lambda-表达式","depth":1},{"value":"3. 函数式接口","url":"#3-函数式接口","depth":1},{"value":"4. 方法与构造函数引用","url":"#4-方法与构造函数引用","depth":1},{"value":"5. Lambda 作用域","url":"#5-lambda-作用域","depth":1},{"value":"6. 访问局部变量","url":"#6-访问局部变量","depth":1},{"value":"7. 访问对象字段与静态变量","url":"#7-访问对象字段与静态变量","depth":1},{"value":"8. 访问接口的默认方法","url":"#8-访问接口的默认方法","depth":1},{"value":"Predicate接口","url":"#predicate接口","depth":2},{"value":"Function 接口","url":"#function-接口","depth":2},{"value":"Supplier 接口","url":"#supplier-接口","depth":2},{"value":"Consumer 接口","url":"#consumer-接口","depth":2},{"value":"Comparator 接口","url":"#comparator-接口","depth":2},{"value":"Optional 接口","url":"#optional-接口","depth":2},{"value":"Stream 接口","url":"#stream-接口","depth":2},{"value":"Filter 过滤","url":"#filter-过滤","depth":2},{"value":"Sort 排序","url":"#sort-排序","depth":2},{"value":"Map 映射","url":"#map-映射","depth":2},{"value":"Match 匹配","url":"#match-匹配","depth":2},{"value":"Count 计数","url":"#count-计数","depth":2},{"value":"Reduce 规约","url":"#reduce-规约","depth":2},{"value":"并行Streams","url":"#并行streams","depth":2},{"value":"Map","url":"#map","depth":2},{"value":"9. Date API","url":"#9-date-api","depth":1},{"value":"Clock 时钟","url":"#clock-时钟","depth":2},{"value":"Timezones 时区","url":"#timezones-时区","depth":2},{"value":"LocalTime 本地时间","url":"#localtime-本地时间","depth":2},{"value":"LocalDate 本地日期","url":"#localdate-本地日期","depth":2},{"value":"LocalDateTime 本地日期时间","url":"#localdatetime-本地日期时间","depth":2},{"value":"10. Annotation 注解","url":"#10-annotation-注解","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"JAVA8 十大新特性详解","datePublished":"2018-07-16T00:00:00.000Z","dateModified":"2018-07-16T00:00:00.000Z","description":"Java8 十大新特性详解：默认方法、Lambda 表达式、函数式接口、方法与构造函数引用、Lambda 作用域、Stream 接口等。新 API 如日期 API 更便捷，还支持多重注解，提升开发效率，有众多实用内容待发掘。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180716074125"}},{"title":"一张图展示google c++ 代码规范","date":"2018-07-13T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"本文通过一张图展示Google C++代码规范，包含命名规则、代码结构和注释风格等内容。\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.16,"time":9600,"words":32},"slug":"2018/20180713020055","path":"blog/2018/20180713020055","filePath":"blog/2018/20180713020055.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"一张图展示google c++ 代码规范","datePublished":"2018-07-13T00:00:00.000Z","dateModified":"2018-07-13T00:00:00.000Z","description":"本文通过一张图展示Google C++代码规范，包含命名规则、代码结构和注释风格等内容。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180713020055"}},{"title":"AStyle格式化代码","date":"2018-07-13T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"本文介绍如何使用Node.js脚本调用AStyle.exe批量格式化C/C++代码文件，包含配置和使用方法。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.11,"time":66600,"words":222},"slug":"2018/20180713101633","path":"blog/2018/20180713101633","filePath":"blog/2018/20180713101633.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"AStyle格式化代码","datePublished":"2018-07-13T00:00:00.000Z","dateModified":"2018-07-13T00:00:00.000Z","description":"本文介绍如何使用Node.js脚本调用AStyle.exe批量格式化C/C++代码文件，包含配置和使用方法。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180713101633"}},{"title":"windows安装包制作","date":"2018-07-02T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"本文介绍用 Qt 官方的 qt-installer-framework 制作 Windows 安装包，给出主要目录结构及各文件内容，如 config.xml、package.xml 等，还说明了放置应用程序文件及打包命令等，最后提供目录结构和制作后的安装包下载地址。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.685,"time":161100,"words":537},"slug":"2018/20180702073359","path":"blog/2018/20180702073359","filePath":"blog/2018/20180702073359.mdx","toc":[{"value":"准备主要目录结构","url":"#准备主要目录结构","depth":1},{"value":"创建config.xml文件","url":"#创建configxml文件","depth":1},{"value":"创建package.xml文件","url":"#创建packagexml文件","depth":1},{"value":"放置应用程序文件","url":"#放置应用程序文件","depth":1},{"value":"打包","url":"#打包","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"windows安装包制作","datePublished":"2018-07-02T00:00:00.000Z","dateModified":"2018-07-02T00:00:00.000Z","description":"本文介绍用 Qt 官方的 qt-installer-framework 制作 Windows 安装包，给出主要目录结构及各文件内容，如 config.xml、package.xml 等，还说明了放置应用程序文件及打包命令等，最后提供目录结构和制作后的安装包下载地址。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180702073359"}},{"title":"visual studio中props文件用法","date":"2018-06-29T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"在 visual studio 中，.props 文件可固定工程配置，方便下次使用。其内容包含库目录宏定义等，导入到 vcxproj 文件只需在后者中用<Import Project=\"$(SolutionDir)asio.props\"/>等语句。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.43,"time":85800,"words":286},"slug":"2018/20180629060934","path":"blog/2018/20180629060934","filePath":"blog/2018/20180629060934.mdx","toc":[{"value":"props文件内容","url":"#props文件内容","depth":1},{"value":"导入props到vcxproj文件中","url":"#导入props到vcxproj文件中","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"visual studio中props文件用法","datePublished":"2018-06-29T00:00:00.000Z","dateModified":"2018-06-29T00:00:00.000Z","description":"在 visual studio 中，.props 文件可固定工程配置，方便下次使用。其内容包含库目录宏定义等，导入到 vcxproj 文件只需在后者中用<Import Project=\"$(SolutionDir)asio.props\"/>等语句。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180629060934"}},{"title":"解决github慢的问题","date":"2018-06-25T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"这篇文章介绍了如何解决GitHub下载速度慢的问题。作者通过查询GitHub域名对应的IP地址，并修改Windows系统的hosts文件，使得GitHub的下载速度大大提高。同时，文章还提供了在MAC电脑上修改hosts文件的步骤。最后，作者测试了修改后的效果，下载速度达到了400~500kiB/s。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.835,"time":110100,"words":367},"slug":"2018/20180625063630","path":"blog/2018/20180625063630","filePath":"blog/2018/20180625063630.mdx","toc":[{"value":"获取github域名对应的IP地址","url":"#获取github域名对应的ip地址","depth":1},{"value":"修改hosts文件","url":"#修改hosts文件","depth":1},{"value":"不重启电脑生效hosts","url":"#不重启电脑生效hosts","depth":1},{"value":"MAC电脑修改host文件","url":"#mac电脑修改host文件","depth":1},{"value":"测试","url":"#测试","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"解决github慢的问题","datePublished":"2018-06-25T00:00:00.000Z","dateModified":"2018-06-25T00:00:00.000Z","description":"这篇文章介绍了如何解决GitHub下载速度慢的问题。作者通过查询GitHub域名对应的IP地址，并修改Windows系统的hosts文件，使得GitHub的下载速度大大提高。同时，文章还提供了在MAC电脑上修改hosts文件的步骤。最后，作者测试了修改后的效果，下载速度达到了400~500kiB/s。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180625063630"}},{"title":"http升级到https","date":"2018-06-23T00:00:00.000Z","tags":["Web","Node.js","Linux"],"draft":false,"summary":"文章介绍 http 升级到 https 的过程，环境为腾讯云服务、nodejs 服务和 nginx 反向代理。包括获取免费 DVSSL 证书、上传证书到 nginx 目录、修改 conf 文件（改 80 服务为 443 并新增 80 强制跳转到 https 服务）及 nginx reload 等步骤。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.555,"time":93300,"words":311},"slug":"2018/20180623230827","path":"blog/2018/20180623230827","filePath":"blog/2018/20180623230827.mdx","toc":[{"value":"获取证书","url":"#获取证书","depth":1},{"value":"上传证书","url":"#上传证书","depth":1},{"value":"修改conf文件","url":"#修改conf文件","depth":1},{"value":"nginx reload","url":"#nginx-reload","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"http升级到https","datePublished":"2018-06-23T00:00:00.000Z","dateModified":"2018-06-23T00:00:00.000Z","description":"文章介绍 http 升级到 https 的过程，环境为腾讯云服务、nodejs 服务和 nginx 反向代理。包括获取免费 DVSSL 证书、上传证书到 nginx 目录、修改 conf 文件（改 80 服务为 443 并新增 80 强制跳转到 https 服务）及 nginx reload 等步骤。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180623230827"}},{"title":"boost asio使用技巧","date":"2018-06-15T00:00:00.000Z","tags":["C/C++","Boost"],"draft":false,"summary":"本文介绍了Boost.Asio库的使用技巧和基本概念，涵盖I/O服务、Proactor模型、缓冲区管理、I/O对象、信号处理、定时器和strand等功能。\r","type":"Blog","readingTime":{"text":"15 min read","minutes":14.99,"time":899400,"words":2998},"slug":"2018/20180615013147","path":"blog/2018/20180615013147","filePath":"blog/2018/20180615013147.mdx","toc":[{"value":"基本概念","url":"#基本概念","depth":1},{"value":"Asio proactor","url":"#asio-proactor","depth":1},{"value":"I/O服务","url":"#io服务","depth":1},{"value":"work类","url":"#work类","depth":2},{"value":"run() vs poll()","url":"#run-vs-poll","depth":2},{"value":"stop()","url":"#stop","depth":2},{"value":"post() vs dispatch()","url":"#post-vs-dispatch","depth":2},{"value":"buffer类","url":"#buffer类","depth":1},{"value":"缓冲区管理","url":"#缓冲区管理","depth":1},{"value":"I/O对象","url":"#io对象","depth":1},{"value":"socket","url":"#socket","depth":2},{"value":"信号处理","url":"#信号处理","depth":2},{"value":"定时器","url":"#定时器","depth":2},{"value":"strand","url":"#strand","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"boost asio使用技巧","datePublished":"2018-06-15T00:00:00.000Z","dateModified":"2018-06-15T00:00:00.000Z","description":"本文介绍了Boost.Asio库的使用技巧和基本概念，涵盖I/O服务、Proactor模型、缓冲区管理、I/O对象、信号处理、定时器和strand等功能。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180615013147"}},{"title":"字符串 单词 翻转","date":"2018-06-11T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"本文介绍字符串和单词翻转的实现方法，提供C++和C#的代码示例，展示如何通过分段反序实现特定翻转效果。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.73,"time":103800,"words":346},"slug":"2018/20180611073200","path":"blog/2018/20180611073200","filePath":"blog/2018/20180611073200.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"字符串 单词 翻转","datePublished":"2018-06-11T00:00:00.000Z","dateModified":"2018-06-11T00:00:00.000Z","description":"本文介绍字符串和单词翻转的实现方法，提供C++和C#的代码示例，展示如何通过分段反序实现特定翻转效果。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180611073200"}},{"title":"c++ 性能优化策略","date":"2018-06-03T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"总结 c++ 性能优化策略：从程序架构到具体细节，如避免过度继承、合理使用对象复合等；优化构造函数、变量定义等；善用内联、stl 等，还包括缓存、多线程等方面的技巧。 \r","type":"Blog","readingTime":{"text":"7 min read","minutes":6.935,"time":416100,"words":1387},"slug":"2018/20180603040126","path":"blog/2018/20180603040126","filePath":"blog/2018/20180603040126.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"c++ 性能优化策略","datePublished":"2018-06-03T00:00:00.000Z","dateModified":"2018-06-03T00:00:00.000Z","description":"总结 c++ 性能优化策略：从程序架构到具体细节，如避免过度继承、合理使用对象复合等；优化构造函数、变量定义等；善用内联、stl 等，还包括缓存、多线程等方面的技巧。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180603040126"}},{"title":"简单有理数(Rational)实现","date":"2018-06-02T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"本文展示了C++中有理数(Rational)类的实现方法，包含基本运算和相关功能。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.575,"time":94500,"words":315},"slug":"2018/20180602150307","path":"blog/2018/20180602150307","filePath":"blog/2018/20180602150307.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"简单有理数(Rational)实现","datePublished":"2018-06-02T00:00:00.000Z","dateModified":"2018-06-02T00:00:00.000Z","description":"本文展示了C++中有理数(Rational)类的实现方法，包含基本运算和相关功能。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180602150307"}},{"title":"C++惯用法","date":"2018-05-19T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"总结 C++ 相关内容：虚基类需 virtual 析构，std::auto_ptr 有风险用 unique_ptr 替代，重载 operator&()用 std::addressof，不支持重载函数模板及名称空间问题，基类派生类成员变量初始化顺序等，还提到一些其他用法及注意事项。 \r","type":"Blog","readingTime":{"text":"7 min read","minutes":6.875,"time":412500,"words":1375},"slug":"2018/20180519135047","path":"blog/2018/20180519135047","filePath":"blog/2018/20180519135047.mdx","toc":[{"value":"虚基类中要实现virtual析构函数","url":"#虚基类中要实现virtual析构函数","depth":1},{"value":"std::auto_ptr和std::unique_ptr区别","url":"#stdauto_ptr和stdunique_ptr区别","depth":1},{"value":"当某个类重载了operator&()操作符的时候应该怎样获取对象的地址","url":"#当某个类重载了operator操作符的时候应该怎样获取对象的地址","depth":1},{"value":"C++不支持重载函数模板，许多实现仍然不支持名称空间","url":"#c不支持重载函数模板许多实现仍然不支持名称空间","depth":1},{"value":"基类，派生类，成员变量初始化顺序","url":"#基类派生类成员变量初始化顺序","depth":1},{"value":"成员变量之间的初始化顺序","url":"#成员变量之间的初始化顺序","depth":1},{"value":"派生类构造函数中不能调用虚函数","url":"#派生类构造函数中不能调用虚函数","depth":1},{"value":"未定义对象的删除","url":"#未定义对象的删除","depth":1},{"value":"shrink_to_fit用法","url":"#shrink_to_fit用法","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++惯用法","datePublished":"2018-05-19T00:00:00.000Z","dateModified":"2018-05-19T00:00:00.000Z","description":"总结 C++ 相关内容：虚基类需 virtual 析构，std::auto_ptr 有风险用 unique_ptr 替代，重载 operator&()用 std::addressof，不支持重载函数模板及名称空间问题，基类派生类成员变量初始化顺序等，还提到一些其他用法及注意事项。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180519135047"}},{"title":"C++ windows实用函数","date":"2018-05-18T00:00:00.000Z","tags":["C/C++","Windows"],"draft":false,"summary":"收集 C++ Windows 实用函数，含头文件依赖，如获取系统内存等信息、字符串编码转换、目标是否存在等 17 个函数，涵盖内存、线程、时间、文件等方面操作，方便开发使用。 \r","type":"Blog","readingTime":{"text":"10 min read","minutes":9.72,"time":583200,"words":1944},"slug":"2018/20180518100809","path":"blog/2018/20180518100809","filePath":"blog/2018/20180518100809.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ windows实用函数","datePublished":"2018-05-18T00:00:00.000Z","dateModified":"2018-05-18T00:00:00.000Z","description":"收集 C++ Windows 实用函数，含头文件依赖，如获取系统内存等信息、字符串编码转换、目标是否存在等 17 个函数，涵盖内存、线程、时间、文件等方面操作，方便开发使用。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180518100809"}},{"title":"bug修复，for循环倒叙遍历的时候千万不要用size_t等无符号整型","date":"2018-05-10T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"2018 年 5 月 10 日的 C/C++相关文章指出，for 循环倒叙遍历勿用 size_t 等无符号整型，如上述代码，size_t 为无符号整型，i 为 0 时继续减会变为 UINT_MAX 导致越界崩溃，结论是逆序遍历用 int 别用 size_t。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.615,"time":36900,"words":123},"slug":"2018/20180510143841","path":"blog/2018/20180510143841","filePath":"blog/2018/20180510143841.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"bug修复，for循环倒叙遍历的时候千万不要用size_t等无符号整型","datePublished":"2018-05-10T00:00:00.000Z","dateModified":"2018-05-10T00:00:00.000Z","description":"2018 年 5 月 10 日的 C/C++相关文章指出，for 循环倒叙遍历勿用 size_t 等无符号整型，如上述代码，size_t 为无符号整型，i 为 0 时继续减会变为 UINT_MAX 导致越界崩溃，结论是逆序遍历用 int 别用 size_t。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180510143841"}},{"title":"C++ String正确实现以及关键点","date":"2018-05-09T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"本文介绍 C++ String 正确实现及关键点，包括构造函数等必要操作，列举要点如成员初始化列表顺序等，还给出简化代码及相关注意事项，如字符串需以'\\0'结尾、赋值操作符参数传值等。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.565,"time":213900,"words":713},"slug":"2018/20180509161721","path":"blog/2018/20180509161721","filePath":"blog/2018/20180509161721.mdx","toc":[{"value":"简化代码","url":"#简化代码","depth":1},{"value":"成员初始化列表","url":"#成员初始化列表","depth":1},{"value":"字符串以'\\0'结尾","url":"#字符串以0结尾","depth":1},{"value":"参数通过传值的方式实现赋值操作符","url":"#参数通过传值的方式实现赋值操作符","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ String正确实现以及关键点","datePublished":"2018-05-09T00:00:00.000Z","dateModified":"2018-05-09T00:00:00.000Z","description":"本文介绍 C++ String 正确实现及关键点，包括构造函数等必要操作，列举要点如成员初始化列表顺序等，还给出简化代码及相关注意事项，如字符串需以'\\0'结尾、赋值操作符参数传值等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180509161721"}},{"title":"我的云服务器开机自启动所有服务","date":"2018-04-10T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"本文介绍了如何设置云服务器在重启后自动启动所有服务，实现服务部署自动化。\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.34,"time":80400,"words":268},"slug":"2018/20180410112835","path":"blog/2018/20180410112835","filePath":"blog/2018/20180410112835.mdx","toc":[{"value":"mongodb启停脚本","url":"#mongodb启停脚本","depth":1},{"value":"自启动脚本","url":"#自启动脚本","depth":1},{"value":"写入rc.local","url":"#写入rclocal","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"我的云服务器开机自启动所有服务","datePublished":"2018-04-10T00:00:00.000Z","dateModified":"2018-04-10T00:00:00.000Z","description":"本文介绍了如何设置云服务器在重启后自动启动所有服务，实现服务部署自动化。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180410112835"}},{"title":"CentOs7 防火墙firewalld基本使用方法","date":"2018-03-28T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"CentOs7 防火墙 firewalld 基本使用：启动、查看状态、停止、禁用用 systemctl 操作；还可通过 firewalld-cmd 配置，如查看版本等，开启端口用 firewall-cmd 加参数，重新载入及查看状态等操作也可实现。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.49,"time":89400,"words":298},"slug":"2018/20180328013908","path":"blog/2018/20180328013908","filePath":"blog/2018/20180328013908.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"CentOs7 防火墙firewalld基本使用方法","datePublished":"2018-03-28T00:00:00.000Z","dateModified":"2018-03-28T00:00:00.000Z","description":"CentOs7 防火墙 firewalld 基本使用：启动、查看状态、停止、禁用用 systemctl 操作；还可通过 firewalld-cmd 配置，如查看版本等，开启端口用 firewall-cmd 加参数，重新载入及查看状态等操作也可实现。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180328013908"}},{"title":"bug修复，内存释放问题","date":"2018-03-19T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"遇到 C/C++ 和 Qt 中的内存释放问题，操作复杂时释放会崩溃。通过保存待删指针，10 秒空闲时销毁解决。代码中定义 DelayDestory 类，提供实例获取及删除操作方法，通过定时器控制删除时机。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.615,"time":96900,"words":323},"slug":"2018/20180319095000","path":"blog/2018/20180319095000","filePath":"blog/2018/20180319095000.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"bug修复，内存释放问题","datePublished":"2018-03-19T00:00:00.000Z","dateModified":"2018-03-19T00:00:00.000Z","description":"遇到 C/C++ 和 Qt 中的内存释放问题，操作复杂时释放会崩溃。通过保存待删指针，10 秒空闲时销毁解决。代码中定义 DelayDestory 类，提供实例获取及删除操作方法，通过定时器控制删除时机。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180319095000"}},{"title":"bug修复，解决延迟搜索的问题","date":"2018-03-19T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"文章主要讲 C/C++ 和 Qt 中解决输入框搜索延迟问题。通过设置 200 毫秒输入间隔时间，利用 Timer 控制搜索，先停止再重新开始计时，还优化了 Timer 触发逻辑，避免用户快速输入时带来问题。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.885,"time":113100,"words":377},"slug":"2018/20180319100933","path":"blog/2018/20180319100933","filePath":"blog/2018/20180319100933.mdx","toc":[{"value":"解决方法","url":"#解决方法","depth":1},{"value":"优化","url":"#优化","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"bug修复，解决延迟搜索的问题","datePublished":"2018-03-19T00:00:00.000Z","dateModified":"2018-03-19T00:00:00.000Z","description":"文章主要讲 C/C++ 和 Qt 中解决输入框搜索延迟问题。通过设置 200 毫秒输入间隔时间，利用 Timer 控制搜索，先停止再重新开始计时，还优化了 Timer 触发逻辑，避免用户快速输入时带来问题。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180319100933"}},{"title":"Qt自定义Tooltip","date":"2018-03-09T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"文章介绍 Qt 自定义 Tooltip，从 QDialog 继承，设置无边框属性，鼠标点击其他处自动关闭及自动析构等操作。给出 tooltip.h 和 tooltip.cpp 源码，用法为 Tooltip::popup(QCursor::pos(), \"hello\")。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.345,"time":80700,"words":269},"slug":"2018/20180309075802","path":"blog/2018/20180309075802","filePath":"blog/2018/20180309075802.mdx","toc":[{"value":"从QDialog继承","url":"#从qdialog继承","depth":1},{"value":"设置无边框属性","url":"#设置无边框属性","depth":1},{"value":"在鼠标点击其他地方的时候自动关闭","url":"#在鼠标点击其他地方的时候自动关闭","depth":1},{"value":"自动析构","url":"#自动析构","depth":1},{"value":"源码","url":"#源码","depth":1},{"value":"用法","url":"#用法","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt自定义Tooltip","datePublished":"2018-03-09T00:00:00.000Z","dateModified":"2018-03-09T00:00:00.000Z","description":"文章介绍 Qt 自定义 Tooltip，从 QDialog 继承，设置无边框属性，鼠标点击其他处自动关闭及自动析构等操作。给出 tooltip.h 和 tooltip.cpp 源码，用法为 Tooltip::popup(QCursor::pos(), \"hello\")。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180309075802"}},{"title":"react native中使用protobufjs","date":"2018-02-25T00:00:00.000Z","tags":["React","Javascript"],"draft":false,"summary":"文章介绍 react native 中使用 protobufjs，需将 proto 文件转换为 json 载入，注意 lookupTypeOrEnum 查找 message 时 proto 中 enum 枚举类型会失败，还提到在不同系统降级 protobuf.js 版本的情况及相关代码片段。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.89,"time":173400,"words":578},"slug":"2018/20180225135521","path":"blog/2018/20180225135521","filePath":"blog/2018/20180225135521.mdx","toc":[{"value":"载入proto文件","url":"#载入proto文件","depth":1},{"value":"lookupTypeOrEnum","url":"#lookuptypeorenum","depth":1},{"value":"代码片段","url":"#代码片段","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"react native中使用protobufjs","datePublished":"2018-02-25T00:00:00.000Z","dateModified":"2018-02-25T00:00:00.000Z","description":"文章介绍 react native 中使用 protobufjs，需将 proto 文件转换为 json 载入，注意 lookupTypeOrEnum 查找 message 时 proto 中 enum 枚举类型会失败，还提到在不同系统降级 protobuf.js 版本的情况及相关代码片段。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180225135521"}},{"title":"One of the sources for assign has an enumerable key on the prototype chain","date":"2018-02-25T00:00:00.000Z","tags":["React"],"draft":false,"summary":"在 react native 中拷贝对象遇“One of the sources for assign has an enumerable key on the prototype chain”错误。for 循环给 obj 赋值放入数组，使用 _.clone 后正常，之前用 {...obj} 或 Object.assign({}, obj) 会报错，改用 lodash 的 clone 就没问题。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.71,"time":42600,"words":142},"slug":"2018/20180225140856","path":"blog/2018/20180225140856","filePath":"blog/2018/20180225140856.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"One of the sources for assign has an enumerable key on the prototype chain","datePublished":"2018-02-25T00:00:00.000Z","dateModified":"2018-02-25T00:00:00.000Z","description":"在 react native 中拷贝对象遇“One of the sources for assign has an enumerable key on the prototype chain”错误。for 循环给 obj 赋值放入数组，使用 _.clone 后正常，之前用 {...obj} 或 Object.assign({}, obj) 会报错，改用 lodash 的 clone 就没问题。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180225140856"}},{"title":"10 种最常见的 Javascript 错误","date":"2018-02-16T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"文章介绍了 10 种最常见的 Javascript 错误，包括 Uncaught TypeError 等，分别阐述其产生原因及解决办法，如在初始化状态、处理 DOM 元素等场景中易出现错误，还提到不同浏览器错误提示不同及相关解决方法，最后强调 Rollbar 的重要性。 \r","type":"Blog","readingTime":{"text":"17 min read","minutes":16.73,"time":1003800,"words":3346},"slug":"2018/20180216122310","path":"blog/2018/20180216122310","filePath":"blog/2018/20180216122310.mdx","toc":[{"value":"1. Uncaught TypeError: Cannot read property","url":"#1-uncaught-typeerror-cannot-read-property","depth":1},{"value":"2. TypeError: ‘undefined’ is not an object","url":"#2-typeerror-undefined-is-not-an-object","depth":1},{"value":"3. TypeError: null is not an object","url":"#3-typeerror-null-is-not-an-object","depth":1},{"value":"4. (unknown): Script error","url":"#4-unknown-script-error","depth":1},{"value":"5. TypeError: Object doesn’t support property","url":"#5-typeerror-object-doesnt-support-property","depth":1},{"value":"6. TypeError: ‘undefined’ is not a function","url":"#6-typeerror-undefined-is-not-a-function","depth":1},{"value":"7. Uncaught RangeError: Maximum call stack","url":"#7-uncaught-rangeerror-maximum-call-stack","depth":1},{"value":"8. TypeError: Cannot read property ‘length’","url":"#8-typeerror-cannot-read-property-length","depth":1},{"value":"9. Uncaught TypeError: Cannot set property","url":"#9-uncaught-typeerror-cannot-set-property","depth":1},{"value":"10. ReferenceError: event is not defined","url":"#10-referenceerror-event-is-not-defined","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"10 种最常见的 Javascript 错误","datePublished":"2018-02-16T00:00:00.000Z","dateModified":"2018-02-16T00:00:00.000Z","description":"文章介绍了 10 种最常见的 Javascript 错误，包括 Uncaught TypeError 等，分别阐述其产生原因及解决办法，如在初始化状态、处理 DOM 元素等场景中易出现错误，还提到不同浏览器错误提示不同及相关解决方法，最后强调 Rollbar 的重要性。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180216122310"}},{"title":"nginx url跳转保留路径","date":"2018-02-16T00:00:00.000Z","tags":["Product","Tools"],"draft":false,"summary":"文章介绍了将老域名 http://3inns.cn 映射到新域名 http://ningto.com 且保留路径的方法。在 nginx 中通过配置 `server` 段的 `rewrite` 规则实现，最后重启 nginx 使配置生效。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.535,"time":32100,"words":107},"slug":"2018/20180216235531","path":"blog/2018/20180216235531","filePath":"blog/2018/20180216235531.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"nginx url跳转保留路径","datePublished":"2018-02-16T00:00:00.000Z","dateModified":"2018-02-16T00:00:00.000Z","description":"文章介绍了将老域名 http://3inns.cn 映射到新域名 http://ningto.com 且保留路径的方法。在 nginx 中通过配置 `server` 段的 `rewrite` 规则实现，最后重启 nginx 使配置生效。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180216235531"}},{"title":"腾讯云服务器CVM上部署nodejs服务","date":"2018-01-14T00:00:00.000Z","tags":["Node.js","Web"],"draft":false,"summary":"介绍了如何在腾讯云服务器CVM上部署Node.js服务，包括环境配置和部署步骤。\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.87,"time":172200,"words":574},"slug":"2018/20180114034028","path":"blog/2018/20180114034028","filePath":"blog/2018/20180114034028.mdx","toc":[{"value":"登录服务器","url":"#登录服务器","depth":1},{"value":"安装nodejs","url":"#安装nodejs","depth":1},{"value":"升级nodejs","url":"#升级nodejs","depth":1},{"value":"安装git","url":"#安装git","depth":1},{"value":"运行nodejs服务","url":"#运行nodejs服务","depth":1},{"value":"测试","url":"#测试","depth":1},{"value":"用精美大图展示您的项目成果","url":"#用精美大图展示您的项目成果","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"腾讯云服务器CVM上部署nodejs服务","datePublished":"2018-01-14T00:00:00.000Z","dateModified":"2018-01-14T00:00:00.000Z","description":"介绍了如何在腾讯云服务器CVM上部署Node.js服务，包括环境配置和部署步骤。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180114034028"}},{"title":"QTableView多选","date":"2018-01-09T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"介绍了 QTableView 多选，需了解 setSelectionBehavior 和 setSelectionMode 接口。初始化后用特定代码达不到要求，需使用 select 接口的新用法，封装了 selectMulRows 方法实现多选。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.395,"time":83700,"words":279},"slug":"2018/20180109052544","path":"blog/2018/20180109052544","filePath":"blog/2018/20180109052544.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QTableView多选","datePublished":"2018-01-09T00:00:00.000Z","dateModified":"2018-01-09T00:00:00.000Z","description":"介绍了 QTableView 多选，需了解 setSelectionBehavior 和 setSelectionMode 接口。初始化后用特定代码达不到要求，需使用 select 接口的新用法，封装了 selectMulRows 方法实现多选。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180109052544"}},{"title":"ES6 class介绍","date":"2018-01-06T00:00:00.000Z","tags":["Javascript"],"draft":false,"summary":"ES6 类主要提供方便语法创建老式构造函数，有类申明、类表达式等定义方式。类主体可定义成员，含严格模式、构造函数、原型方法、静态方法、getter 和 setter 方法等。还可继承，子类构造函数需调用 super，继承原型链有特定图表展示。  \r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.415,"time":324900,"words":1083},"slug":"2018/20180106121608","path":"blog/2018/20180106121608","filePath":"blog/2018/20180106121608.mdx","toc":[{"value":"定义类","url":"#定义类","depth":1},{"value":"类申明","url":"#类申明","depth":2},{"value":"类表达式","url":"#类表达式","depth":2},{"value":"类的主体和方法定义","url":"#类的主体和方法定义","depth":1},{"value":"严格模式","url":"#严格模式","depth":2},{"value":"构造函数","url":"#构造函数","depth":2},{"value":"原型方法","url":"#原型方法","depth":2},{"value":"静态方法","url":"#静态方法","depth":2},{"value":"getter and setter方法","url":"#getter-and-setter方法","depth":2},{"value":"构造函数，静态方法，原型方法","url":"#构造函数静态方法原型方法","depth":2},{"value":"继承","url":"#继承","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ES6 class介绍","datePublished":"2018-01-06T00:00:00.000Z","dateModified":"2018-01-06T00:00:00.000Z","description":"ES6 类主要提供方便语法创建老式构造函数，有类申明、类表达式等定义方式。类主体可定义成员，含严格模式、构造函数、原型方法、静态方法、getter 和 setter 方法等。还可继承，子类构造函数需调用 super，继承原型链有特定图表展示。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180106121608"}},{"title":"Qt回调到UI线程","date":"2018-01-05T00:00:00.000Z","tags":["C/C++","Qt","Windows"],"draft":false,"summary":"桌面客户端主线程即 UI 线程，异步获取数据常在子线程，不能直接操作 UI。介绍两种将子线程数据抛到 UI 层处理的方法：一是调用和接收在一起，通过信号槽机制；二是调用和接收分开，用 signalDispatch 类以信号方式 emit 结果，可实现多个 UI 窗口数据同步。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.775,"time":166500,"words":555},"slug":"2018/20180105014315","path":"blog/2018/20180105014315","filePath":"blog/2018/20180105014315.mdx","toc":[{"value":"调用和接收在一起","url":"#调用和接收在一起","depth":1},{"value":"调用和接收分开","url":"#调用和接收分开","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt回调到UI线程","datePublished":"2018-01-05T00:00:00.000Z","dateModified":"2018-01-05T00:00:00.000Z","description":"桌面客户端主线程即 UI 线程，异步获取数据常在子线程，不能直接操作 UI。介绍两种将子线程数据抛到 UI 层处理的方法：一是调用和接收在一起，通过信号槽机制；二是调用和接收分开，用 signalDispatch 类以信号方式 emit 结果，可实现多个 UI 窗口数据同步。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180105014315"}},{"title":"谷歌是如何做代码审查的（转）","date":"2018-01-01T00:00:00.000Z","tags":["Product"],"draft":false,"summary":"Google 重视代码审查，无程序可提交至代码库，所有人都要经过。其最大功用是社会性，让编程态度改变，传播知识。但需注意避免常见错误，如按自己编程习惯评判、为说而说、速度不当等，以确保代码审查有效。 \r","type":"Blog","readingTime":{"text":"9 min read","minutes":8.95,"time":537000,"words":1790},"slug":"2018/20180101020657","path":"blog/2018/20180101020657","filePath":"blog/2018/20180101020657.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"谷歌是如何做代码审查的（转）","datePublished":"2018-01-01T00:00:00.000Z","dateModified":"2018-01-01T00:00:00.000Z","description":"Google 重视代码审查，无程序可提交至代码库，所有人都要经过。其最大功用是社会性，让编程态度改变，传播知识。但需注意避免常见错误，如按自己编程习惯评判、为说而说、速度不当等，以确保代码审查有效。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2018/20180101020657"}},{"title":"node.js中exports与module.exports区别","date":"2017-12-10T00:00:00.000Z","tags":["Javascript"],"draft":false,"summary":"文章介绍 node.js 中 exports 与 module.exports 的区别。两种导出方式不同，给 exports 增加成员时两者一样，将对象赋值给 exports 时只有 module.exports 正确。原理是主调函数传参包装，exports 对 module.exports 是引用，混着用易出错，一般导出对象用 module.exports，其他用 exports。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.285,"time":137100,"words":457},"slug":"2017/20171210125823","path":"blog/2017/20171210125823","filePath":"blog/2017/20171210125823.mdx","toc":[{"value":"使用方法","url":"#使用方法","depth":1},{"value":"给exports增加成员","url":"#给exports增加成员","depth":2},{"value":"将对象赋值给exports","url":"#将对象赋值给exports","depth":2},{"value":"导出原理","url":"#导出原理","depth":1},{"value":"结论","url":"#结论","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"node.js中exports与module.exports区别","datePublished":"2017-12-10T00:00:00.000Z","dateModified":"2017-12-10T00:00:00.000Z","description":"文章介绍 node.js 中 exports 与 module.exports 的区别。两种导出方式不同，给 exports 增加成员时两者一样，将对象赋值给 exports 时只有 module.exports 正确。原理是主调函数传参包装，exports 对 module.exports 是引用，混着用易出错，一般导出对象用 module.exports，其他用 exports。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125823"}},{"title":"mongodb replica set部署与测试","date":"2017-12-03T00:00:00.000Z","tags":["Database","MongoDB"],"draft":false,"summary":"在 windows 一台机器上部署 3 个端口不同的副本集，先创建并初始化，再新增成员。通过 nodejs 测试，关闭主服务后写入数据会失败十几秒后自动补上，至少两个成员存活才能完成自动切换到 primary，副本集个数需满足“大多数”概念，奇数个至少 3 个，偶数个需部署仲裁者。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.155,"time":249300,"words":831},"slug":"2017/20171203061242","path":"blog/2017/20171203061242","filePath":"blog/2017/20171203061242.mdx","toc":[{"value":"环境","url":"#环境","depth":1},{"value":"创建副本集","url":"#创建副本集","depth":1},{"value":"初始化副本集","url":"#初始化副本集","depth":1},{"value":"新增副本集","url":"#新增副本集","depth":1},{"value":"nodejs测试","url":"#nodejs测试","depth":1},{"value":"副本集个数","url":"#副本集个数","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"mongodb replica set部署与测试","datePublished":"2017-12-03T00:00:00.000Z","dateModified":"2017-12-03T00:00:00.000Z","description":"在 windows 一台机器上部署 3 个端口不同的副本集，先创建并初始化，再新增成员。通过 nodejs 测试，关闭主服务后写入数据会失败十几秒后自动补上，至少两个成员存活才能完成自动切换到 primary，副本集个数需满足“大多数”概念，奇数个至少 3 个，偶数个需部署仲裁者。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171203061242"}},{"title":"写代码怎能不会这些Linux命令？","date":"2017-11-29T00:00:00.000Z","tags":["Linux","Tips"],"draft":false,"summary":"这篇文章介绍 50 个常用 Linux 命令，如 tar、grep、find 等，每个命令都有简单示例说明用法，对学习 Unix/Linux 很重要，涵盖文件操作、进程管理等方面，对 Linux 初学者很有帮助。 \r","type":"Blog","readingTime":{"text":"20 min read","minutes":19.89,"time":1193400,"words":3978},"slug":"2017/20171129134350","path":"blog/2017/20171129134350","filePath":"blog/2017/20171129134350.mdx","toc":[{"value":"1. tar","url":"#1-tar","depth":1},{"value":"2. grep","url":"#2-grep","depth":1},{"value":"3. find","url":"#3-find","depth":1},{"value":"4. ssh","url":"#4-ssh","depth":1},{"value":"5. sed","url":"#5-sed","depth":1},{"value":"6. awk","url":"#6-awk","depth":1},{"value":"7. vim","url":"#7-vim","depth":1},{"value":"8. diff","url":"#8-diff","depth":1},{"value":"9. sort","url":"#9-sort","depth":1},{"value":"10. export","url":"#10-export","depth":1},{"value":"11. xargs","url":"#11-xargs","depth":1},{"value":"12. ls","url":"#12-ls","depth":1},{"value":"13. pwd","url":"#13-pwd","depth":1},{"value":"14. cd","url":"#14-cd","depth":1},{"value":"15. gzip","url":"#15-gzip","depth":1},{"value":"16. bzip2","url":"#16-bzip2","depth":1},{"value":"17. uzip","url":"#17-uzip","depth":1},{"value":"18. shutdown","url":"#18-shutdown","depth":1},{"value":"19. ftp","url":"#19-ftp","depth":1},{"value":"20. crontab","url":"#20-crontab","depth":1},{"value":"21. service","url":"#21-service","depth":1},{"value":"22. ps","url":"#22-ps","depth":1},{"value":"23. free","url":"#23-free","depth":1},{"value":"24. top","url":"#24-top","depth":1},{"value":"25. df","url":"#25-df","depth":1},{"value":"26. kill","url":"#26-kill","depth":1},{"value":"27. rm","url":"#27-rm","depth":1},{"value":"28. cp","url":"#28-cp","depth":1},{"value":"29. mv","url":"#29-mv","depth":1},{"value":"30. cat","url":"#30-cat","depth":1},{"value":"31. mount","url":"#31-mount","depth":1},{"value":"32. chmod","url":"#32-chmod","depth":1},{"value":"33. chown","url":"#33-chown","depth":1},{"value":"34. passwd","url":"#34-passwd","depth":1},{"value":"35. mkdir","url":"#35-mkdir","depth":1},{"value":"36. ifconfig","url":"#36-ifconfig","depth":1},{"value":"37. uname","url":"#37-uname","depth":1},{"value":"38. whereis","url":"#38-whereis","depth":1},{"value":"39. whatis","url":"#39-whatis","depth":1},{"value":"40. locate","url":"#40-locate","depth":1},{"value":"41. man","url":"#41-man","depth":1},{"value":"42. tail","url":"#42-tail","depth":1},{"value":"43. less","url":"#43-less","depth":1},{"value":"44. su","url":"#44-su","depth":1},{"value":"45. mysql","url":"#45-mysql","depth":1},{"value":"46. yum","url":"#46-yum","depth":1},{"value":"47. rpm","url":"#47-rpm","depth":1},{"value":"48. ping","url":"#48-ping","depth":1},{"value":"49. date","url":"#49-date","depth":1},{"value":"50. wget","url":"#50-wget","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"写代码怎能不会这些Linux命令？","datePublished":"2017-11-29T00:00:00.000Z","dateModified":"2017-11-29T00:00:00.000Z","description":"这篇文章介绍 50 个常用 Linux 命令，如 tar、grep、find 等，每个命令都有简单示例说明用法，对学习 Unix/Linux 很重要，涵盖文件操作、进程管理等方面，对 Linux 初学者很有帮助。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171129134350"}},{"title":"antd按需加载","date":"2017-11-21T00:00:00.000Z","tags":["React"],"draft":false,"summary":"Ant Design 是提升体验的中后台设计语言，react 首页渲染慢，按需加载的方法。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.63,"time":37800,"words":126},"slug":"2017/20171121022737","path":"blog/2017/20171121022737","filePath":"blog/2017/20171121022737.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"antd按需加载","datePublished":"2017-11-21T00:00:00.000Z","dateModified":"2017-11-21T00:00:00.000Z","description":"Ant Design 是提升体验的中后台设计语言，react 首页渲染慢，按需加载的方法。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171121022737"}},{"title":"API设计原则(上)","date":"2017-11-17T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"介绍 Qt API 设计原则，包括一致、易掌握、强大等特质，如极简、完备等。强调静态多态和基于属性的 API，举例说明好、差及值得斟酌的案例，还提及属性间关联处理及特殊值或重置方法等，有原文链接及译文稿。 \r","type":"Blog","readingTime":{"text":"11 min read","minutes":10.78,"time":646800,"words":2156},"slug":"2017/20171117140712","path":"blog/2017/20171117140712","filePath":"blog/2017/20171117140712.mdx","toc":[{"value":"译序","url":"#译序","depth":1},{"value":"API设计原则","url":"#api设计原则","depth":1},{"value":"好API的6个特质","url":"#好api的6个特质","depth":2},{"value":"1. 极简","url":"#1-极简","depth":3},{"value":"2. 完备","url":"#2-完备","depth":3},{"value":"3. 语义清晰简单","url":"#3-语义清晰简单","depth":3},{"value":"4. 符合直觉","url":"#4-符合直觉","depth":3},{"value":"5. 易于记忆","url":"#5-易于记忆","depth":3},{"value":"6. 引导API使用者写出可读代码","url":"#6-引导api使用者写出可读代码","depth":3},{"value":"静态多态","url":"#静态多态","depth":2},{"value":"1. 好的案例","url":"#1-好的案例","depth":3},{"value":"2. 差的案例","url":"#2-差的案例","depth":3},{"value":"3. 值得斟酌的案例","url":"#3-值得斟酌的案例","depth":3},{"value":"基于属性的API","url":"#基于属性的api","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"API设计原则(上)","datePublished":"2017-11-17T00:00:00.000Z","dateModified":"2017-11-17T00:00:00.000Z","description":"介绍 Qt API 设计原则，包括一致、易掌握、强大等特质，如极简、完备等。强调静态多态和基于属性的 API，举例说明好、差及值得斟酌的案例，还提及属性间关联处理及特殊值或重置方法等，有原文链接及译文稿。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171117140712"}},{"title":"API设计原则(中)","date":"2017-11-17T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"总结：介绍 C++相关 API 设计原则，如值与对象（指针 vs 引用等）、虚函数（避免过度使用等）、关于 const（输入参数、返回值等方面），并提及 Qt 中的实践及相关注意事项，还对比不同情况下的选择。  \r","type":"Blog","readingTime":{"text":"22 min read","minutes":21.065,"time":1263900,"words":4213},"slug":"2017/20171117140822","path":"blog/2017/20171117140822","filePath":"blog/2017/20171117140822.mdx","toc":[{"value":"C++相关","url":"#c相关","depth":2},{"value":"值 vs. 对象","url":"#值-vs-对象","depth":3},{"value":"1. 指针 vs. 引用","url":"#1-指针-vs-引用","depth":4},{"value":"2. 按常量引用传参 vs. 按值传参","url":"#2-按常量引用传参-vs-按值传参","depth":4},{"value":"虚函数","url":"#虚函数","depth":3},{"value":"1. 避免虚函数","url":"#1-避免虚函数","depth":4},{"value":"2. 虚函数 vs. 拷贝","url":"#2-虚函数-vs-拷贝","depth":4},{"value":"关于const","url":"#关于const","depth":3},{"value":"1. 输入参数：const指针","url":"#1-输入参数const指针","depth":4},{"value":"2. 返回值：const值","url":"#2-返回值const值","depth":4},{"value":"3. 返回值：非const的指针还是有const的指针","url":"#3-返回值非const的指针还是有const的指针","depth":4},{"value":"4. 返回值：按值返回 还是 按const引用返回？","url":"#4-返回值按值返回-还是-按const引用返回","depth":4},{"value":"5. const vs. 对象的状态","url":"#5-const-vs-对象的状态","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"API设计原则(中)","datePublished":"2017-11-17T00:00:00.000Z","dateModified":"2017-11-17T00:00:00.000Z","description":"总结：介绍 C++相关 API 设计原则，如值与对象（指针 vs 引用等）、虚函数（避免过度使用等）、关于 const（输入参数、返回值等方面），并提及 Qt 中的实践及相关注意事项，还对比不同情况下的选择。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171117140822"}},{"title":"API设计原则(下)","date":"2017-11-17T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"总结：介绍 API 设计原则，包括语义文档、命名艺术、避免陷阱等方面，以 QProgressBar 等案例展示实际应用，强调抽象类等问题，还提及相关 Qt 类的改进，如去掉 QGLayoutIterator 等，原文链接为[API Design Principles – Qt Wiki](http://qt-project.org/wiki/API-Design-Principles)。 \r","type":"Blog","readingTime":{"text":"16 min read","minutes":15.555,"time":933300,"words":3111},"slug":"2017/20171117140849","path":"blog/2017/20171117140849","filePath":"blog/2017/20171117140849.mdx","toc":[{"value":"API的语义和文档","url":"#api的语义和文档","depth":1},{"value":"命名的艺术","url":"#命名的艺术","depth":1},{"value":"通用的命名规则","url":"#通用的命名规则","depth":2},{"value":"类的命名","url":"#类的命名","depth":2},{"value":"枚举类型及其值的命名","url":"#枚举类型及其值的命名","depth":2},{"value":"函数和参数的命名","url":"#函数和参数的命名","depth":2},{"value":"布尔类型的getter与setter方法的命名","url":"#布尔类型的getter与setter方法的命名","depth":2},{"value":"避免常见陷阱","url":"#避免常见陷阱","depth":1},{"value":"简化的陷阱","url":"#简化的陷阱","depth":2},{"value":"布尔参数的陷阱","url":"#布尔参数的陷阱","depth":2},{"value":"案例研究","url":"#案例研究","depth":1},{"value":"QProgressBar","url":"#qprogressbar","depth":2},{"value":"QAbstractPrintDialog & QAbstractPageSizeDialog","url":"#qabstractprintdialog--qabstractpagesizedialog","depth":2},{"value":"QAbstractItemModel","url":"#qabstractitemmodel","depth":2},{"value":"QLayoutIterator & QGLayoutIterator","url":"#qlayoutiterator--qglayoutiterator","depth":2},{"value":"QImageSink","url":"#qimagesink","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"API设计原则(下)","datePublished":"2017-11-17T00:00:00.000Z","dateModified":"2017-11-17T00:00:00.000Z","description":"总结：介绍 API 设计原则，包括语义文档、命名艺术、避免陷阱等方面，以 QProgressBar 等案例展示实际应用，强调抽象类等问题，还提及相关 Qt 类的改进，如去掉 QGLayoutIterator 等，原文链接为[API Design Principles – Qt Wiki](http://qt-project.org/wiki/API-Design-Principles)。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171117140849"}},{"title":"mongodb模糊匹配正则转义","date":"2017-11-04T00:00:00.000Z","tags":["Javascript","MongoDB"],"draft":false,"summary":"介绍 mongodb 模糊匹配正则转义，先通过特定代码搜索关键字，遇特殊字符如++搜索失败，需对关键字转义，mongdb 正则表达式中 keyword 特殊字符转义加单斜杠，给出完整代码示例。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.845,"time":50700,"words":169},"slug":"2017/20171104024203","path":"blog/2017/20171104024203","filePath":"blog/2017/20171104024203.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"mongodb模糊匹配正则转义","datePublished":"2017-11-04T00:00:00.000Z","dateModified":"2017-11-04T00:00:00.000Z","description":"介绍 mongodb 模糊匹配正则转义，先通过特定代码搜索关键字，遇特殊字符如++搜索失败，需对关键字转义，mongdb 正则表达式中 keyword 特殊字符转义加单斜杠，给出完整代码示例。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171104024203"}},{"title":"nodejs批量ping","date":"2017-11-03T00:00:00.000Z","tags":["Node.js"],"draft":false,"summary":"文章介绍 nodejs 批量 ping ，使用 net-ping 模块，通过读取 gui-config.json 中 ip 地址列表进行 ping 测试，需管理员权限运行 cmd 执行 node ping.js ，展示了测试结果。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.895,"time":113700,"words":379},"slug":"2017/20171103012302","path":"blog/2017/20171103012302","filePath":"blog/2017/20171103012302.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"nodejs批量ping","datePublished":"2017-11-03T00:00:00.000Z","dateModified":"2017-11-03T00:00:00.000Z","description":"文章介绍 nodejs 批量 ping ，使用 net-ping 模块，通过读取 gui-config.json 中 ip 地址列表进行 ping 测试，需管理员权限运行 cmd 执行 node ping.js ，展示了测试结果。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171103012302"}},{"title":"19个JavaScript常用的简写技术","date":"2017-11-03T00:00:00.000Z","tags":["Javascript"],"draft":false,"summary":"总结了 19 个 JavaScript 常用简写技术，包括三元操作符、短路求值等，涵盖变量声明、循环、函数等方面，如用三元操作符代替 if...else 语句等，使代码更简洁高效。  \r","type":"Blog","readingTime":{"text":"9 min read","minutes":8.61,"time":516600,"words":1722},"slug":"2017/20171103142445","path":"blog/2017/20171103142445","filePath":"blog/2017/20171103142445.mdx","toc":[{"value":"三元操作符","url":"#三元操作符","depth":1},{"value":"短路求值","url":"#短路求值","depth":1},{"value":"声明变量","url":"#声明变量","depth":1},{"value":"if存在条件","url":"#if存在条件","depth":1},{"value":"循环","url":"#循环","depth":1},{"value":"短路评价","url":"#短路评价","depth":1},{"value":"十进制指数","url":"#十进制指数","depth":1},{"value":"对象属性","url":"#对象属性","depth":1},{"value":"箭头函数","url":"#箭头函数","depth":1},{"value":"隐式返回值","url":"#隐式返回值","depth":1},{"value":"默认参数值","url":"#默认参数值","depth":1},{"value":"模板字符串","url":"#模板字符串","depth":1},{"value":"解构赋值","url":"#解构赋值","depth":1},{"value":"多行字符串","url":"#多行字符串","depth":1},{"value":"扩展运算符","url":"#扩展运算符","depth":1},{"value":"强制参数","url":"#强制参数","depth":1},{"value":"Array.find","url":"#arrayfind","depth":1},{"value":"Object[key]","url":"#objectkey","depth":1},{"value":"双重非位运算","url":"#双重非位运算","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"19个JavaScript常用的简写技术","datePublished":"2017-11-03T00:00:00.000Z","dateModified":"2017-11-03T00:00:00.000Z","description":"总结了 19 个 JavaScript 常用简写技术，包括三元操作符、短路求值等，涵盖变量声明、循环、函数等方面，如用三元操作符代替 if...else 语句等，使代码更简洁高效。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171103142445"}},{"title":"koa2给所有页面渲染全局数据","date":"2017-11-02T00:00:00.000Z","tags":["Web","Node.js"],"draft":false,"summary":"文章介绍 koa2 给所有页面渲染全局数据的方法。通过在所有路由前新增代码捕捉每次请求并写入 mongodb 新增访问量及返回总访问量，前端可在模板中获取该变量实现显示用户访问量。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.15,"time":69000,"words":230},"slug":"2017/20171102122829","path":"blog/2017/20171102122829","filePath":"blog/2017/20171102122829.mdx","toc":[{"value":"场景","url":"#场景","depth":1},{"value":"捕捉每次请求","url":"#捕捉每次请求","depth":1},{"value":"每个请求中返回总访问量","url":"#每个请求中返回总访问量","depth":1},{"value":"前端实现","url":"#前端实现","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"koa2给所有页面渲染全局数据","datePublished":"2017-11-02T00:00:00.000Z","dateModified":"2017-11-02T00:00:00.000Z","description":"文章介绍 koa2 给所有页面渲染全局数据的方法。通过在所有路由前新增代码捕捉每次请求并写入 mongodb 新增访问量及返回总访问量，前端可在模板中获取该变量实现显示用户访问量。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171102122829"}},{"title":"常用CRT字符串函数源码","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"这是常用 CRT 字符串函数的源码，包含 memcpy、memset、strcat 等 14 个函数，分别实现了内存复制、内存设置、字符串连接等功能，代码简洁且实用。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.135,"time":188100,"words":627},"slug":"2017/20171024120211","path":"blog/2017/20171024120211","filePath":"blog/2017/20171024120211.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"常用CRT字符串函数源码","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"这是常用 CRT 字符串函数的源码，包含 memcpy、memset、strcat 等 14 个函数，分别实现了内存复制、内存设置、字符串连接等功能，代码简洁且实用。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024120211"}},{"title":"如何为包含指向（抽象）基类的指针的类定义拷贝构造函数或复制操作符","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"总结：文章通过示例代码展示如何为含指向（抽象）基类指针的类定义拷贝构造函数或复制操作符，如 Fred 类利用 Shape 类的 clone 函数进行相关操作，代码清晰易懂。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.08,"time":64800,"words":216},"slug":"2017/20171024120406","path":"blog/2017/20171024120406","filePath":"blog/2017/20171024120406.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何为包含指向（抽象）基类的指针的类定义拷贝构造函数或复制操作符","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"总结：文章通过示例代码展示如何为含指向（抽象）基类指针的类定义拷贝构造函数或复制操作符，如 Fred 类利用 Shape 类的 clone 函数进行相关操作，代码清晰易懂。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024120406"}},{"title":"C++大数相乘","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"这是 C++实现的大数相乘代码。通过两个循环计算乘积，再处理进位和输出。还给出了 C++的字符串实现版本，同样通过循环和进位处理得到结果，去除前导 0 后输出。  \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.155,"time":69300,"words":231},"slug":"2017/20171024120642","path":"blog/2017/20171024120642","filePath":"blog/2017/20171024120642.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++大数相乘","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"这是 C++实现的大数相乘代码。通过两个循环计算乘积，再处理进位和输出。还给出了 C++的字符串实现版本，同样通过循环和进位处理得到结果，去除前导 0 后输出。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024120642"}},{"title":"KMP算法","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"KMP 算法是改进字符串匹配算法，利用匹配失败信息快速匹配，通过实现 next()函数包含模式串局部匹配信息。文中还给出求子串 nextval[]数组的步骤及代码，如 GetNextValue 和 KmpSearch 函数，最后展示了在特定字符串中的搜索示例。 \r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.335,"time":320100,"words":1067},"slug":"2017/20171024120712","path":"blog/2017/20171024120712","filePath":"blog/2017/20171024120712.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"KMP算法","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"KMP 算法是改进字符串匹配算法，利用匹配失败信息快速匹配，通过实现 next()函数包含模式串局部匹配信息。文中还给出求子串 nextval[]数组的步骤及代码，如 GetNextValue 和 KmpSearch 函数，最后展示了在特定字符串中的搜索示例。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024120712"}},{"title":"将一个长度为n的字符串向左循环移动m位","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"文章介绍将长度为 n 的字符串向左循环移动 m 位的方法，通过先切分字符串为两部分并分别逆序，最后对整个字符串逆序实现。给出 C++代码示例，包含相关函数定义及主函数测试。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.055,"time":63300,"words":211},"slug":"2017/20171024120806","path":"blog/2017/20171024120806","filePath":"blog/2017/20171024120806.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"将一个长度为n的字符串向左循环移动m位","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"文章介绍将长度为 n 的字符串向左循环移动 m 位的方法，通过先切分字符串为两部分并分别逆序，最后对整个字符串逆序实现。给出 C++代码示例，包含相关函数定义及主函数测试。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024120806"}},{"title":"将字符串中的单词进行倒序","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"文章介绍将字符串中单词倒序的方法，先整体倒序，再逐个单词倒序。通过`ReverseString`函数实现字符串倒序，`ReverseAllWord`函数先整体倒序后逐个单词倒序。代码示例在`_tmain`函数中进行了测试。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.07,"time":64200,"words":214},"slug":"2017/20171024120834","path":"blog/2017/20171024120834","filePath":"blog/2017/20171024120834.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"将字符串中的单词进行倒序","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"文章介绍将字符串中单词倒序的方法，先整体倒序，再逐个单词倒序。通过`ReverseString`函数实现字符串倒序，`ReverseAllWord`函数先整体倒序后逐个单词倒序。代码示例在`_tmain`函数中进行了测试。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024120834"}},{"title":"字符编解码的故事（ASCII，ANSI，Unicode，Utf-8）","date":"2017-10-24T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"字符编解码故事：起初 ASCII 用于美国，后世界各国使用计算机，中国制定 GB2312 等编码，各国有不同编码致交流困难。ISO 推出 UNICODE 用两字节统一表示所有字符，后有多种 UTF 标准。记事本中 GB2312 编码与 UTF8 编码易产生冲撞，还有多种编码形式及转换函数，如 MultiByteToWideChar 和 WideCharToMultiByte。 \r","type":"Blog","readingTime":{"text":"21 min read","minutes":20.185,"time":1211100,"words":4037},"slug":"2017/20171024125452","path":"blog/2017/20171024125452","filePath":"blog/2017/20171024125452.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"字符编解码的故事（ASCII，ANSI，Unicode，Utf-8）","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"字符编解码故事：起初 ASCII 用于美国，后世界各国使用计算机，中国制定 GB2312 等编码，各国有不同编码致交流困难。ISO 推出 UNICODE 用两字节统一表示所有字符，后有多种 UTF 标准。记事本中 GB2312 编码与 UTF8 编码易产生冲撞，还有多种编码形式及转换函数，如 MultiByteToWideChar 和 WideCharToMultiByte。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024125452"}},{"title":"C++多态的实现原理","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍 C++多态实现原理，用 virtual 申明虚函数，类有虚表和对象虚指针，多态分类和函数多态，虚函数结合动态绑定实现多态，虚表在构造函数中创建初始化，总结类有虚表等内容，还对比了早期绑定和迟绑定，及类和函数多态性差异。 \r","type":"Blog","readingTime":{"text":"16 min read","minutes":15.225,"time":913500,"words":3045},"slug":"2017/20171024130134","path":"blog/2017/20171024130134","filePath":"blog/2017/20171024130134.mdx","toc":[{"value":"编译的角度","url":"#编译的角度","depth":1},{"value":"内存模型的角度","url":"#内存模型的角度","depth":1},{"value":"总结（基类有虚函数）","url":"#总结基类有虚函数","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++多态的实现原理","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"介绍 C++多态实现原理，用 virtual 申明虚函数，类有虚表和对象虚指针，多态分类和函数多态，虚函数结合动态绑定实现多态，虚表在构造函数中创建初始化，总结类有虚表等内容，还对比了早期绑定和迟绑定，及类和函数多态性差异。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024130134"}},{"title":"linux笔记","date":"2017-10-24T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"总结：涵盖 Linux 诸多操作，如编译加 -g 参数用 gdb 查段错误位置、各种输入法安装与配置、常用快捷键（emacs）、文件操作、系统命令（top、df 等）、进程管理（kill 等）、SSH 开启与配置、解决乱码、svn 操作、deb 包安装及查看程序对库的依赖等内容。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.81,"time":288600,"words":962},"slug":"2017/20171024130821","path":"blog/2017/20171024130821","filePath":"blog/2017/20171024130821.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"linux笔记","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"总结：涵盖 Linux 诸多操作，如编译加 -g 参数用 gdb 查段错误位置、各种输入法安装与配置、常用快捷键（emacs）、文件操作、系统命令（top、df 等）、进程管理（kill 等）、SSH 开启与配置、解决乱码、svn 操作、deb 包安装及查看程序对库的依赖等内容。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024130821"}},{"title":"封包和拆包","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"文章主要讨论基于 TCP 开发通讯程序的封包和拆包问题。TCP 是“流”协议易出现“粘包”，需在发送端封包、接收端拆包。介绍了多种封包拆包方式，如动态缓冲区暂存、利用底层缓冲区等，并给出相关代码示例。UDP 不存在拆包问题。 \r","type":"Blog","readingTime":{"text":"14 min read","minutes":13.8,"time":828000,"words":2760},"slug":"2017/20171024131723","path":"blog/2017/20171024131723","filePath":"blog/2017/20171024131723.mdx","toc":[{"value":"为什么基于TCP的通讯程序需要进行封包和拆包.","url":"#为什么基于tcp的通讯程序需要进行封包和拆包","depth":1},{"value":"为什么会出现B.C.D的情况.","url":"#为什么会出现bcd的情况","depth":1},{"value":"怎样封包和拆包.","url":"#怎样封包和拆包","depth":1},{"value":"封包","url":"#封包","depth":2},{"value":"拆包","url":"#拆包","depth":2},{"value":"利用底层的缓冲区来进行拆包","url":"#利用底层的缓冲区来进行拆包","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"封包和拆包","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"文章主要讨论基于 TCP 开发通讯程序的封包和拆包问题。TCP 是“流”协议易出现“粘包”，需在发送端封包、接收端拆包。介绍了多种封包拆包方式，如动态缓冲区暂存、利用底层缓冲区等，并给出相关代码示例。UDP 不存在拆包问题。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024131723"}},{"title":"STL transform用法","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍了 STL 中 transform 的用法，通过不同函数指针实现对容器元素的操作，如对向量元素加 1、两向量元素相加等，还可用于字符串大小写转换，代码示例清晰展示其功能。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.295,"time":137700,"words":459},"slug":"2017/20171024132238","path":"blog/2017/20171024132238","filePath":"blog/2017/20171024132238.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"STL transform用法","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"介绍了 STL 中 transform 的用法，通过不同函数指针实现对容器元素的操作，如对向量元素加 1、两向量元素相加等，还可用于字符串大小写转换，代码示例清晰展示其功能。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024132238"}},{"title":"C语言日历","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"这是 C 语言日历程序，输入年月显示当前日历，按左右方向键可显示上月或下月日历，按其他键两次退出。通过函数判断闰年及计算星期数，循环输出日历，可根据输入动态调整。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.665,"time":99900,"words":333},"slug":"2017/20171024132530","path":"blog/2017/20171024132530","filePath":"blog/2017/20171024132530.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C语言日历","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"这是 C 语言日历程序，输入年月显示当前日历，按左右方向键可显示上月或下月日历，按其他键两次退出。通过函数判断闰年及计算星期数，循环输出日历，可根据输入动态调整。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024132530"}},{"title":"我的emacs 23配置","date":"2017-10-24T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"介绍了 emacs 23 配置，包括设置插件路径、显示行号和时间、提示位置、支持粘贴、选择颜色主题、设置括号配对等功能，还定义了多个快捷键及 C/C++相关设置。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.145,"time":188700,"words":629},"slug":"2017/20171024133020","path":"blog/2017/20171024133020","filePath":"blog/2017/20171024133020.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"我的emacs 23配置","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"介绍了 emacs 23 配置，包括设置插件路径、显示行号和时间、提示位置、支持粘贴、选择颜色主题、设置括号配对等功能，还定义了多个快捷键及 C/C++相关设置。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024133020"}},{"title":"C++读写XML文件（Libxml2库）","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍 C++读写 XML 文件的 Libxml2 库，给出相关代码示例。包括打开文件、解析文件、写入文件及查找节点等操作，代码有读写 XML 文件的具体实现及测试案例，示例文件内容也一并给出。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.73,"time":283800,"words":946},"slug":"2017/20171024133211","path":"blog/2017/20171024133211","filePath":"blog/2017/20171024133211.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++读写XML文件（Libxml2库）","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"介绍 C++读写 XML 文件的 Libxml2 库，给出相关代码示例。包括打开文件、解析文件、写入文件及查找节点等操作，代码有读写 XML 文件的具体实现及测试案例，示例文件内容也一并给出。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024133211"}},{"title":"头文件宏定义","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"文章介绍了 C/C++ 头文件宏定义，包括各种条件判断、数组元素计数、断言等宏的定义，如`G_BEGIN_DECLS`等，还定义了相关的辅助函数如`_Assert`等。  \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.25,"time":75000,"words":250},"slug":"2017/20171024133408","path":"blog/2017/20171024133408","filePath":"blog/2017/20171024133408.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"头文件宏定义","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"文章介绍了 C/C++ 头文件宏定义，包括各种条件判断、数组元素计数、断言等宏的定义，如`G_BEGIN_DECLS`等，还定义了相关的辅助函数如`_Assert`等。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024133408"}},{"title":"STL 什么时候用哪种容器","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"本文提供了C++标准库容器的选择指南，帮助开发者根据实际需求选择合适的数据结构。\r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.615,"time":156900,"words":523},"slug":"2017/20171024133557","path":"blog/2017/20171024133557","filePath":"blog/2017/20171024133557.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"STL 什么时候用哪种容器","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"本文提供了C++标准库容器的选择指南，帮助开发者根据实际需求选择合适的数据结构。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024133557"}},{"title":"sigsetjmp用法","date":"2017-10-24T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.76,"time":105600,"words":352},"slug":"2017/20171024133748","path":"blog/2017/20171024133748","filePath":"blog/2017/20171024133748.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"sigsetjmp用法","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024133748"}},{"title":"模拟glib中双链表的部分实现","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"实现了模拟 glib 中双链表的部分功能。包含头文件`GList.h`定义双链表结构及相关函数声明，`GList.c`实现各函数，如`g_list_alloc`分配内存等，`main.c`进行测试，展示添加、遍历等操作及链表长度等信息。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.605,"time":216300,"words":721},"slug":"2017/20171024133919","path":"blog/2017/20171024133919","filePath":"blog/2017/20171024133919.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"模拟glib中双链表的部分实现","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"实现了模拟 glib 中双链表的部分功能。包含头文件`GList.h`定义双链表结构及相关函数声明，`GList.c`实现各函数，如`g_list_alloc`分配内存等，`main.c`进行测试，展示添加、遍历等操作及链表长度等信息。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024133919"}},{"title":"精灵程序(daemon)","date":"2017-10-24T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"精灵程序（daemon）生存期长，在系统引导装入时起动，关闭时终止。编程规则包括 fork、setsid、更改工作目录等，示例代码展示了初始化过程，查看其 ID 用 ps -ef ，退出用 kill ，源自《UNIX 环境高级编程》。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.51,"time":210600,"words":702},"slug":"2017/20171024134136","path":"blog/2017/20171024134136","filePath":"blog/2017/20171024134136.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"精灵程序(daemon)","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"精灵程序（daemon）生存期长，在系统引导装入时起动，关闭时终止。编程规则包括 fork、setsid、更改工作目录等，示例代码展示了初始化过程，查看其 ID 用 ps -ef ，退出用 kill ，源自《UNIX 环境高级编程》。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024134136"}},{"title":"当年的毕业设计 - MFC信息管理系统","date":"2017-10-24T00:00:00.000Z","tags":["C/C++","Windows"],"draft":false,"summary":"2017 年 10 月 24 日回顾当年 MFC 信息管理系统毕业设计，曾想弄 UDP 日志服务程序，用 MFC 做单文档应用。参照孙鑫教程学两月后做毕设，功能随意加，最后成学习试验品。现公布源码，数据库连不上部分已注释，VC6.0 可编译运行。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.035,"time":122100,"words":407},"slug":"2017/20171024134435","path":"blog/2017/20171024134435","filePath":"blog/2017/20171024134435.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"当年的毕业设计 - MFC信息管理系统","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"2017 年 10 月 24 日回顾当年 MFC 信息管理系统毕业设计，曾想弄 UDP 日志服务程序，用 MFC 做单文档应用。参照孙鑫教程学两月后做毕设，功能随意加，最后成学习试验品。现公布源码，数据库连不上部分已注释，VC6.0 可编译运行。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024134435"}},{"title":"makefile简单写法","date":"2017-10-24T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"介绍 makefile 简单写法，含四个文件及相关编译规则。可自动查找.h.cpp，有常用模板如使用 muduo 库等，包含编辑、清理等目标，清晰定义对象、源文件及编译选项。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.935,"time":56100,"words":187},"slug":"2017/20171024134524","path":"blog/2017/20171024134524","filePath":"blog/2017/20171024134524.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"makefile简单写法","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"介绍 makefile 简单写法，含四个文件及相关编译规则。可自动查找.h.cpp，有常用模板如使用 muduo 库等，包含编辑、清理等目标，清晰定义对象、源文件及编译选项。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024134524"}},{"title":"STL进阶","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"总结 STL 进阶内容：包含多种容器及操作，如打印容器元素、排序、查找等，还涉及迭代器、仿函数等，多种容器特性及适用场景不同，如 vector、deque、list 等，同时介绍了类似 shared_ptr 的智能指针等。 \r","type":"Blog","readingTime":{"text":"9 min read","minutes":8.855,"time":531300,"words":1771},"slug":"2017/20171024135145","path":"blog/2017/20171024135145","filePath":"blog/2017/20171024135145.mdx","toc":[{"value":"打印容器内的所有元素","url":"#打印容器内的所有元素","depth":1},{"value":"sort排序","url":"#sort排序","depth":1},{"value":"find、find_if","url":"#findfind_if","depth":1},{"value":"stack","url":"#stack","depth":1},{"value":"equal","url":"#equal","depth":1},{"value":"迭代器","url":"#迭代器","depth":1},{"value":"remove","url":"#remove","depth":1},{"value":"set","url":"#set","depth":1},{"value":"multimap","url":"#multimap","depth":1},{"value":"ostream_iterator自定义输出，在类型里面重载不行？","url":"#ostream_iterator自定义输出在类型里面重载不行","depth":1},{"value":"自定义泛型函数","url":"#自定义泛型函数","depth":1},{"value":"for_each","url":"#for_each","depth":1},{"value":"仿函数，行为类似如函数的对象","url":"#仿函数行为类似如函数的对象","depth":1},{"value":"容器元素的条件：必须能进行copy构造、assignment操作符、析构函数","url":"#容器元素的条件必须能进行copy构造assignment操作符析构函数","depth":1},{"value":"vector 动态数组","url":"#vector-动态数组","depth":1},{"value":"deque 双端队列","url":"#deque-双端队列","depth":1},{"value":"list 双向链表","url":"#list-双向链表","depth":1},{"value":"set和multiset，通常有平衡二叉树完成","url":"#set和multiset通常有平衡二叉树完成","depth":1},{"value":"map和multimap，通常以平衡二叉树完成，将key/value pair（键值对）当做元素","url":"#map和multimap通常以平衡二叉树完成将keyvalue-pair键值对当做元素","depth":1},{"value":"类似如shared_ptr智能指针","url":"#类似如shared_ptr智能指针","depth":1},{"value":"std::map查找的时候不区分大小写","url":"#stdmap查找的时候不区分大小写","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"STL进阶","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"总结 STL 进阶内容：包含多种容器及操作，如打印容器元素、排序、查找等，还涉及迭代器、仿函数等，多种容器特性及适用场景不同，如 vector、deque、list 等，同时介绍了类似 shared_ptr 的智能指针等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024135145"}},{"title":"表达式求值——栈","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"此代码实现表达式求值，通过栈实现。`Precede`函数获取运算符优先级，`Operate`函数进行运算。`EvaluateExpression`函数遍历表达式，根据优先级进行操作数和运算符的处理，最终返回结果。主函数测试了该功能。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.165,"time":129900,"words":433},"slug":"2017/20171024135712","path":"blog/2017/20171024135712","filePath":"blog/2017/20171024135712.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"表达式求值——栈","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"此代码实现表达式求值，通过栈实现。`Precede`函数获取运算符优先级，`Operate`函数进行运算。`EvaluateExpression`函数遍历表达式，根据优先级进行操作数和运算符的处理，最终返回结果。主函数测试了该功能。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024135712"}},{"title":"boost xml","date":"2017-10-24T00:00:00.000Z","tags":["C/C++","Boost"],"draft":false,"summary":"介绍了使用 Boost 库读写 XML 文件的示例代码。通过`load`函数读取`testConfigRead.xml`文件内容并存储到结构体`TestConfig`中，通过`save`函数将结构体内容写入`testConfigWrite.xml`文件，展示了 Boost 库在 XML 操作方面的便捷性。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.21,"time":72600,"words":242},"slug":"2017/20171024140242","path":"blog/2017/20171024140242","filePath":"blog/2017/20171024140242.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"boost xml","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"介绍了使用 Boost 库读写 XML 文件的示例代码。通过`load`函数读取`testConfigRead.xml`文件内容并存储到结构体`TestConfig`中，通过`save`函数将结构体内容写入`testConfigWrite.xml`文件，展示了 Boost 库在 XML 操作方面的便捷性。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024140242"}},{"title":"python模拟鼠标、捕获按键事件","date":"2017-10-24T00:00:00.000Z","tags":["Tools"],"draft":false,"summary":"文章介绍用 Python 模拟鼠标、捕获按键事件。可连续双击鼠标左键，用按键 1 控制运行、其他按键暂停。通过多线程实现，定义相关函数并启动线程，代码实现了相应功能。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.895,"time":53700,"words":179},"slug":"2017/20171024140332","path":"blog/2017/20171024140332","filePath":"blog/2017/20171024140332.mdx","toc":[{"value":"----------------------------------------------------------------------------   Name           Purpose     Author      Administrator     Created     02...","url":"#-------------------------------------------------------------------------------name-----------purpose-----author------administrator-----created-----02","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"python模拟鼠标、捕获按键事件","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"文章介绍用 Python 模拟鼠标、捕获按键事件。可连续双击鼠标左键，用按键 1 控制运行、其他按键暂停。通过多线程实现，定义相关函数并启动线程，代码实现了相应功能。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024140332"}},{"title":"2013新的一年马上到来了","date":"2017-10-24T00:00:00.000Z","tags":["Life"],"draft":false,"summary":"2013 年将至，作者回顾从 2010 年毕业至今的经历。07 年接触编程，大二下学期主动学习，通过多考试。毕业后找实习做输入法接触多种技术，后换工作做数据采集等，目前工作仍与通信有关，接触不少开源库，期望能写出好库，迎接新年。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.995,"time":179700,"words":599},"slug":"2017/20171024141026","path":"blog/2017/20171024141026","filePath":"blog/2017/20171024141026.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"2013新的一年马上到来了","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"2013 年将至，作者回顾从 2010 年毕业至今的经历。07 年接触编程，大二下学期主动学习，通过多考试。毕业后找实习做输入法接触多种技术，后换工作做数据采集等，目前工作仍与通信有关，接触不少开源库，期望能写出好库，迎接新年。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024141026"}},{"title":"log4cxx编译、使用","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍 log4cxx 编译与使用，需下载相关文件并解压，运行批处理文件（遇问题需下载 sed），用 vs 打开文件编译得 log4cxx.lib 和 dll，使用时包含头文件、lib 和 dll 文件，配置文件可灵活记日志，还可封装为 Logger 类。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.51,"time":270600,"words":902},"slug":"2017/20171024142205","path":"blog/2017/20171024142205","filePath":"blog/2017/20171024142205.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"log4cxx编译、使用","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"介绍 log4cxx 编译与使用，需下载相关文件并解压，运行批处理文件（遇问题需下载 sed），用 vs 打开文件编译得 log4cxx.lib 和 dll，使用时包含头文件、lib 和 dll 文件，配置文件可灵活记日志，还可封装为 Logger 类。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024142205"}},{"title":"WSAAsyncSelect模型","date":"2017-10-24T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"WSAAsyncSelect 模型与窗口相关，用消息通知。文中为对话框客户端关键代码，连接 echo 服务端，测试文件传输，包含自定义消息、消息映射等，还有连接、发送、接收等相关函数。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.86,"time":171600,"words":572},"slug":"2017/20171024142734","path":"blog/2017/20171024142734","filePath":"blog/2017/20171024142734.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WSAAsyncSelect模型","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"WSAAsyncSelect 模型与窗口相关，用消息通知。文中为对话框客户端关键代码，连接 echo 服务端，测试文件传输，包含自定义消息、消息映射等，还有连接、发送、接收等相关函数。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024142734"}},{"title":"select模型","date":"2017-10-24T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"介绍 select 模型，需设 listenSock 为非阻塞，放入 fdread 中。每次 FD_SET 前要 FD_ZERO，用 list 保存 SOCKET 循环处理。在`_tmain`函数中创建套接字、绑定、监听等，通过 select 检测读写事件并处理客户端连接与数据收发。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.825,"time":169500,"words":565},"slug":"2017/20171024142826","path":"blog/2017/20171024142826","filePath":"blog/2017/20171024142826.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"select模型","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"介绍 select 模型，需设 listenSock 为非阻塞，放入 fdread 中。每次 FD_SET 前要 FD_ZERO，用 list 保存 SOCKET 循环处理。在`_tmain`函数中创建套接字、绑定、监听等，通过 select 检测读写事件并处理客户端连接与数据收发。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024142826"}},{"title":"visual stdio不同目录下的文件重名，类重名问题解决方法","date":"2017-10-24T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"文章介绍 visual stdio 不同目录下文件重名及类重名问题及解决方法。先给出特定目录结构及代码，编译时出现 warning 因同名 obj 文件导致类编译出错，简单改文件名可解决但会造成重复定义，加命名空间可解决。还可在重复 cpp 文件属性中修改输出文件对象文件名避免重名。\r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.14,"time":188400,"words":628},"slug":"2017/20171024143716","path":"blog/2017/20171024143716","filePath":"blog/2017/20171024143716.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"visual stdio不同目录下的文件重名，类重名问题解决方法","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"文章介绍 visual stdio 不同目录下文件重名及类重名问题及解决方法。先给出特定目录结构及代码，编译时出现 warning 因同名 obj 文件导致类编译出错，简单改文件名可解决但会造成重复定义，加命名空间可解决。还可在重复 cpp 文件属性中修改输出文件对象文件名避免重名。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171024143716"}},{"title":"C、C++常用函数备份（持续更新）","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"本文为 C、C++常用函数备份，包含获取当前毫秒数、获取格式化时间等多种函数，如`GetCurrentMilliseconds()`、`GetTimeString()`等，还有字节大小格式化、产生随机字符串等功能函数，满足多种编程需求。  \r","type":"Blog","readingTime":{"text":"9 min read","minutes":8.31,"time":498600,"words":1662},"slug":"2017/20171210125826","path":"blog/2017/20171210125826","filePath":"blog/2017/20171210125826.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C、C++常用函数备份（持续更新）","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"本文为 C、C++常用函数备份，包含获取当前毫秒数、获取格式化时间等多种函数，如`GetCurrentMilliseconds()`、`GetTimeString()`等，还有字节大小格式化、产生随机字符串等功能函数，满足多种编程需求。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125826"}},{"title":"C、C++面试题（整理上）","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"总结：文章涵盖 C、C++ 诸多面试题及相关知识，如 new 与 delete、继承组合优缺点等，详细阐述各知识点并给出答案及解释，还涉及多种数据类型转换等内容。  \r","type":"Blog","readingTime":{"text":"26 min read","minutes":25.305,"time":1518300,"words":5061},"slug":"2017/20171210125827","path":"blog/2017/20171210125827","filePath":"blog/2017/20171210125827.mdx","toc":[{"value":"new、delete、malloc、free关系","url":"#newdeletemallocfree关系","depth":1},{"value":"delete与delete []区别","url":"#delete与delete-区别","depth":1},{"value":"C/C++ JAVA .NET区别","url":"#cc-java-net区别","depth":1},{"value":"继承、组合优缺点","url":"#继承组合优缺点","depth":1},{"value":"C++有哪些特质（面向对象特点）","url":"#c有哪些特质面向对象特点","depth":1},{"value":"子类析构时要调用父类的析构函数吗","url":"#子类析构时要调用父类的析构函数吗","depth":1},{"value":"多态，虚函数，纯虚函数","url":"#多态虚函数纯虚函数","depth":1},{"value":"求下面函数的返回值（微软）","url":"#求下面函数的返回值微软","depth":1},{"value":"什么是“引用”，声明和使用“引用”要注意哪些问题","url":"#什么是引用声明和使用引用要注意哪些问题","depth":1},{"value":"将“引用”作为函数参数有哪些特点","url":"#将引用作为函数参数有哪些特点","depth":1},{"value":"在什么时候需要使用“常引用”","url":"#在什么时候需要使用常引用","depth":1},{"value":"将“引用”作为函数返回值类型的格式、好处和需要遵守的规则","url":"#将引用作为函数返回值类型的格式好处和需要遵守的规则","depth":1},{"value":"“引用”与多态的关系","url":"#引用与多态的关系","depth":1},{"value":"“引用”与指针的区别是什么","url":"#引用与指针的区别是什么","depth":1},{"value":"结构与联合的区别","url":"#结构与联合的区别","depth":1},{"value":"关于“联合”题目的输出结果","url":"#关于联合题目的输出结果","depth":1},{"value":"关联、聚合（Aggregation）以及组合（Composition）的区别","url":"#关联聚合aggregation以及组合composition的区别","depth":1},{"value":"重载（overload）和重写（overried，也叫做“覆盖”）的区别","url":"#重载overload和重写overried也叫做覆盖的区别","depth":1},{"value":"多态的作用","url":"#多态的作用","depth":1},{"value":"Ado与Ado.net的相同与不同","url":"#ado与adonet的相同与不同","depth":1},{"value":"宏","url":"#宏","depth":1},{"value":"有哪几种情况只能用initialization list而不能用assignment","url":"#有哪几种情况只能用initialization-list而不能用assignment","depth":1},{"value":"C++是不是类型安全的","url":"#c是不是类型安全的","depth":1},{"value":"main函数执行以前，还会执行什么代码","url":"#main函数执行以前还会执行什么代码","depth":1},{"value":"描述内存分配方式以及它们的区别","url":"#描述内存分配方式以及它们的区别","depth":1},{"value":"struct和class的区别","url":"#struct和class的区别","depth":1},{"value":"当一个类A中没有任何成员变量与成员函数，这是sizeof(A)的值是多少","url":"#当一个类a中没有任何成员变量与成员函数这是sizeofa的值是多少","depth":1},{"value":"在8086汇编下，逻辑地址和物理地址是怎样转换的（Interl）","url":"#在8086汇编下逻辑地址和物理地址是怎样转换的interl","depth":1},{"value":"比较C++中的4中类型转换方式","url":"#比较c中的4中类型转换方式","depth":1},{"value":"分别写出BOOL, int, float， 指针类型的变量a与“零”的比较语句","url":"#分别写出bool-int-float-指针类型的变量a与零的比较语句","depth":1},{"value":"请说出const与#define相比，有何有点","url":"#请说出const与define相比有何有点","depth":1},{"value":"简述数组与指针的区别","url":"#简述数组与指针的区别","depth":1},{"value":"类成员函数的重载、覆盖和隐藏的区别","url":"#类成员函数的重载覆盖和隐藏的区别","depth":1},{"value":"求出两个数中的较大者","url":"#求出两个数中的较大者","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C、C++面试题（整理上）","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"总结：文章涵盖 C、C++ 诸多面试题及相关知识，如 new 与 delete、继承组合优缺点等，详细阐述各知识点并给出答案及解释，还涉及多种数据类型转换等内容。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125827"}},{"title":"C、C++面试题（整理下）","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"这是关于 C、C++的面试题整理，包含打印源文件信息、main 主函数执行后代码执行、判断编译语言、整数数组排序、链表相关、程序输出分析、找第二大整数、寻找子串位置、判断单链表是否有环、指针找错、标准函数编写、头文件相关、C++调用 C 函数、String 实现、函数调用输出等多方面内容，还包括一些具体代码示例和解答。 \r","type":"Blog","readingTime":{"text":"8 min read","minutes":7.1,"time":426000,"words":1420},"slug":"2017/20171210125828","path":"blog/2017/20171210125828","filePath":"blog/2017/20171210125828.mdx","toc":[{"value":"如何打印出当前源文件的文件名以及源文件的当前行号","url":"#如何打印出当前源文件的文件名以及源文件的当前行号","depth":1},{"value":"main主函数执行完毕后，是否可能会再执行一段代码，给出说明","url":"#main主函数执行完毕后是否可能会再执行一段代码给出说明","depth":1},{"value":"如何判断一段程序是由C编译的还是由C++编译的","url":"#如何判断一段程序是由c编译的还是由c编译的","depth":1},{"value":"文件中有一组整数，要求排序后输出到另一个文件中","url":"#文件中有一组整数要求排序后输出到另一个文件中","depth":1},{"value":"链表题，一个链表的节点结构","url":"#链表题一个链表的节点结构","depth":1},{"value":"分析一下这段程序的输出（Autodesk）","url":"#分析一下这段程序的输出autodesk","depth":1},{"value":"写一个函数找出一个整数数组中第二大的数（microsoft）","url":"#写一个函数找出一个整数数组中第二大的数microsoft","depth":1},{"value":"写一个在一个字符串（n）中寻找一个字串（m）第一个位置的函数","url":"#写一个在一个字符串n中寻找一个字串m第一个位置的函数","depth":1},{"value":"如何判断一个单链表是有环的（注意不能用标志位，最多只能用两个额外指针）","url":"#如何判断一个单链表是有环的注意不能用标志位最多只能用两个额外指针","depth":1},{"value":"指针找错题","url":"#指针找错题","depth":1},{"value":"编写一个标准的strcpy和strlen函数","url":"#编写一个标准的strcpy和strlen函数","depth":1},{"value":"头文件中的ifndef/define/endif的作用","url":"#头文件中的ifndefdefineendif的作用","depth":1},{"value":"#include <file.h>与#include \"file.h\"的区别","url":"#include-fileh与include-fileh的区别","depth":1},{"value":"在C++程序中调用被C编译器编译后的函数，为什么要加extern \"C\"","url":"#在c程序中调用被c编译器编译后的函数为什么要加extern-c","depth":1},{"value":"String的具体实现","url":"#string的具体实现","depth":1},{"value":"What is displayed when Func() is called given the code:","url":"#what-is-displayed-when-func-is-called-given-the-code","depth":1},{"value":"Which is the correct output for the following code","url":"#which-is-the-correct-output-for-the-following-code","depth":1},{"value":"Sony笔试题","url":"#sony笔试题","depth":1},{"value":"将字符串中的单词进行倒序","url":"#将字符串中的单词进行倒序","depth":1},{"value":"将一个长度为n的字符串向左循环移动m位","url":"#将一个长度为n的字符串向左循环移动m位","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C、C++面试题（整理下）","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"这是关于 C、C++的面试题整理，包含打印源文件信息、main 主函数执行后代码执行、判断编译语言、整数数组排序、链表相关、程序输出分析、找第二大整数、寻找子串位置、判断单链表是否有环、指针找错、标准函数编写、头文件相关、C++调用 C 函数、String 实现、函数调用输出等多方面内容，还包括一些具体代码示例和解答。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125828"}},{"title":"tcp、ip 3次握手与4次分手","date":"2017-10-24T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"总结：介绍 TCP、IP 的 3 次握手（服务器被动打开、客户主动打开等步骤）与 4 次分手（应用进程调用 close 等流程），并配有相关图示，清晰阐述连接建立与终止过程。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.35,"time":141000,"words":470},"slug":"2017/20171210125834","path":"blog/2017/20171210125834","filePath":"blog/2017/20171210125834.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"tcp、ip 3次握手与4次分手","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"总结：介绍 TCP、IP 的 3 次握手（服务器被动打开、客户主动打开等步骤）与 4 次分手（应用进程调用 close 等流程），并配有相关图示，清晰阐述连接建立与终止过程。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125834"}},{"title":"windows std  cout设置输出颜色","date":"2017-10-24T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍在 Windows 中设置 `std::cout` 输出颜色的方法，包含 ConsoleColor.h 头文件，通过定义不同颜色的函数及操作符重载来实现，如 `blue`、`red` 等函数可设置相应颜色输出。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.69,"time":41400,"words":138},"slug":"2017/20171210125835","path":"blog/2017/20171210125835","filePath":"blog/2017/20171210125835.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"windows std  cout设置输出颜色","datePublished":"2017-10-24T00:00:00.000Z","dateModified":"2017-10-24T00:00:00.000Z","description":"介绍在 Windows 中设置 `std::cout` 输出颜色的方法，包含 ConsoleColor.h 头文件，通过定义不同颜色的函数及操作符重载来实现，如 `blue`、`red` 等函数可设置相应颜色输出。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125835"}},{"title":"我的书签","date":"2017-10-23T00:00:00.000Z","tags":["Life"],"draft":false,"summary":"总结：这是一份包含众多技术相关网站的书签列表，如唐巧博客、奇舞团博客等，涵盖 IOS 技术、前端、C++等多个领域，还有各种工具和学习资源网站。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.915,"time":174900,"words":583},"slug":"2017/20171023132128","path":"blog/2017/20171023132128","filePath":"blog/2017/20171023132128.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"我的书签","datePublished":"2017-10-23T00:00:00.000Z","dateModified":"2017-10-23T00:00:00.000Z","description":"总结：这是一份包含众多技术相关网站的书签列表，如唐巧博客、奇舞团博客等，涵盖 IOS 技术、前端、C++等多个领域，还有各种工具和学习资源网站。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171023132128"}},{"title":"给marked增加TOC(Table of content)","date":"2017-10-22T00:00:00.000Z","tags":["Web","Javascript"],"draft":false,"summary":"介绍给 marked 库增加 TOC 功能，先初始化 marked 引入库并重写 renderer.heading，设置参数后保存解析后的 header 信息，再用特定代码将数据转换成 html 形式的 toc，最后通过 post2html 函数实现并添加锚点定位偏移 css。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.51,"time":270600,"words":902},"slug":"2017/20171022033741","path":"blog/2017/20171022033741","filePath":"blog/2017/20171022033741.mdx","toc":[{"value":"初始化marked","url":"#初始化marked","depth":1},{"value":"引入库","url":"#引入库","depth":2},{"value":"重写renderer.heading","url":"#重写rendererheading","depth":2},{"value":"设置参数","url":"#设置参数","depth":2},{"value":"保存marked解析后的header信息","url":"#保存marked解析后的header信息","depth":1},{"value":"产生toc的html代码","url":"#产生toc的html代码","depth":1},{"value":"最后的代码实现","url":"#最后的代码实现","depth":1},{"value":"锚点定位偏移css","url":"#锚点定位偏移css","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"给marked增加TOC(Table of content)","datePublished":"2017-10-22T00:00:00.000Z","dateModified":"2017-10-22T00:00:00.000Z","description":"介绍给 marked 库增加 TOC 功能，先初始化 marked 引入库并重写 renderer.heading，设置参数后保存解析后的 header 信息，再用特定代码将数据转换成 html 形式的 toc，最后通过 post2html 函数实现并添加锚点定位偏移 css。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171022033741"}},{"title":"登录后自动跳转到登录前的页面","date":"2017-10-20T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"文章介绍登录后自动跳转到登录前页面的方法。在 signin.html 页面的表单中增加隐藏元素记录前页地址，后台验证登录成功后根据 referrer 判断是否跳转，若存在则跳转到 referrer 地址，不存在则跳转到主页，通过相关代码实现此功能。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.555,"time":93300,"words":311},"slug":"2017/20171020082612","path":"blog/2017/20171020082612","filePath":"blog/2017/20171020082612.mdx","toc":[{"value":"signin.html页面","url":"#signinhtml页面","depth":1},{"value":"路由","url":"#路由","depth":1},{"value":"后台处理登录","url":"#后台处理登录","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"登录后自动跳转到登录前的页面","datePublished":"2017-10-20T00:00:00.000Z","dateModified":"2017-10-20T00:00:00.000Z","description":"文章介绍登录后自动跳转到登录前页面的方法。在 signin.html 页面的表单中增加隐藏元素记录前页地址，后台验证登录成功后根据 referrer 判断是否跳转，若存在则跳转到 referrer 地址，不存在则跳转到主页，通过相关代码实现此功能。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171020082612"}},{"title":"Markdown在线预览","date":"2017-10-14T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"Markdown 在线预览上线，可拖放或上传文件预览，服务器不存副本。前端通过 HTML 和 JS 实现拖拽及文件选择功能，后台用 koa2 并引入 koaBody 模块，将 markdown 转换为 html 格式显示。暂未考虑浏览器兼容性。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.49,"time":149400,"words":498},"slug":"2017/20171014071803","path":"blog/2017/20171014071803","filePath":"blog/2017/20171014071803.mdx","toc":[{"value":"前端实现","url":"#前端实现","depth":1},{"value":"后台实现","url":"#后台实现","depth":1},{"value":"引入koaBody模块","url":"#引入koabody模块","depth":2},{"value":"路由以及实现","url":"#路由以及实现","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Markdown在线预览","datePublished":"2017-10-14T00:00:00.000Z","dateModified":"2017-10-14T00:00:00.000Z","description":"Markdown 在线预览上线，可拖放或上传文件预览，服务器不存副本。前端通过 HTML 和 JS 实现拖拽及文件选择功能，后台用 koa2 并引入 koaBody 模块，将 markdown 转换为 html 格式显示。暂未考虑浏览器兼容性。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171014071803"}},{"title":"mongodb部署分片集群","date":"2017-10-12T00:00:00.000Z","tags":["Database","MongoDB"],"draft":false,"summary":"在 3 台 CentOS 6 服务器上部署 mongodb 分片集群，准备工作包括保证服务器连通、关闭防火墙等，准备好各目录及文件，按顺序创建并初始化配置、分片服务副本集，启动 mongos 服务，添加分片并启用分片，简单验证集群可插入数据且统计信息正确。 \r","type":"Blog","readingTime":{"text":"7 min read","minutes":6.65,"time":399000,"words":1330},"slug":"2017/20171012081009","path":"blog/2017/20171012081009","filePath":"blog/2017/20171012081009.mdx","toc":[{"value":"目标","url":"#目标","depth":1},{"value":"准备工作","url":"#准备工作","depth":1},{"value":"主目录","url":"#主目录","depth":2},{"value":"bin目录","url":"#bin目录","depth":2},{"value":"deploy目录","url":"#deploy目录","depth":2},{"value":"dbs目录","url":"#dbs目录","depth":2},{"value":"logs目录","url":"#logs目录","depth":2},{"value":"pids目录","url":"#pids目录","depth":2},{"value":"etc目录","url":"#etc目录","depth":2},{"value":"文件准备","url":"#文件准备","depth":2},{"value":"每个服务器都将mongodb安装在/usr/local目录下","url":"#每个服务器都将mongodb安装在usrlocal目录下","depth":3},{"value":"每台服务器上准备deploy目录","url":"#每台服务器上准备deploy目录","depth":3},{"value":"部署分片集群","url":"#部署分片集群","depth":1},{"value":"创建配置服务副本集","url":"#创建配置服务副本集","depth":2},{"value":"初始化配置服务副本集","url":"#初始化配置服务副本集","depth":2},{"value":"创建分片1服务副本集","url":"#创建分片1服务副本集","depth":2},{"value":"初始化分片1服务副本集","url":"#初始化分片1服务副本集","depth":2},{"value":"创建分片2服务副本集","url":"#创建分片2服务副本集","depth":2},{"value":"初始化分片2副本集","url":"#初始化分片2副本集","depth":2},{"value":"启动mongos服务","url":"#启动mongos服务","depth":2},{"value":"连接到mongos","url":"#连接到mongos","depth":2},{"value":"集群简单验证","url":"#集群简单验证","depth":1},{"value":"连接到其中一个mongos服务","url":"#连接到其中一个mongos服务","depth":2},{"value":"使用test数据库","url":"#使用test数据库","depth":2},{"value":"往test数据库的users集合中插入10000条数据","url":"#往test数据库的users集合中插入10000条数据","depth":2},{"value":"查看users集合状态","url":"#查看users集合状态","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"mongodb部署分片集群","datePublished":"2017-10-12T00:00:00.000Z","dateModified":"2017-10-12T00:00:00.000Z","description":"在 3 台 CentOS 6 服务器上部署 mongodb 分片集群，准备工作包括保证服务器连通、关闭防火墙等，准备好各目录及文件，按顺序创建并初始化配置、分片服务副本集，启动 mongos 服务，添加分片并启用分片，简单验证集群可插入数据且统计信息正确。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171012081009"}},{"title":"protobuf反射","date":"2017-09-30T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"C++本身无反射，protobuf 可实现。介绍其两种用途：通过 proto 对象名字创建对象，通过 Message 初始化和获取成员变量值，不知具体子类时可通过 key 获取或设置值，如获取 int32 值和设置 int32 值，其他类型同理。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.515,"time":90900,"words":303},"slug":"2017/20170930095016","path":"blog/2017/20170930095016","filePath":"blog/2017/20170930095016.mdx","toc":[{"value":"通过proto对象的名字来创建一个对象","url":"#通过proto对象的名字来创建一个对象","depth":1},{"value":"通过Message初始化和获取成员变量的值","url":"#通过message初始化和获取成员变量的值","depth":1},{"value":"通过Message的key获取值","url":"#通过message的key获取值","depth":2},{"value":"通过key给Message设置值","url":"#通过key给message设置值","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"protobuf反射","datePublished":"2017-09-30T00:00:00.000Z","dateModified":"2017-09-30T00:00:00.000Z","description":"C++本身无反射，protobuf 可实现。介绍其两种用途：通过 proto 对象名字创建对象，通过 Message 初始化和获取成员变量值，不知具体子类时可通过 key 获取或设置值，如获取 int32 值和设置 int32 值，其他类型同理。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170930095016"}},{"title":"10个React小模式","date":"2017-09-24T00:00:00.000Z","tags":["React"],"draft":false,"summary":"分享 10 个 React 小模式，包括数据传递、修复 input 标签、绑定 ID、控制 CSS、动态组件等。还提及优化组件、别过早组件化、文本格式化组件、降低组件复杂度及正确导入组件等，希望对 React 初学者有帮助。 \r","type":"Blog","readingTime":{"text":"13 min read","minutes":12.39,"time":743400,"words":2478},"slug":"2017/20170924141623","path":"blog/2017/20170924141623","filePath":"blog/2017/20170924141623.mdx","toc":[{"value":"1.数据向下和向上传递","url":"#1数据向下和向上传递","depth":1},{"value":"2.修复HTML的input标签","url":"#2修复html的input标签","depth":1},{"value":"3.为input绑定唯一的ID","url":"#3为input绑定唯一的id","depth":1},{"value":"4.用props控制CSS","url":"#4用props控制css","depth":1},{"value":"5.动态组件","url":"#5动态组件","depth":1},{"value":"6.优化组件","url":"#6优化组件","depth":1},{"value":"7.别过早组件化","url":"#7别过早组件化","depth":1},{"value":"8.用于文本格式化的组件","url":"#8用于文本格式化的组件","depth":1},{"value":"9.降低组件复杂度","url":"#9降低组件复杂度","depth":1},{"value":"10.不用相对路径来导入组件","url":"#10不用相对路径来导入组件","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"10个React小模式","datePublished":"2017-09-24T00:00:00.000Z","dateModified":"2017-09-24T00:00:00.000Z","description":"分享 10 个 React 小模式，包括数据传递、修复 input 标签、绑定 ID、控制 CSS、动态组件等。还提及优化组件、别过早组件化、文本格式化组件、降低组件复杂度及正确导入组件等，希望对 React 初学者有帮助。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170924141623"}},{"title":"如何优雅的编写JavaScript代码","date":"2017-09-23T00:00:00.000Z","tags":["Javascript"],"draft":false,"summary":"本文介绍了优雅编写 JavaScript 代码的方法，包括避免使用糟粕特性、编写简洁代码（如使用有意义变量名等）、利用 ES6/ES7 新特性（箭头函数等）、使用 Babel 转码、ESLint 保证代码风格、Prettier 格式化代码、采用函数式编程等，强调长期奉行这些准则能提升代码质量，是软件工程发展的重要部分。 \r","type":"Blog","readingTime":{"text":"28 min read","minutes":27.385,"time":1643100,"words":5477},"slug":"2017/20170923123203","path":"blog/2017/20170923123203","filePath":"blog/2017/20170923123203.mdx","toc":[{"value":"避免使用 JS 糟粕和鸡肋","url":"#避免使用-js-糟粕和鸡肋","depth":1},{"value":"编写简洁的 JavaScript 代码","url":"#编写简洁的-javascript-代码","depth":1},{"value":"变量","url":"#变量","depth":2},{"value":"使用有意义，可读性好的变量名","url":"#使用有意义可读性好的变量名","depth":3},{"value":"使用 ES6 的 const 定义常量","url":"#使用-es6-的-const-定义常量","depth":3},{"value":"使用易于检索的名称","url":"#使用易于检索的名称","depth":3},{"value":"使用说明性的变量 (即有意义的变量名)","url":"#使用说明性的变量-即有意义的变量名","depth":3},{"value":"方法","url":"#方法","depth":2},{"value":"保持函数功能的单一性","url":"#保持函数功能的单一性","depth":3},{"value":"函数名应明确表明其功能（见名知意）","url":"#函数名应明确表明其功能见名知意","depth":3},{"value":"使用默认变量替代短路运算或条件","url":"#使用默认变量替代短路运算或条件","depth":3},{"value":"函数参数 (理想情况下应不超过 2 个)","url":"#函数参数-理想情况下应不超过-2-个","depth":3},{"value":"移除重复代码","url":"#移除重复代码","depth":3},{"value":"避免副作用","url":"#避免副作用","depth":3},{"value":"避免条件判断","url":"#避免条件判断","depth":3},{"value":"使用 ES6/ES7 新特性","url":"#使用-es6es7-新特性","depth":2},{"value":"箭头函数","url":"#箭头函数","depth":3},{"value":"模板字符串","url":"#模板字符串","depth":3},{"value":"解构","url":"#解构","depth":3},{"value":"使用 ES6 的 classes 而不是 ES5 的 Function","url":"#使用-es6-的-classes-而不是-es5-的-function","depth":3},{"value":"Async/Await 是比 Promise 和回调更好的选择","url":"#asyncawait-是比-promise-和回调更好的选择","depth":3},{"value":"Babel","url":"#babel","depth":1},{"value":"Use next generation JavaScript, today","url":"#use-next-generation-javascript-today","depth":2},{"value":"ESLint","url":"#eslint","depth":1},{"value":"Prettier","url":"#prettier","depth":1},{"value":"采用函数式编程","url":"#采用函数式编程","depth":1},{"value":"总结","url":"#总结","depth":1},{"value":"参考","url":"#参考","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何优雅的编写JavaScript代码","datePublished":"2017-09-23T00:00:00.000Z","dateModified":"2017-09-23T00:00:00.000Z","description":"本文介绍了优雅编写 JavaScript 代码的方法，包括避免使用糟粕特性、编写简洁代码（如使用有意义变量名等）、利用 ES6/ES7 新特性（箭头函数等）、使用 Babel 转码、ESLint 保证代码风格、Prettier 格式化代码、采用函数式编程等，强调长期奉行这些准则能提升代码质量，是软件工程发展的重要部分。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170923123203"}},{"title":"模拟QThreadPool实现","date":"2017-09-21T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"本文介绍了使用C++模拟实现QThreadPool的过程，涵盖线程池的核心组件设计与实现，包括任务调度、线程管理及同步机制。\r","type":"Blog","readingTime":{"text":"9 min read","minutes":8.265,"time":495900,"words":1653},"slug":"2017/20170921101911","path":"blog/2017/20170921101911","filePath":"blog/2017/20170921101911.mdx","toc":[{"value":"std::thread::hardware_concurrency()","url":"#stdthreadhardware_concurrency","depth":2},{"value":"template <class T> numeric_limits","url":"#template-class-t-numeric_limits","depth":2},{"value":"std::unique_ptr","url":"#stdunique_ptr","depth":2},{"value":"std::upper_bound","url":"#stdupper_bound","depth":2},{"value":"std::lower_bound","url":"#stdlower_bound","depth":2},{"value":"std::unique_lock<std::mutex>","url":"#stdunique_lockstdmutex","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"模拟QThreadPool实现","datePublished":"2017-09-21T00:00:00.000Z","dateModified":"2017-09-21T00:00:00.000Z","description":"本文介绍了使用C++模拟实现QThreadPool的过程，涵盖线程池的核心组件设计与实现，包括任务调度、线程管理及同步机制。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170921101911"}},{"title":"std  move和右值引用","date":"2017-09-21T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"右值引用可避免不必要内存拷贝提高性能。如 std::string 示例，push_back 时加 std::move 避免深拷贝。自定义类需实现右值引用相关函数，std::move 只是返回右值类型调用类中操作，虽增加写库工作量，但方便用户且提升程序性能。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.605,"time":216300,"words":721},"slug":"2017/20171210125833","path":"blog/2017/20171210125833","filePath":"blog/2017/20171210125833.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"std  move和右值引用","datePublished":"2017-09-21T00:00:00.000Z","dateModified":"2017-09-21T00:00:00.000Z","description":"右值引用可避免不必要内存拷贝提高性能。如 std::string 示例，push_back 时加 std::move 避免深拷贝。自定义类需实现右值引用相关函数，std::move 只是返回右值类型调用类中操作，虽增加写库工作量，但方便用户且提升程序性能。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125833"}},{"title":"Qt简单截屏","date":"2017-09-18T00:00:00.000Z","tags":["Qt","C/C++"],"draft":false,"summary":"介绍 Qt 简单截屏，通过鼠标操作实现。定义 GrabWidget 类，包含多种鼠标事件处理函数，如移动、按下、释放等，可保存截取的图片。主函数创建并显示 GrabWidget 实例。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.38,"time":82800,"words":276},"slug":"2017/20170918012544","path":"blog/2017/20170918012544","filePath":"blog/2017/20170918012544.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt简单截屏","datePublished":"2017-09-18T00:00:00.000Z","dateModified":"2017-09-18T00:00:00.000Z","description":"介绍 Qt 简单截屏，通过鼠标操作实现。定义 GrabWidget 类，包含多种鼠标事件处理函数，如移动、按下、释放等，可保存截取的图片。主函数创建并显示 GrabWidget 实例。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170918012544"}},{"title":"Qt重要特性","date":"2017-09-18T00:00:00.000Z","tags":["Qt","C/C++"],"draft":false,"summary":"Qt 是跨平台 C++开发框架，含丰富类库与工具。有事件循环、事件过滤，通过 QEventLoop 处理自发和已发事件。信号槽机制可松耦合通信，新语法有编译期检查等优点。还有元对象、隐式共享与 d-pointer 技术、布局管理（多种布局可组合）、内存管理（自动或延迟销毁）等重要特性。 \r","type":"Blog","readingTime":{"text":"21 min read","minutes":20.1,"time":1206000,"words":4020},"slug":"2017/20170918085557","path":"blog/2017/20170918085557","filePath":"blog/2017/20170918085557.mdx","toc":[{"value":"事件循环，事件过滤","url":"#事件循环事件过滤","depth":2},{"value":"信号槽","url":"#信号槽","depth":2},{"value":"元对象","url":"#元对象","depth":2},{"value":"隐式共享与d-pointer技术","url":"#隐式共享与d-pointer技术","depth":2},{"value":"布局管理","url":"#布局管理","depth":2},{"value":"内存管理","url":"#内存管理","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt重要特性","datePublished":"2017-09-18T00:00:00.000Z","dateModified":"2017-09-18T00:00:00.000Z","description":"Qt 是跨平台 C++开发框架，含丰富类库与工具。有事件循环、事件过滤，通过 QEventLoop 处理自发和已发事件。信号槽机制可松耦合通信，新语法有编译期检查等优点。还有元对象、隐式共享与 d-pointer 技术、布局管理（多种布局可组合）、内存管理（自动或延迟销毁）等重要特性。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170918085557"}},{"title":"Qt只启动一个实例","date":"2017-09-18T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"文章介绍 Qt 实现只启动一个实例的方法，涉及进程间通信。给出三种方案，重点展示共享内存的实现代码，通过 QSharedMemory 和 QSystemSemaphore 保证原子操作，用法示例中用随机 GUID 作为标识。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.97,"time":118200,"words":394},"slug":"2017/20170918095214","path":"blog/2017/20170918095214","filePath":"blog/2017/20170918095214.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt只启动一个实例","datePublished":"2017-09-18T00:00:00.000Z","dateModified":"2017-09-18T00:00:00.000Z","description":"文章介绍 Qt 实现只启动一个实例的方法，涉及进程间通信。给出三种方案，重点展示共享内存的实现代码，通过 QSharedMemory 和 QSystemSemaphore 保证原子操作，用法示例中用随机 GUID 作为标识。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170918095214"}},{"title":"mongodb 常用操作","date":"2017-09-15T00:00:00.000Z","tags":["Database"],"draft":false,"summary":"介绍 mongodb 常用操作，包括连接、插入数据（单条、循环、数组）、聚合、查询（各种条件）、删除记录、limit/skip/sort/distinct 方法、查询创建索引及删除索引、查看命令执行时间、删除文档、主从复制、监控状态、查看数据库及使用数据库、查看集合、导出恢复数据库等。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.415,"time":264900,"words":883},"slug":"2017/20170915010500","path":"blog/2017/20170915010500","filePath":"blog/2017/20170915010500.mdx","toc":[{"value":"连接mongodb","url":"#连接mongodb","depth":2},{"value":"插入数据","url":"#插入数据","depth":2},{"value":"聚合","url":"#聚合","depth":2},{"value":"查询","url":"#查询","depth":2},{"value":"删除记录","url":"#删除记录","depth":2},{"value":"limit方法","url":"#limit方法","depth":2},{"value":"skip方法","url":"#skip方法","depth":2},{"value":"sort方法","url":"#sort方法","depth":2},{"value":"distinct方法","url":"#distinct方法","depth":2},{"value":"查询创建的索引","url":"#查询创建的索引","depth":2},{"value":"删除索引，通过上面查到的name，如：title_1_count_1","url":"#删除索引通过上面查到的name如title_1_count_1","depth":2},{"value":"创建索引","url":"#创建索引","depth":2},{"value":"查看命令执行时间","url":"#查看命令执行时间","depth":2},{"value":"删除文档","url":"#删除文档","depth":2},{"value":"主从复制","url":"#主从复制","depth":2},{"value":"监控状态，每秒刷新一次","url":"#监控状态每秒刷新一次","depth":2},{"value":"查看数据库","url":"#查看数据库","depth":2},{"value":"使用数据库","url":"#使用数据库","depth":2},{"value":"查看当前数据库中的集合（表）","url":"#查看当前数据库中的集合表","depth":2},{"value":"导出数据库","url":"#导出数据库","depth":2},{"value":"恢复数据库","url":"#恢复数据库","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"mongodb 常用操作","datePublished":"2017-09-15T00:00:00.000Z","dateModified":"2017-09-15T00:00:00.000Z","description":"介绍 mongodb 常用操作，包括连接、插入数据（单条、循环、数组）、聚合、查询（各种条件）、删除记录、limit/skip/sort/distinct 方法、查询创建索引及删除索引、查看命令执行时间、删除文档、主从复制、监控状态、查看数据库及使用数据库、查看集合、导出恢复数据库等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170915010500"}},{"title":"Qt解决：warning   Z-order assignment","date":"2017-09-14T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"在 Qt 调整 UI 布局时易出现“Z-order assignment”警告，虽运行无问题但影响代码洁癖。解决办法是用文本编辑器打开 ui 文件，删除含警告的 zroder 行，重新编译后警告消失。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.75,"time":45000,"words":150},"slug":"2017/20171210125832","path":"blog/2017/20171210125832","filePath":"blog/2017/20171210125832.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt解决：warning   Z-order assignment","datePublished":"2017-09-14T00:00:00.000Z","dateModified":"2017-09-14T00:00:00.000Z","description":"在 Qt 调整 UI 布局时易出现“Z-order assignment”警告，虽运行无问题但影响代码洁癖。解决办法是用文本编辑器打开 ui 文件，删除含警告的 zroder 行，重新编译后警告消失。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125832"}},{"title":"WTL VS2013安装","date":"2017-09-01T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍 WTL VS2013 安装，提供下载地址，详解解压后双击运行及处理不能运行的方法，还提及创建项目时向导脚本出错的解决办法及编译工程需包含头文件目录等，相关链接也有说明。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.15,"time":69000,"words":230},"slug":"2017/20170901015152","path":"blog/2017/20170901015152","filePath":"blog/2017/20170901015152.mdx","toc":[{"value":"执行命令后没有安装上","url":"#执行命令后没有安装上","depth":2},{"value":"创建WTL项目时，向导中脚本运行出错","url":"#创建wtl项目时向导中脚本运行出错","depth":2},{"value":"编译WTL工程","url":"#编译wtl工程","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL VS2013安装","datePublished":"2017-09-01T00:00:00.000Z","dateModified":"2017-09-01T00:00:00.000Z","description":"介绍 WTL VS2013 安装，提供下载地址，详解解压后双击运行及处理不能运行的方法，还提及创建项目时向导脚本出错的解决办法及编译工程需包含头文件目录等，相关链接也有说明。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170901015152"}},{"title":"react native 配置方面的问题汇总","date":"2017-08-20T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"总结：文章汇总了 react native 配置方面问题，包括无法加载脚本及无法连接开发服务器等，给出了相应解决办法，如创建目录、执行命令等。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.43,"time":25800,"words":86},"slug":"2017/20170820074417","path":"blog/2017/20170820074417","filePath":"blog/2017/20170820074417.mdx","toc":[{"value":"unable to load script from assets index.android.bundle","url":"#unable-to-load-script-from-assets-indexandroidbundle","depth":1},{"value":"Could not connect to development server","url":"#could-not-connect-to-development-server","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"react native 配置方面的问题汇总","datePublished":"2017-08-20T00:00:00.000Z","dateModified":"2017-08-20T00:00:00.000Z","description":"总结：文章汇总了 react native 配置方面问题，包括无法加载脚本及无法连接开发服务器等，给出了相应解决办法，如创建目录、执行命令等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170820074417"}},{"title":"CSRF 攻击的应对之道","date":"2017-08-19T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"CSRF 是跨站域请求伪造攻击，2007 年被列为互联网 20 大安全隐患。文中介绍其背景、实例、攻击对象及三种防御策略（验证 Referer 字段、添加 token 并验证、自定义 HTTP 头属性并验证），并以 Java 代码示例，还探讨了防御方法选择，总结目前防御策略不完善，需重视并选择合适策略降低危害。 \r","type":"Blog","readingTime":{"text":"25 min read","minutes":24.085,"time":1445100,"words":4817},"slug":"2017/20170819151037","path":"blog/2017/20170819151037","filePath":"blog/2017/20170819151037.mdx","toc":[{"value":"CSRF 背景与介绍","url":"#csrf-背景与介绍","depth":1},{"value":"CSRF 攻击实例","url":"#csrf-攻击实例","depth":1},{"value":"CSRF 攻击的对象","url":"#csrf-攻击的对象","depth":1},{"value":"当前防御 CSRF 的几种策略","url":"#当前防御-csrf-的几种策略","depth":1},{"value":"验证 HTTP Referer 字段","url":"#验证-http-referer-字段","depth":2},{"value":"在请求地址中添加 token 并验证","url":"#在请求地址中添加-token-并验证","depth":2},{"value":"在 HTTP 头中自定义属性并验证","url":"#在-http-头中自定义属性并验证","depth":2},{"value":"Java 代码示例","url":"#java-代码示例","depth":1},{"value":"CSRF 防御方法选择之道","url":"#csrf-防御方法选择之道","depth":1},{"value":"总结与展望","url":"#总结与展望","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"CSRF 攻击的应对之道","datePublished":"2017-08-19T00:00:00.000Z","dateModified":"2017-08-19T00:00:00.000Z","description":"CSRF 是跨站域请求伪造攻击，2007 年被列为互联网 20 大安全隐患。文中介绍其背景、实例、攻击对象及三种防御策略（验证 Referer 字段、添加 token 并验证、自定义 HTTP 头属性并验证），并以 Java 代码示例，还探讨了防御方法选择，总结目前防御策略不完善，需重视并选择合适策略降低危害。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170819151037"}},{"title":"nodejs下载图片保存到本地","date":"2017-08-17T00:00:00.000Z","tags":["Node.js"],"draft":false,"summary":"文章介绍 nodejs 下载图片保存到本地，因浏览器端有防盗链限制而后端无，可通过获取图片 url 在服务端下载保存。给出创建本地目录、下载并写入的代码，还展示了删除大于 100k 文件的方法。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.305,"time":138300,"words":461},"slug":"2017/20170817000250","path":"blog/2017/20170817000250","filePath":"blog/2017/20170817000250.mdx","toc":[{"value":"分析源url，创建本地目录以及解析出新的写入路径","url":"#分析源url创建本地目录以及解析出新的写入路径","depth":1},{"value":"下载并写入","url":"#下载并写入","depth":1},{"value":"删除大于100k的文件","url":"#删除大于100k的文件","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"nodejs下载图片保存到本地","datePublished":"2017-08-17T00:00:00.000Z","dateModified":"2017-08-17T00:00:00.000Z","description":"文章介绍 nodejs 下载图片保存到本地，因浏览器端有防盗链限制而后端无，可通过获取图片 url 在服务端下载保存。给出创建本地目录、下载并写入的代码，还展示了删除大于 100k 文件的方法。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170817000250"}},{"title":"fetch跨域post，后端express","date":"2017-08-16T00:00:00.000Z","tags":["Node.js"],"draft":false,"summary":"总结：通过 fetch 的 post 方法进行跨域请求，后端用 express 时需设置支持跨域，如在 express 中设置各种跨域头信息，fetch 中要注意参数填写，这里还给出了 fetch post 的写法和后端 express 设置跨域的代码。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.625,"time":37500,"words":125},"slug":"2017/20170816234138","path":"blog/2017/20170816234138","filePath":"blog/2017/20170816234138.mdx","toc":[{"value":"fetch post写法如下","url":"#fetch-post写法如下","depth":1},{"value":"后端express设置支持跨域","url":"#后端express设置支持跨域","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"fetch跨域post，后端express","datePublished":"2017-08-16T00:00:00.000Z","dateModified":"2017-08-16T00:00:00.000Z","description":"总结：通过 fetch 的 post 方法进行跨域请求，后端用 express 时需设置支持跨域，如在 express 中设置各种跨域头信息，fetch 中要注意参数填写，这里还给出了 fetch post 的写法和后端 express 设置跨域的代码。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170816234138"}},{"title":"js库支持CommonJs和浏览器的标准写法","date":"2017-08-01T00:00:00.000Z","tags":["Javascript"],"draft":false,"summary":"文章介绍了 github 开源 js 库同时支持 CommonJs 和浏览器的写法。以 A.js 和 B.js 为例，说明了在不同环境下的引用方式及代码结构，还给出了浏览器端和 nodejs 端的测试代码。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.665,"time":99900,"words":333},"slug":"2017/20170801133007","path":"blog/2017/20170801133007","filePath":"blog/2017/20170801133007.mdx","toc":[{"value":"浏览器端测试","url":"#浏览器端测试","depth":1},{"value":"nodejs端测试","url":"#nodejs端测试","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"js库支持CommonJs和浏览器的标准写法","datePublished":"2017-08-01T00:00:00.000Z","dateModified":"2017-08-01T00:00:00.000Z","description":"文章介绍了 github 开源 js 库同时支持 CommonJs 和浏览器的写法。以 A.js 和 B.js 为例，说明了在不同环境下的引用方式及代码结构，还给出了浏览器端和 nodejs 端的测试代码。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170801133007"}},{"title":"react判断滚动到底部以及保持原来的滚动位置","date":"2017-07-25T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"文章解决判断组件滚动到底部及页面切换后保持滚动位置问题。通过 ref 获取 dom 节点，在组件加载和卸载时添加/移除 scroll 事件监听来判断。页面切换时用全局变量保存和恢复 scrollTop 位置。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.79,"time":107400,"words":358},"slug":"2017/20170725101014","path":"blog/2017/20170725101014","filePath":"blog/2017/20170725101014.mdx","toc":[{"value":"判断某个组件是否滚动到底部","url":"#判断某个组件是否滚动到底部","depth":1},{"value":"页面切换出去再切换回来后怎样保持之前的滚动位置","url":"#页面切换出去再切换回来后怎样保持之前的滚动位置","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"react判断滚动到底部以及保持原来的滚动位置","datePublished":"2017-07-25T00:00:00.000Z","dateModified":"2017-07-25T00:00:00.000Z","description":"文章解决判断组件滚动到底部及页面切换后保持滚动位置问题。通过 ref 获取 dom 节点，在组件加载和卸载时添加/移除 scroll 事件监听来判断。页面切换时用全局变量保存和恢复 scrollTop 位置。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170725101014"}},{"title":"使用flex固定头部和底部中间滚动","date":"2017-07-24T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"介绍使用 flex 固定头部和底部中间滚动的方法，关键在于 root 纵向布局高度 100vh 隐藏滚动条，content 设滚动且 flex 为 1，item 设高度后需 flexShrink 为 0，代码示例如下。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.385,"time":83100,"words":277},"slug":"2017/20170724074419","path":"blog/2017/20170724074419","filePath":"blog/2017/20170724074419.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用flex固定头部和底部中间滚动","datePublished":"2017-07-24T00:00:00.000Z","dateModified":"2017-07-24T00:00:00.000Z","description":"介绍使用 flex 固定头部和底部中间滚动的方法，关键在于 root 纵向布局高度 100vh 隐藏滚动条，content 设滚动且 flex 为 1，item 设高度后需 flexShrink 为 0，代码示例如下。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170724074419"}},{"title":"nodejs根据url下载图片存储到当前目录","date":"2017-07-23T00:00:00.000Z","tags":["Node.js"],"draft":false,"summary":"文章介绍 nodejs 可根据 url 下载图片并存储到当前目录。通过安装“request”模块，利用循环遍历图片列表，获取每个图片的 url 和名称，然后使用“request”下载图片并通过“fs”模块保存到本地，代码简洁高效。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.99,"time":119400,"words":398},"slug":"2017/20170723102131","path":"blog/2017/20170723102131","filePath":"blog/2017/20170723102131.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"nodejs根据url下载图片存储到当前目录","datePublished":"2017-07-23T00:00:00.000Z","dateModified":"2017-07-23T00:00:00.000Z","description":"文章介绍 nodejs 可根据 url 下载图片并存储到当前目录。通过安装“request”模块，利用循环遍历图片列表，获取每个图片的 url 和名称，然后使用“request”下载图片并通过“fs”模块保存到本地，代码简洁高效。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170723102131"}},{"title":"javascript原型和继承","date":"2017-07-01T00:00:00.000Z","tags":["Javascript"],"draft":false,"summary":"介绍了 javascript 原型和继承，对象由方法和属性组成，javascript 无类概念，通过原型实现方法共享和继承。原型是隐藏对象，实例对象通过__proto__引用原型对象，形成原型链，new 操作符创建对象并关联原型函数。有伪类继承和原型继承等方式。 \r","type":"Blog","readingTime":{"text":"7 min read","minutes":6.425,"time":385500,"words":1285},"slug":"2017/20170701145128","path":"blog/2017/20170701145128","filePath":"blog/2017/20170701145128.mdx","toc":[{"value":"对象和类","url":"#对象和类","depth":1},{"value":"原型","url":"#原型","depth":1},{"value":"实例对象和原型对象的区别：","url":"#实例对象和原型对象的区别","depth":3},{"value":"多个实例对象共享同一个原型","url":"#多个实例对象共享同一个原型","depth":1},{"value":"原型链","url":"#原型链","depth":1},{"value":"继承","url":"#继承","depth":1},{"value":"伪类继承（Pseudoclassical 继承）","url":"#伪类继承pseudoclassical-继承","depth":2},{"value":"原型继承（Prototypal继承）","url":"#原型继承prototypal继承","depth":2},{"value":"new操作符所做的事情","url":"#new操作符所做的事情","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"javascript原型和继承","datePublished":"2017-07-01T00:00:00.000Z","dateModified":"2017-07-01T00:00:00.000Z","description":"介绍了 javascript 原型和继承，对象由方法和属性组成，javascript 无类概念，通过原型实现方法共享和继承。原型是隐藏对象，实例对象通过__proto__引用原型对象，形成原型链，new 操作符创建对象并关联原型函数。有伪类继承和原型继承等方式。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170701145128"}},{"title":"qDebug日志写入本地文件","date":"2017-06-30T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"在 Qt 中，通过`qInstallMessageHandler(myMessageOutput)`在应用创建前设置日志处理函数。该函数根据不同类型输出带时间、文件、行号的日志，使用当天日期作为文件名，可指定打印文件，日志信息先输出到调试面板再写入文件。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.74,"time":104400,"words":348},"slug":"2017/20170630021101","path":"blog/2017/20170630021101","filePath":"blog/2017/20170630021101.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"qDebug日志写入本地文件","datePublished":"2017-06-30T00:00:00.000Z","dateModified":"2017-06-30T00:00:00.000Z","description":"在 Qt 中，通过`qInstallMessageHandler(myMessageOutput)`在应用创建前设置日志处理函数。该函数根据不同类型输出带时间、文件、行号的日志，使用当天日期作为文件名，可指定打印文件，日志信息先输出到调试面板再写入文件。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170630021101"}},{"title":"javascript怎么实现类似如C++函数中使用静态数据","date":"2017-06-25T00:00:00.000Z","tags":["Javascript"],"draft":false,"summary":"在 JavaScript 中实现类似 C++函数中静态数据，可利用闭包。如通过创建立即调用函数表达式，在内部定义并返回一个函数，该函数可访问内部的变量，避免全局污染。像防抖函数 debounce 就利用了此原理。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.025,"time":121500,"words":405},"slug":"2017/20170625130219","path":"blog/2017/20170625130219","filePath":"blog/2017/20170625130219.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"javascript怎么实现类似如C++函数中使用静态数据","datePublished":"2017-06-25T00:00:00.000Z","dateModified":"2017-06-25T00:00:00.000Z","description":"在 JavaScript 中实现类似 C++函数中静态数据，可利用闭包。如通过创建立即调用函数表达式，在内部定义并返回一个函数，该函数可访问内部的变量，避免全局污染。像防抖函数 debounce 就利用了此原理。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170625130219"}},{"title":"C++11 thread","date":"2017-06-17T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍 C++11 的线程相关内容，包括线程创建（std::thread）、互斥量（多种类型）、线程间同步（条件变量）、线程池等。通过代码示例详细展示其用法和注意事项，如独占式互斥量加解锁、递归式互斥量、允许超时的互斥量及避免死锁等。  \r","type":"Blog","readingTime":{"text":"12 min read","minutes":11.78,"time":706800,"words":2356},"slug":"2017/20170617112259","path":"blog/2017/20170617112259","filePath":"blog/2017/20170617112259.mdx","toc":[{"value":"线程的创建","url":"#线程的创建","depth":1},{"value":"互斥量","url":"#互斥量","depth":1},{"value":"独占式互斥量","url":"#独占式互斥量","depth":2},{"value":"递归式互斥量","url":"#递归式互斥量","depth":2},{"value":"允许超时的互斥量","url":"#允许超时的互斥量","depth":2},{"value":"线程间同步，条件变量","url":"#线程间同步条件变量","depth":1},{"value":"线程池","url":"#线程池","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++11 thread","datePublished":"2017-06-17T00:00:00.000Z","dateModified":"2017-06-17T00:00:00.000Z","description":"介绍 C++11 的线程相关内容，包括线程创建（std::thread）、互斥量（多种类型）、线程间同步（条件变量）、线程池等。通过代码示例详细展示其用法和注意事项，如独占式互斥量加解锁、递归式互斥量、允许超时的互斥量及避免死锁等。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170617112259"}},{"title":"QLayout  Attempting to add QLayout","date":"2017-06-17T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.655,"time":39300,"words":131},"slug":"2017/20171210125831","path":"blog/2017/20171210125831","filePath":"blog/2017/20171210125831.mdx","toc":[{"value":"解决方法：","url":"#解决方法","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QLayout  Attempting to add QLayout","datePublished":"2017-06-17T00:00:00.000Z","dateModified":"2017-06-17T00:00:00.000Z","description":"\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125831"}},{"title":"QLabel文本超出显示区域显示...","date":"2017-06-13T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"介绍了能让 QLabel 文本超出显示区域显示为“...”并带 tooltip 的 ElidedLabel 类。通过 paintEvent 处理文本绘制，超出则截断显示，且更新 elided 状态和 tooltip，代码包含类定义及实现。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.335,"time":80100,"words":267},"slug":"2017/20170613010720","path":"blog/2017/20170613010720","filePath":"blog/2017/20170613010720.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QLabel文本超出显示区域显示...","datePublished":"2017-06-13T00:00:00.000Z","dateModified":"2017-06-13T00:00:00.000Z","description":"介绍了能让 QLabel 文本超出显示区域显示为“...”并带 tooltip 的 ElidedLabel 类。通过 paintEvent 处理文本绘制，超出则截断显示，且更新 elided 状态和 tooltip，代码包含类定义及实现。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170613010720"}},{"title":"给QPushButton增加图标并且显示在文本右边","date":"2017-06-13T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"介绍了在 C/C++ 的 Qt 中，给 QPushButton 增加图标并显示在文本右边的方法。通过创建按钮、设置文本、图标及布局方向实现，如上述代码所示。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.045,"time":2700,"words":9},"slug":"2017/20170613011051","path":"blog/2017/20170613011051","filePath":"blog/2017/20170613011051.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"给QPushButton增加图标并且显示在文本右边","datePublished":"2017-06-13T00:00:00.000Z","dateModified":"2017-06-13T00:00:00.000Z","description":"介绍了在 C/C++ 的 Qt 中，给 QPushButton 增加图标并显示在文本右边的方法。通过创建按钮、设置文本、图标及布局方向实现，如上述代码所示。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170613011051"}},{"title":"你必须知道的28个HTML5特征、窍门和技术","date":"2017-06-11T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"介绍 28 个 HTML5 特征、窍门和技术，包括新 Doctype、图形元素、<small>重新定义等，如使用新 Doctype 更便捷，<figure>元素可语义化图片标题等，还提及本地存储、表单特征等，部分技术仅在特定浏览器下效果较好，不少浏览器已支持这些特性。 \r","type":"Blog","readingTime":{"text":"30 min read","minutes":29.61,"time":1776600,"words":5922},"slug":"2017/20170611042521","path":"blog/2017/20170611042521","filePath":"blog/2017/20170611042521.mdx","toc":[{"value":"1. 新的Doctype","url":"#1-新的doctype","depth":1},{"value":"2. 图形元素(The Figure Element )","url":"#2-图形元素the-figure-element-","depth":1},{"value":"3. <small>重新定义","url":"#3-small重新定义","depth":1},{"value":"4. 脚本(scripts)和链接(links)无需type","url":"#4-脚本scripts和链接links无需type","depth":1},{"value":"5. 引号还是不要引号","url":"#5-引号还是不要引号","depth":1},{"value":"6. 内容可编辑","url":"#6-内容可编辑","depth":1},{"value":"7. Email输入(Inputs)","url":"#7-email输入inputs","depth":1},{"value":"8. 占位符(Placeholders)","url":"#8-占位符placeholders","depth":1},{"value":"9. 本地存储(Local Storage)","url":"#9-本地存储local-storage","depth":1},{"value":"10. 语义的Header和Footer","url":"#10-语义的header和footer","depth":1},{"value":"11. 更多HTML5表单特征(More HTML5 Form Features )","url":"#11-更多html5表单特征more-html5-form-features-","depth":1},{"value":"12. IE和HTML5(Internet Explorer and HTML5)","url":"#12-ie和html5internet-explorer-and-html5","depth":1},{"value":"13. 文档某一部分的信息(hgroup)","url":"#13-文档某一部分的信息hgroup","depth":1},{"value":"14. 必要的属性(Required Attribute )","url":"#14-必要的属性required-attribute-","depth":1},{"value":"15. Autofocus属性","url":"#15-autofocus属性","depth":1},{"value":"16. Audio支持","url":"#16-audio支持","depth":1},{"value":"17. Video支持","url":"#17-video支持","depth":1},{"value":"18. 视频预载(Preload Videos)","url":"#18-视频预载preload-videos","depth":1},{"value":"19. 显示控制条","url":"#19-显示控制条","depth":1},{"value":"20. 正则表达式","url":"#20-正则表达式","depth":1},{"value":"21. 属性支持检测","url":"#21-属性支持检测","depth":1},{"value":"22. mark元素(Mark Element )","url":"#22-mark元素mark-element-","depth":1},{"value":"23. 什么时候使用div","url":"#23-什么时候使用div","depth":1},{"value":"24. 什么可以开始立即使用","url":"#24-什么可以开始立即使用","depth":1},{"value":"25. 哪些不是HTML5(What is Not HTML5)","url":"#25-哪些不是html5what-is-not-html5","depth":1},{"value":"26. data属性(The Data Attribute)","url":"#26-data属性the-data-attribute","depth":1},{"value":"27. Output元素","url":"#27-output元素","depth":1},{"value":"28. 使用区域input创建滑块(Create Sliders with the Range Input)","url":"#28-使用区域input创建滑块create-sliders-with-the-range-input","depth":1},{"value":"第一步：标签","url":"#第一步标签","depth":2},{"value":"第二步：CSS","url":"#第二步css","depth":2},{"value":"第三步：JavaScript","url":"#第三步javascript","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"你必须知道的28个HTML5特征、窍门和技术","datePublished":"2017-06-11T00:00:00.000Z","dateModified":"2017-06-11T00:00:00.000Z","description":"介绍 28 个 HTML5 特征、窍门和技术，包括新 Doctype、图形元素、<small>重新定义等，如使用新 Doctype 更便捷，<figure>元素可语义化图片标题等，还提及本地存储、表单特征等，部分技术仅在特定浏览器下效果较好，不少浏览器已支持这些特性。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170611042521"}},{"title":"Qt 大数据列表展示","date":"2017-06-10T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"介绍 Qt 大数据列表展示，用 QListWidget 等自定义子 widget 展示数据时易慢耗内存，原理是重用隐藏 widget 。组件有父 widget 和滚动条，基本方法有 showEvent 等，通过 m_widgets 缓存 widget ，重点是刷新数据到 widget ，文末有源码及展示效果。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.995,"time":299700,"words":999},"slug":"2017/20170610102949","path":"blog/2017/20170610102949","filePath":"blog/2017/20170610102949.mdx","toc":[{"value":"原理：","url":"#原理","depth":3},{"value":"组件组成","url":"#组件组成","depth":3},{"value":"基本方法","url":"#基本方法","depth":3},{"value":"怎样重用子widget","url":"#怎样重用子widget","depth":3},{"value":"重点是刷新数据到widget上","url":"#重点是刷新数据到widget上","depth":3},{"value":"结尾","url":"#结尾","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt 大数据列表展示","datePublished":"2017-06-10T00:00:00.000Z","dateModified":"2017-06-10T00:00:00.000Z","description":"介绍 Qt 大数据列表展示，用 QListWidget 等自定义子 widget 展示数据时易慢耗内存，原理是重用隐藏 widget 。组件有父 widget 和滚动条，基本方法有 showEvent 等，通过 m_widgets 缓存 widget ，重点是刷新数据到 widget ，文末有源码及展示效果。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170610102949"}},{"title":"方形图片使用QLabel显示成圆形","date":"2017-06-10T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"介绍了方形图片用 QLabel 显示成圆形的代码。通过自定义的 MaskLabel 类，在 paintEvent 中设置绘图参数，用 QPainterPath 画椭圆作为裁剪路径，实现方形图片的圆形显示。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.39,"time":23400,"words":78},"slug":"2017/20170610103055","path":"blog/2017/20170610103055","filePath":"blog/2017/20170610103055.mdx","toc":[{"value":"方形图片使用QLabel显示成圆形","url":"#方形图片使用qlabel显示成圆形","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"方形图片使用QLabel显示成圆形","datePublished":"2017-06-10T00:00:00.000Z","dateModified":"2017-06-10T00:00:00.000Z","description":"介绍了方形图片用 QLabel 显示成圆形的代码。通过自定义的 MaskLabel 类，在 paintEvent 中设置绘图参数，用 QPainterPath 画椭圆作为裁剪路径，实现方形图片的圆形显示。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170610103055"}},{"title":"Qt设置窗口标题和exe图标","date":"2017-06-10T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"文章介绍 Qt 设置窗口标题和 exe 图标，以工程名“joke”为例，给窗口标题设图简单，需创建 QApplication 和 Dialog 等，给 exe 设图需新建 joke.rc 并粘贴特定文本，加入 pro 文件，在 vs 中加入 rc 文件，执行 qmake 后构建即可。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.775,"time":46500,"words":155},"slug":"2017/20170610112113","path":"blog/2017/20170610112113","filePath":"blog/2017/20170610112113.mdx","toc":[{"value":"给窗口标题设置图标比较简单","url":"#给窗口标题设置图标比较简单","depth":1},{"value":"给exe设置图标","url":"#给exe设置图标","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt设置窗口标题和exe图标","datePublished":"2017-06-10T00:00:00.000Z","dateModified":"2017-06-10T00:00:00.000Z","description":"文章介绍 Qt 设置窗口标题和 exe 图标，以工程名“joke”为例，给窗口标题设图简单，需创建 QApplication 和 Dialog 等，给 exe 设图需新建 joke.rc 并粘贴特定文本，加入 pro 文件，在 vs 中加入 rc 文件，执行 qmake 后构建即可。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170610112113"}},{"title":"windows任务栏高亮","date":"2017-06-10T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"此代码实现了 Windows 任务栏高亮功能。通过`startAlert`函数可设置高亮持续时间和超时时间来闪烁任务栏，`stopAlert`函数则停止高亮。利用`FLASHWINFO`结构体和`FlashWindowEx`函数来完成相关操作。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.3,"time":18000,"words":60},"slug":"2017/20170610113527","path":"blog/2017/20170610113527","filePath":"blog/2017/20170610113527.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"windows任务栏高亮","datePublished":"2017-06-10T00:00:00.000Z","dateModified":"2017-06-10T00:00:00.000Z","description":"此代码实现了 Windows 任务栏高亮功能。通过`startAlert`函数可设置高亮持续时间和超时时间来闪烁任务栏，`stopAlert`函数则停止高亮。利用`FLASHWINFO`结构体和`FlashWindowEx`函数来完成相关操作。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170610113527"}},{"title":"swift 网络搜索热词排行","date":"2017-06-10T00:00:00.000Z","tags":["Mobile"],"draft":false,"summary":"介绍 swift 网络搜索热词排行相关内容，包括接口使用、库文件、桥接头文件等，还有数据管理、视图控制器等代码示例及 github 地址和截图，点击热搜词可在百度搜索。 \r","type":"Blog","readingTime":{"text":"7 min read","minutes":6.4,"time":384000,"words":1280},"slug":"2017/20170610115119","path":"blog/2017/20170610115119","filePath":"blog/2017/20170610115119.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"swift 网络搜索热词排行","datePublished":"2017-06-10T00:00:00.000Z","dateModified":"2017-06-10T00:00:00.000Z","description":"介绍 swift 网络搜索热词排行相关内容，包括接口使用、库文件、桥接头文件等，还有数据管理、视图控制器等代码示例及 github 地址和截图，点击热搜词可在百度搜索。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170610115119"}},{"title":"Static table views are only valid when embedded in","date":"2017-06-10T00:00:00.000Z","tags":["Mobile"],"draft":false,"summary":"在 UIViewController 中加入 Table View 并设 Content 为 Static Cells 会报错，解决方法为将放置 Table View 改为 Container View 或拖出单独 Table View Controller 并关联，即可成功。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.7,"time":42000,"words":140},"slug":"2017/20170610115154","path":"blog/2017/20170610115154","filePath":"blog/2017/20170610115154.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Static table views are only valid when embedded in","datePublished":"2017-06-10T00:00:00.000Z","dateModified":"2017-06-10T00:00:00.000Z","description":"在 UIViewController 中加入 Table View 并设 Content 为 Static Cells 会报错，解决方法为将放置 Table View 改为 Container View 或拖出单独 Table View Controller 并关联，即可成功。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170610115154"}},{"title":"swift分享到微信","date":"2017-06-10T00:00:00.000Z","tags":["Mobile"],"draft":false,"summary":"介绍 swift 分享到微信的步骤，需申请 AppId 并下载 sdk 导入工程，链接相关库，添加桥接头文件等，还可分享文字、文章到朋友、朋友圈及收藏，调试需装微信，提供 github 地址。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.48,"time":148800,"words":496},"slug":"2017/20170610115226","path":"blog/2017/20170610115226","filePath":"blog/2017/20170610115226.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"swift分享到微信","datePublished":"2017-06-10T00:00:00.000Z","dateModified":"2017-06-10T00:00:00.000Z","description":"介绍 swift 分享到微信的步骤，需申请 AppId 并下载 sdk 导入工程，链接相关库，添加桥接头文件等，还可分享文字、文章到朋友、朋友圈及收藏，调试需装微信，提供 github 地址。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170610115226"}},{"title":"给UITableView增加拷贝","date":"2017-06-10T00:00:00.000Z","tags":["Mobile"],"draft":false,"summary":"文章介绍给 UITableView 增加拷贝功能。通过两个函数实现，一个用于执行拷贝操作（若满足条件则将对应内容的 url 拷贝到粘贴板），另一个用于判断是否可执行拷贝动作，还设置了应显示菜单的条件为 true。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.315,"time":18900,"words":63},"slug":"2017/20170610115256","path":"blog/2017/20170610115256","filePath":"blog/2017/20170610115256.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"给UITableView增加拷贝","datePublished":"2017-06-10T00:00:00.000Z","dateModified":"2017-06-10T00:00:00.000Z","description":"文章介绍给 UITableView 增加拷贝功能。通过两个函数实现，一个用于执行拷贝操作（若满足条件则将对应内容的 url 拷贝到粘贴板），另一个用于判断是否可执行拷贝动作，还设置了应显示菜单的条件为 true。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170610115256"}},{"title":"swift delegate","date":"2017-06-10T00:00:00.000Z","tags":["Mobile"],"draft":false,"summary":"This code shows a Swift delegate example. It defines a `ModelDelegate` protocol with methods. The `Model` class has a delegate property and a `count` variable. The `View` class conforms to the protocol and implements the methods. An instance of `Model` and `View` is created, and the delegate is set. The `count` property is changed, triggering the delegate methods.  \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.42,"time":25200,"words":84},"slug":"2017/20170610115347","path":"blog/2017/20170610115347","filePath":"blog/2017/20170610115347.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"swift delegate","datePublished":"2017-06-10T00:00:00.000Z","dateModified":"2017-06-10T00:00:00.000Z","description":"This code shows a Swift delegate example. It defines a `ModelDelegate` protocol with methods. The `Model` class has a delegate property and a `count` variable. The `View` class conforms to the protocol and implements the methods. An instance of `Model` and `View` is created, and the delegate is set. The `count` property is changed, triggering the delegate methods.  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170610115347"}},{"title":"swift UILabel不显示html标签","date":"2017-06-10T00:00:00.000Z","tags":["Mobile"],"draft":false,"summary":"2017 年 6 月 10 日，关于 swift UILabel 不显示 html 标签的讨论。通过将带 html 标签的文本转成 NSAttributedString 并设置给 label 的 attributedText 来尝试显示，但未成功。  \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.135,"time":8100,"words":27},"slug":"2017/20170610115514","path":"blog/2017/20170610115514","filePath":"blog/2017/20170610115514.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"swift UILabel不显示html标签","datePublished":"2017-06-10T00:00:00.000Z","dateModified":"2017-06-10T00:00:00.000Z","description":"2017 年 6 月 10 日，关于 swift UILabel 不显示 html 标签的讨论。通过将带 html 标签的文本转成 NSAttributedString 并设置给 label 的 attributedText 来尝试显示，但未成功。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170610115514"}},{"title":"swift UITableView cell自适应高度","date":"2017-06-10T00:00:00.000Z","tags":["Mobile"],"draft":false,"summary":"2017 年 6 月 10 日的文章介绍 swift UITableView cell 自适应高度。ios8 支持，需在 viewDidLoad 中设置 estimatedRowHeight 和 rowHeight，在 cellForRowAtIndexPath 中设置 textLabel 的行数和宽度，heightForRowAtIndexPath 设为 UITableViewAutomaticDimension。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.245,"time":14700,"words":49},"slug":"2017/20170610115631","path":"blog/2017/20170610115631","filePath":"blog/2017/20170610115631.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"swift UITableView cell自适应高度","datePublished":"2017-06-10T00:00:00.000Z","dateModified":"2017-06-10T00:00:00.000Z","description":"2017 年 6 月 10 日的文章介绍 swift UITableView cell 自适应高度。ios8 支持，需在 viewDidLoad 中设置 estimatedRowHeight 和 rowHeight，在 cellForRowAtIndexPath 中设置 textLabel 的行数和宽度，heightForRowAtIndexPath 设为 UITableViewAutomaticDimension。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170610115631"}},{"title":"App Transport Security has blocked a cleartext HTTP (http 、、) resource load since it is insecure.","date":"2017-06-10T00:00:00.000Z","tags":["Mobile"],"draft":false,"summary":"2017 年 6 月 10 日，App Transport Security 因不安全阻止了明文 HTTP 资源加载。解决办法有使用 https 协议请求或在 Info.plist 中增加 App Transport Security Settings 子项 Allow Arbitrary Loads 并设为 YES 。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.21,"time":12600,"words":42},"slug":"2017/20171210125825","path":"blog/2017/20171210125825","filePath":"blog/2017/20171210125825.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"App Transport Security has blocked a cleartext HTTP (http 、、) resource load since it is insecure.","datePublished":"2017-06-10T00:00:00.000Z","dateModified":"2017-06-10T00:00:00.000Z","description":"2017 年 6 月 10 日，App Transport Security 因不安全阻止了明文 HTTP 资源加载。解决办法有使用 https 协议请求或在 Info.plist 中增加 App Transport Security Settings 子项 Allow Arbitrary Loads 并设为 YES 。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125825"}},{"title":"网页聊天气泡效果实现","date":"2017-06-03T00:00:00.000Z","tags":["Node.js","Web"],"draft":false,"summary":"介绍网页聊天气泡效果实现，通过 ejs 模板实现收发消息布局，利用 flex 布局和特定样式打造左右对齐气泡，包含头像、名字、聊天内容等部分，文末提供 github 地址。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.85,"time":111000,"words":370},"slug":"2017/20170603082330","path":"blog/2017/20170603082330","filePath":"blog/2017/20170603082330.mdx","toc":[{"value":"模板","url":"#模板","depth":1},{"value":"样式","url":"#样式","depth":1},{"value":"效果图","url":"#效果图","depth":1},{"value":"源码","url":"#源码","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"网页聊天气泡效果实现","datePublished":"2017-06-03T00:00:00.000Z","dateModified":"2017-06-03T00:00:00.000Z","description":"介绍网页聊天气泡效果实现，通过 ejs 模板实现收发消息布局，利用 flex 布局和特定样式打造左右对齐气泡，包含头像、名字、聊天内容等部分，文末提供 github 地址。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170603082330"}},{"title":"Material-UI FontIcon组件使用","date":"2017-05-21T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"material-ui 的 FontIcon 组件含 900 多个系统图标但易显示不出。需下载资源并新建 css 文件设置字体，将其 link 到 html 中，使用方法多样，如`<FontIcon className=\"material-icons\">keyboard_arrow_left</FontIcon>`。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.18,"time":70800,"words":236},"slug":"2017/20170521135020","path":"blog/2017/20170521135020","filePath":"blog/2017/20170521135020.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Material-UI FontIcon组件使用","datePublished":"2017-05-21T00:00:00.000Z","dateModified":"2017-05-21T00:00:00.000Z","description":"material-ui 的 FontIcon 组件含 900 多个系统图标但易显示不出。需下载资源并新建 css 文件设置字体，将其 link 到 html 中，使用方法多样，如`<FontIcon className=\"material-icons\">keyboard_arrow_left</FontIcon>`。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170521135020"}},{"title":"CHROME开发者工具的小技巧","date":"2017-04-25T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"文章介绍 Chrome 开发者工具的小技巧，包括代码格式化、强制 DOM 状态、动画慢放录制、直接编辑网页、网络限速、复制 HTTP 请求、抓带手机图、设置断点及 Console 中的各种技巧和快捷键等，内容丰富实用。 \r","type":"Blog","readingTime":{"text":"9 min read","minutes":8.08,"time":484800,"words":1616},"slug":"2017/20170425014240","path":"blog/2017/20170425014240","filePath":"blog/2017/20170425014240.mdx","toc":[{"value":"代码格式化","url":"#代码格式化","depth":1},{"value":"强制DOM状态","url":"#强制dom状态","depth":1},{"value":"动画","url":"#动画","depth":1},{"value":"直接编辑网页","url":"#直接编辑网页","depth":1},{"value":"网络限速","url":"#网络限速","depth":1},{"value":"复制HTTP请求","url":"#复制http请求","depth":1},{"value":"抓个带手机的图","url":"#抓个带手机的图","depth":1},{"value":"设置断点","url":"#设置断点","depth":1},{"value":"给DOM设置断点","url":"#给dom设置断点","depth":2},{"value":"给XHR和Event Lisener设置断点","url":"#给xhr和event-lisener设置断点","depth":2},{"value":"关于Console中的技巧","url":"#关于console中的技巧","depth":1},{"value":"DOM操作","url":"#dom操作","depth":2},{"value":"Console中的一些函数","url":"#console中的一些函数","depth":2},{"value":"monitor函数","url":"#monitor函数","depth":3},{"value":"copy函数","url":"#copy函数","depth":3},{"value":"inspect函数","url":"#inspect函数","depth":3},{"value":"Console的输出","url":"#console的输出","depth":2},{"value":"关于console对象","url":"#关于console对象","depth":1},{"value":"关于快捷键","url":"#关于快捷键","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"CHROME开发者工具的小技巧","datePublished":"2017-04-25T00:00:00.000Z","dateModified":"2017-04-25T00:00:00.000Z","description":"文章介绍 Chrome 开发者工具的小技巧，包括代码格式化、强制 DOM 状态、动画慢放录制、直接编辑网页、网络限速、复制 HTTP 请求、抓带手机图、设置断点及 Console 中的各种技巧和快捷键等，内容丰富实用。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170425014240"}},{"title":"无法定位程序输入点strnlen于动态链接库msvcrt.dll上(Qt XP)","date":"2017-04-25T00:00:00.000Z","tags":["C/C++","Windows","Qt"],"draft":false,"summary":"Qt 应用在 XP（sp3）系统出现“无法定位程序输入点 strnlen 于动态链接库 msvcrt.dll 上”错误，含 D3Dcompiler_47.dll 和 opengl32sw.dll。可移除前者用后者，或在 QApplication 实例化前加代码强制 XP 不使用前者，参考相关 Qt 文档。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.81,"time":48600,"words":162},"slug":"2017/20170425065856","path":"blog/2017/20170425065856","filePath":"blog/2017/20170425065856.mdx","toc":[{"value":"解决方法1：","url":"#解决方法1","depth":2},{"value":"解决方法2：","url":"#解决方法2","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"无法定位程序输入点strnlen于动态链接库msvcrt.dll上(Qt XP)","datePublished":"2017-04-25T00:00:00.000Z","dateModified":"2017-04-25T00:00:00.000Z","description":"Qt 应用在 XP（sp3）系统出现“无法定位程序输入点 strnlen 于动态链接库 msvcrt.dll 上”错误，含 D3Dcompiler_47.dll 和 opengl32sw.dll。可移除前者用后者，或在 QApplication 实例化前加代码强制 XP 不使用前者，参考相关 Qt 文档。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170425065856"}},{"title":"QWebEngineView支持XP","date":"2017-04-25T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"Qt 应用中 QWebEngineView 在 XP 上有问题，网页内容显示不出且 QtWebEngineProcess.exe 起不来。需下载 5.6.2 版本 Qt 源码编译该文件，用 vs2013 打开相应 project 并设置属性，编译后替换 Qt 自带的可在 XP 上运行。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.11,"time":66600,"words":222},"slug":"2017/20170425083040","path":"blog/2017/20170425083040","filePath":"blog/2017/20170425083040.mdx","toc":[{"value":"下载Qt源码","url":"#下载qt源码","depth":2},{"value":"找到相应的project","url":"#找到相应的project","depth":2},{"value":"设置工程属性","url":"#设置工程属性","depth":2},{"value":"编译","url":"#编译","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QWebEngineView支持XP","datePublished":"2017-04-25T00:00:00.000Z","dateModified":"2017-04-25T00:00:00.000Z","description":"Qt 应用中 QWebEngineView 在 XP 上有问题，网页内容显示不出且 QtWebEngineProcess.exe 起不来。需下载 5.6.2 版本 Qt 源码编译该文件，用 vs2013 打开相应 project 并设置属性，编译后替换 Qt 自带的可在 XP 上运行。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170425083040"}},{"title":"css中position属性(absolute|relative|static|fixed)详解","date":"2017-04-25T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"介绍了 CSS 中 position 属性（absolute、relative、static、fixed）及 z-index 属性。文档流中三种脱离情况及各定位特点，relative 相对自身文档流位置偏移且占文档空间，absolute 依祖先类非 static 定位，fixed 以窗口为原点定位，z-index 定堆叠层次，无 position 定位的元素 z-index 无效。 \r","type":"Blog","readingTime":{"text":"10 min read","minutes":9.25,"time":555000,"words":1850},"slug":"2017/20171210125829","path":"blog/2017/20171210125829","filePath":"blog/2017/20171210125829.mdx","toc":[{"value":"我们先来看看CSS3 Api中对position属性的相关定义","url":"#我们先来看看css3-api中对position属性的相关定义","depth":1},{"value":"什么是文档流？","url":"#什么是文档流","depth":1},{"value":"静态定位(static)","url":"#静态定位static","depth":1},{"value":"相对定位(relative)","url":"#相对定位relative","depth":1},{"value":"初始未定位","url":"#初始未定位","depth":2},{"value":"我们修改first元素的position属性","url":"#我们修改first元素的position属性","depth":2},{"value":"添加margin属性","url":"#添加margin属性","depth":2},{"value":"绝对定位(absoulte)","url":"#绝对定位absoulte","depth":1},{"value":"添加absoulte属性","url":"#添加absoulte属性","depth":2},{"value":"在absoulte定位中添加margin / padding属性","url":"#在absoulte定位中添加margin--padding属性","depth":2},{"value":"固定定位(fixed)","url":"#固定定位fixed","depth":1},{"value":"z-index属性","url":"#z-index属性","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"css中position属性(absolute|relative|static|fixed)详解","datePublished":"2017-04-25T00:00:00.000Z","dateModified":"2017-04-25T00:00:00.000Z","description":"介绍了 CSS 中 position 属性（absolute、relative、static、fixed）及 z-index 属性。文档流中三种脱离情况及各定位特点，relative 相对自身文档流位置偏移且占文档空间，absolute 依祖先类非 static 定位，fixed 以窗口为原点定位，z-index 定堆叠层次，无 position 定位的元素 z-index 无效。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125829"}},{"title":"bootstrap有省略点才显示tooltip","date":"2017-04-19T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"在 bootstrap 中，可通过给 td 标签添加特定类使长文本显示省略点，同时用 bootstrap 的 tooltip 展示内容。但存在不管有无省略点都显示 tooltip 的问题，可通过 js 代码在鼠标进入时添加 tooltip 属性，离开时去掉来解决。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.19,"time":71400,"words":238},"slug":"2017/20170419051236","path":"blog/2017/20170419051236","filePath":"blog/2017/20170419051236.mdx","toc":[{"value":"让太长的文本显示省略点","url":"#让太长的文本显示省略点","depth":2},{"value":"增加tooltip","url":"#增加tooltip","depth":2},{"value":"实现方法","url":"#实现方法","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"bootstrap有省略点才显示tooltip","datePublished":"2017-04-19T00:00:00.000Z","dateModified":"2017-04-19T00:00:00.000Z","description":"在 bootstrap 中，可通过给 td 标签添加特定类使长文本显示省略点，同时用 bootstrap 的 tooltip 展示内容。但存在不管有无省略点都显示 tooltip 的问题，可通过 js 代码在鼠标进入时添加 tooltip 属性，离开时去掉来解决。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170419051236"}},{"title":"常见排序算法","date":"2017-04-17T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"本文介绍了常见排序算法，包括插入排序、及时终止的冒泡排序、终止不必要的选择排序和快速排序。分别给出了各算法的代码实现，通过模板函数提高通用性。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.155,"time":129300,"words":431},"slug":"2017/20170417095152","path":"blog/2017/20170417095152","filePath":"blog/2017/20170417095152.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"常见排序算法","datePublished":"2017-04-17T00:00:00.000Z","dateModified":"2017-04-17T00:00:00.000Z","description":"本文介绍了常见排序算法，包括插入排序、及时终止的冒泡排序、终止不必要的选择排序和快速排序。分别给出了各算法的代码实现，通过模板函数提高通用性。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170417095152"}},{"title":"类模板之单链表","date":"2017-04-17T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"介绍了类模板之单链表，包含 Chain.h 中定义的模板类 ChainNode 和 Chain，以及 Chain.cpp 中实现的各种函数，如构造、析构、插入、删除等操作，最后在 main.cpp 中进行了测试。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.93,"time":175800,"words":586},"slug":"2017/20170417100056","path":"blog/2017/20170417100056","filePath":"blog/2017/20170417100056.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"类模板之单链表","datePublished":"2017-04-17T00:00:00.000Z","dateModified":"2017-04-17T00:00:00.000Z","description":"介绍了类模板之单链表，包含 Chain.h 中定义的模板类 ChainNode 和 Chain，以及 Chain.cpp 中实现的各种函数，如构造、析构、插入、删除等操作，最后在 main.cpp 中进行了测试。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170417100056"}},{"title":"统计程序实例的个数","date":"2017-04-17T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"此为统计程序实例个数的代码，在 Windows 下用 C/C++编写。通过共享数据段和特定消息，实现应用程序知晓自身运行实例个数，在 WinMain 函数中进行相关操作和消息传递。  \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.825,"time":49500,"words":165},"slug":"2017/20170417100443","path":"blog/2017/20170417100443","filePath":"blog/2017/20170417100443.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"统计程序实例的个数","datePublished":"2017-04-17T00:00:00.000Z","dateModified":"2017-04-17T00:00:00.000Z","description":"此为统计程序实例个数的代码，在 Windows 下用 C/C++编写。通过共享数据段和特定消息，实现应用程序知晓自身运行实例个数，在 WinMain 函数中进行相关操作和消息传递。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170417100443"}},{"title":"用内存映射的方式在文件末尾追加一个hello","date":"2017-04-17T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"此 C++代码通过 Windows API 在文件末尾追加“hello”。先创建文件句柄，获取文件大小，创建文件映射对象，获取映射视图，将“hello”复制到文件末尾，最后解除映射和关闭句柄，实现了在文件末尾追加内容的功能。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.48,"time":28800,"words":96},"slug":"2017/20170417100830","path":"blog/2017/20170417100830","filePath":"blog/2017/20170417100830.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"用内存映射的方式在文件末尾追加一个hello","datePublished":"2017-04-17T00:00:00.000Z","dateModified":"2017-04-17T00:00:00.000Z","description":"此 C++代码通过 Windows API 在文件末尾追加“hello”。先创建文件句柄，获取文件大小，创建文件映射对象，获取映射视图，将“hello”复制到文件末尾，最后解除映射和关闭句柄，实现了在文件末尾追加内容的功能。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170417100830"}},{"title":"6个故事：都体会了你就是营销超人！","date":"2017-04-17T00:00:00.000Z","tags":["Life"],"draft":false,"summary":"本文通过六个故事探讨了营销、质量管理与工作态度的重要性。故事涵盖了从顾客反馈中持续改进、遵守规则、认真对待客户投诉、制定和执行工作标准、培训员工以及追求100%的产品合格率等主题。每个故事都强调了细节决定成败，以及在工作中保持严谨态度和以客户为中心的重要性。\r","type":"Blog","readingTime":{"text":"20 min read","minutes":19.68,"time":1180800,"words":3936},"slug":"2017/20170417114056","path":"blog/2017/20170417114056","filePath":"blog/2017/20170417114056.mdx","toc":[{"value":"1. 割草的男孩(哲理故事)","url":"#1-割草的男孩哲理故事","depth":3},{"value":"感想：","url":"#感想","depth":4},{"value":"2. 德国人的规则","url":"#2-德国人的规则","depth":3},{"value":"3. 为什么买香草冰淇淋汽车就会秀逗的故事？","url":"#3-为什么买香草冰淇淋汽车就会秀逗的故事","depth":3},{"value":"读后感想","url":"#读后感想","depth":4},{"value":"4. 小和尚撞钟","url":"#4-小和尚撞钟","depth":3},{"value":"感想：","url":"#感想-1","depth":4},{"value":"5. 猴子与香蕉","url":"#5-猴子与香蕉","depth":3},{"value":"体会与感想：","url":"#体会与感想","depth":4},{"value":"6. 降落伞的真实故事","url":"#6-降落伞的真实故事","depth":3},{"value":"一点体会：","url":"#一点体会","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"6个故事：都体会了你就是营销超人！","datePublished":"2017-04-17T00:00:00.000Z","dateModified":"2017-04-17T00:00:00.000Z","description":"本文通过六个故事探讨了营销、质量管理与工作态度的重要性。故事涵盖了从顾客反馈中持续改进、遵守规则、认真对待客户投诉、制定和执行工作标准、培训员工以及追求100%的产品合格率等主题。每个故事都强调了细节决定成败，以及在工作中保持严谨态度和以客户为中心的重要性。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170417114056"}},{"title":"Robomongo连接远程MongoDB数据库","date":"2017-04-17T00:00:00.000Z","tags":["Windows","MongoDB","Database"],"draft":false,"summary":"文章介绍 Robomongo 连接远程 MongoDB 数据库的步骤，包括修改远程服务器 mongodb 配置、创建管理员用户并重启服务，还展示了 Robomongo 连接远程服务的截图以及备份还原数据库的方法，如 mongodump 和 mongorestore。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.535,"time":32100,"words":107},"slug":"2017/20170417144947","path":"blog/2017/20170417144947","filePath":"blog/2017/20170417144947.mdx","toc":[{"value":"修改远程服务器上mongodb配置","url":"#修改远程服务器上mongodb配置","depth":2},{"value":"创建管理员用户","url":"#创建管理员用户","depth":2},{"value":"Robomongo连接远程mongodb服务","url":"#robomongo连接远程mongodb服务","depth":2},{"value":"备份还原数据库","url":"#备份还原数据库","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Robomongo连接远程MongoDB数据库","datePublished":"2017-04-17T00:00:00.000Z","dateModified":"2017-04-17T00:00:00.000Z","description":"文章介绍 Robomongo 连接远程 MongoDB 数据库的步骤，包括修改远程服务器 mongodb 配置、创建管理员用户并重启服务，还展示了 Robomongo 连接远程服务的截图以及备份还原数据库的方法，如 mongodump 和 mongorestore。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170417144947"}},{"title":"多文件统计字频","date":"2017-04-16T00:00:00.000Z","tags":["C/C++","Windows"],"draft":false,"summary":"本文介绍多文件统计字频，有 60 个文件如 zipin1.txt 到 zipin60.txt，格式相同词频不同。通过 C++代码实现将各文件相同词语词频相加并写至 main.txt，代码中定义 Word 类，在构造函数和更新函数中处理文件数据，最后输出结果，计算耗时。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.575,"time":94500,"words":315},"slug":"2017/20170416094802","path":"blog/2017/20170416094802","filePath":"blog/2017/20170416094802.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"多文件统计字频","datePublished":"2017-04-16T00:00:00.000Z","dateModified":"2017-04-16T00:00:00.000Z","description":"本文介绍多文件统计字频，有 60 个文件如 zipin1.txt 到 zipin60.txt，格式相同词频不同。通过 C++代码实现将各文件相同词语词频相加并写至 main.txt，代码中定义 Word 类，在构造函数和更新函数中处理文件数据，最后输出结果，计算耗时。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170416094802"}},{"title":"类模板之队列","date":"2017-04-16T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"这是关于类模板之队列的代码。定义了`Queue`类模板，包含构造、析构、判断空满、获取首尾元素及添加删除元素等操作。在`main`函数中创建`Queue<int>`对象并进行操作演示。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.235,"time":134100,"words":447},"slug":"2017/20170416095256","path":"blog/2017/20170416095256","filePath":"blog/2017/20170416095256.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"类模板之队列","datePublished":"2017-04-16T00:00:00.000Z","dateModified":"2017-04-16T00:00:00.000Z","description":"这是关于类模板之队列的代码。定义了`Queue`类模板，包含构造、析构、判断空满、获取首尾元素及添加删除元素等操作。在`main`函数中创建`Queue<int>`对象并进行操作演示。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170416095256"}},{"title":"The Road Not Taken（未选择的路）","date":"2017-04-16T00:00:00.000Z","tags":["Life"],"draft":false,"summary":"《The Road Not Taken》写于 2017 年 4 月 16 日，借自然路喻人生路，表明人生只能选其一需慎重，莫随波逐流要独立思考。清晨两条路落叶满地未被踏，诗人选少有人走的路，决定一生道路，意义深远。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.325,"time":139500,"words":465},"slug":"2017/20170416095840","path":"blog/2017/20170416095840","filePath":"blog/2017/20170416095840.mdx","toc":[{"value":"The Road Not Taken by Robert Frost （弗罗斯特）","url":"#the-road-not-taken-byrobert-frost弗罗斯特","depth":3},{"value":"writen by Robert Lee Frostsai.","url":"#writen-by-robert-lee-frostsai","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Road Not Taken（未选择的路）","datePublished":"2017-04-16T00:00:00.000Z","dateModified":"2017-04-16T00:00:00.000Z","description":"《The Road Not Taken》写于 2017 年 4 月 16 日，借自然路喻人生路，表明人生只能选其一需慎重，莫随波逐流要独立思考。清晨两条路落叶满地未被踏，诗人选少有人走的路，决定一生道路，意义深远。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170416095840"}},{"title":"遍历文件夹下的所有文件","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"此代码为获取指定文件夹下所有.txt 文件的名称及创建时间。通过`FindFirstFile`和`FindNextFile`函数遍历文件夹，将文件名存储在数组中并返回文件数量，最后关闭查找句柄。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.295,"time":17700,"words":59},"slug":"2017/20170415040652","path":"blog/2017/20170415040652","filePath":"blog/2017/20170415040652.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"遍历文件夹下的所有文件","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"此代码为获取指定文件夹下所有.txt 文件的名称及创建时间。通过`FindFirstFile`和`FindNextFile`函数遍历文件夹，将文件名存储在数组中并返回文件数量，最后关闭查找句柄。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415040652"}},{"title":"GDIPLUS环境初始化以及与GDI结合实现双缓冲","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"介绍了在 Windows 的 C/C++中，通过初始化 gdiplus 环境，定义成员变量，在构造和析构函数中进行相应操作，实现 Gdiplus 与 GDI 混合的双缓冲代码，包括创建兼容 DC 和位图等操作。迁移于 2011 - 05 - 08。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.655,"time":39300,"words":131},"slug":"2017/20170415040929","path":"blog/2017/20170415040929","filePath":"blog/2017/20170415040929.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"GDIPLUS环境初始化以及与GDI结合实现双缓冲","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"介绍了在 Windows 的 C/C++中，通过初始化 gdiplus 环境，定义成员变量，在构造和析构函数中进行相应操作，实现 Gdiplus 与 GDI 混合的双缓冲代码，包括创建兼容 DC 和位图等操作。迁移于 2011 - 05 - 08。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415040929"}},{"title":"WTL 给一个对话框添加垂直滚动条","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"介绍给对话框添加垂直滚动条的方法，通过消息映射宏、OnInitDialog 初始化及响应 WM_VSCROLL、WM_SIZE、WM_MOUSEWHEEL 等消息来实现，包括各消息处理函数的具体逻辑。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.385,"time":83100,"words":277},"slug":"2017/20170415041123","path":"blog/2017/20170415041123","filePath":"blog/2017/20170415041123.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL 给一个对话框添加垂直滚动条","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"介绍给对话框添加垂直滚动条的方法，通过消息映射宏、OnInitDialog 初始化及响应 WM_VSCROLL、WM_SIZE、WM_MOUSEWHEEL 等消息来实现，包括各消息处理函数的具体逻辑。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415041123"}},{"title":"WTL CHyperLink类的用法","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"介绍 WTL CHyperLink 类用法，需含 atlctrlx.h 头文件，声明变量并在 OnInitDialog 函数中进行子类化等操作，在消息映射宏中响应事件，可实现点击链接打开指定网页。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.435,"time":26100,"words":87},"slug":"2017/20170415041904","path":"blog/2017/20170415041904","filePath":"blog/2017/20170415041904.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL CHyperLink类的用法","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"介绍 WTL CHyperLink 类用法，需含 atlctrlx.h 头文件，声明变量并在 OnInitDialog 函数中进行子类化等操作，在消息映射宏中响应事件，可实现点击链接打开指定网页。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415041904"}},{"title":"INI文件操作类","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"这是一个 C/C++ 的 INI 文件操作类`CIniFile`，提供了获取和设置 INI 文件中值的各种方法，如获取字符串、整型数值、坐标等，以及写入、删除节等操作。  \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.745,"time":104700,"words":349},"slug":"2017/20170415042007","path":"blog/2017/20170415042007","filePath":"blog/2017/20170415042007.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"INI文件操作类","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"这是一个 C/C++ 的 INI 文件操作类`CIniFile`，提供了获取和设置 INI 文件中值的各种方法，如获取字符串、整型数值、坐标等，以及写入、删除节等操作。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415042007"}},{"title":"WTL自定义的常用类","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"介绍了 WTL 自定义的常用类，包括设置背景图片的`CBitmapBkgnd`类、设置背景颜色及字体颜色的`CCtrlColor`类、自定义静态文本控件的`CMyStatic`类及`CCoolLabel`类，详细说明了各类的功能及用法。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.965,"time":297900,"words":993},"slug":"2017/20170415042234","path":"blog/2017/20170415042234","filePath":"blog/2017/20170415042234.mdx","toc":[{"value":"设置背景图片","url":"#设置背景图片","depth":1},{"value":"设置背景颜色以及字体颜色","url":"#设置背景颜色以及字体颜色","depth":1},{"value":"自定义静态文本控件","url":"#自定义静态文本控件","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL自定义的常用类","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"介绍了 WTL 自定义的常用类，包括设置背景图片的`CBitmapBkgnd`类、设置背景颜色及字体颜色的`CCtrlColor`类、自定义静态文本控件的`CMyStatic`类及`CCoolLabel`类，详细说明了各类的功能及用法。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415042234"}},{"title":"WTL对话框应用程序常用头文件","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"文章介绍 WTL 对话框应用程序常用头文件，包括提前声明 CString 类的 _WTL_USE_CSTRING，以及 atlbase、atlapp 等多个用于基本类、窗口类、数据交换类等的头文件，方便开发。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.675,"time":40500,"words":135},"slug":"2017/20170415042403","path":"blog/2017/20170415042403","filePath":"blog/2017/20170415042403.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL对话框应用程序常用头文件","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"文章介绍 WTL 对话框应用程序常用头文件，包括提前声明 CString 类的 _WTL_USE_CSTRING，以及 atlbase、atlapp 等多个用于基本类、窗口类、数据交换类等的头文件，方便开发。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415042403"}},{"title":"实现无标题栏对话框的拖动","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"文章介绍实现无标题栏对话框拖动的方法。有两种方案，常规思路繁琐且需处理诸多细节，第二种通过处理 WM_NCHITTEST 消息，在客户区模仿标题栏拖动行为实现，代码简单易理解，对话框其他对象照常工作。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.765,"time":285900,"words":953},"slug":"2017/20170415042656","path":"blog/2017/20170415042656","filePath":"blog/2017/20170415042656.mdx","toc":[{"value":"实现方法","url":"#实现方法","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"实现无标题栏对话框的拖动","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"文章介绍实现无标题栏对话框拖动的方法。有两种方案，常规思路繁琐且需处理诸多细节，第二种通过处理 WM_NCHITTEST 消息，在客户区模仿标题栏拖动行为实现，代码简单易理解，对话框其他对象照常工作。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415042656"}},{"title":"WTL IWebBrowser2调用网页中javascript函数","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"文章介绍通过 WTL 的 IWebBrowser2 调用网页中 javascript 函数。给出简单含 js 网页代码，及相关 WebBrowser ActiveX 控件成员变量等操作，在 OnInitDialog 中导航到网页，OnOk 函数中测试执行 js 函数，还给出 WtlCallJavascript 函数，运行后可实现相应功能。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.435,"time":86100,"words":287},"slug":"2017/20170415043044","path":"blog/2017/20170415043044","filePath":"blog/2017/20170415043044.mdx","toc":[{"value":"简单的含有js的网页","url":"#简单的含有js的网页","depth":1},{"value":"WebBrowser ActiveX控件成员变量","url":"#webbrowser-activex控件成员变量","depth":1},{"value":"在OnInitDialog中","url":"#在oninitdialog中","depth":1},{"value":"在OnOk函数里测试","url":"#在onok函数里测试","depth":1},{"value":"上面需要的函数","url":"#上面需要的函数","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL IWebBrowser2调用网页中javascript函数","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"文章介绍通过 WTL 的 IWebBrowser2 调用网页中 javascript 函数。给出简单含 js 网页代码，及相关 WebBrowser ActiveX 控件成员变量等操作，在 OnInitDialog 中导航到网页，OnOk 函数中测试执行 js 函数，还给出 WtlCallJavascript 函数，运行后可实现相应功能。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415043044"}},{"title":"WTL 通过IWebBrowser2接口使WebBrowser控件在自己的窗口打开网页","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"在 WTL 中，为使 WebBrowser 控件在自己窗口打开网页，需添加 IWebBrowser2 控件，创建时勾选相关选项并插入控件。通过代码实现运行后打开默认网页及解决同一窗口打开网页问题，还需处理编译错误和运行时响应事件等。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.24,"time":134400,"words":448},"slug":"2017/20170415043358","path":"blog/2017/20170415043358","filePath":"blog/2017/20170415043358.mdx","toc":[{"value":"添加IWebBrowser2控件","url":"#添加iwebbrowser2控件","depth":2},{"value":"让程序运行后打开一个默认网页","url":"#让程序运行后打开一个默认网页","depth":2},{"value":"解决在同一个窗口打开网页的问题","url":"#解决在同一个窗口打开网页的问题","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL 通过IWebBrowser2接口使WebBrowser控件在自己的窗口打开网页","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"在 WTL 中，为使 WebBrowser 控件在自己窗口打开网页，需添加 IWebBrowser2 控件，创建时勾选相关选项并插入控件。通过代码实现运行后打开默认网页及解决同一窗口打开网页问题，还需处理编译错误和运行时响应事件等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415043358"}},{"title":"SOCKET中宽字符问题","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"本文记录了在看孙鑫老师 vc++16 课聊天程序视频教程时遇到的两个 SOCKET 宽字符问题及解决方法。一是从 ip 地址控件获取值经转换后接收端显示乱码，通过 MultiByteToWideChar 转换为宽字符解决；二是 WSABUF 中 buf 只能接受 char*，需强制转换。作者表示对 SOCKET 宽字符处理仍需努力。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.97,"time":118200,"words":394},"slug":"2017/20170415043626","path":"blog/2017/20170415043626","filePath":"blog/2017/20170415043626.mdx","toc":[{"value":"从ip地址控件上获取的值经过inet_ntoa转换为网络字节序后在接收端显示的时候是乱码","url":"#从ip地址控件上获取的值经过inet_ntoa转换为网络字节序后在接收端显示的时候是乱码","depth":2},{"value":"WSABUF中的buf只能接受char*， 而我们获取的是wchar_t","url":"#wsabuf中的buf只能接受char-而我们获取的是wchar_t","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOCKET中宽字符问题","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"本文记录了在看孙鑫老师 vc++16 课聊天程序视频教程时遇到的两个 SOCKET 宽字符问题及解决方法。一是从 ip 地址控件获取值经转换后接收端显示乱码，通过 MultiByteToWideChar 转换为宽字符解决；二是 WSABUF 中 buf 只能接受 char*，需强制转换。作者表示对 SOCKET 宽字符处理仍需努力。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415043626"}},{"title":"表驱动法介绍 （简单易懂）","date":"2017-04-15T00:00:00.000Z","tags":["C/C++","Design"],"draft":false,"summary":"介绍表驱动法及函数指针应用。用表驱动法可简化获取每月天数的代码，函数指针可用于表驱动中，如处理不同 Event 的代码，通过定义结构体和表来实现更精致灵活的代码。但要注意函数指针的致命缺点，使用时需小心“类型陷阱”。 \r","type":"Blog","readingTime":{"text":"10 min read","minutes":9.14,"time":548400,"words":1828},"slug":"2017/20170415045922","path":"blog/2017/20170415045922","filePath":"blog/2017/20170415045922.mdx","toc":[{"value":"什么是表驱动方法","url":"#什么是表驱动方法","depth":2},{"value":"函数指针在表驱动方法中的应用","url":"#函数指针在表驱动方法中的应用","depth":2},{"value":"总结","url":"#总结","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"表驱动法介绍 （简单易懂）","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"介绍表驱动法及函数指针应用。用表驱动法可简化获取每月天数的代码，函数指针可用于表驱动中，如处理不同 Event 的代码，通过定义结构体和表来实现更精致灵活的代码。但要注意函数指针的致命缺点，使用时需小心“类型陷阱”。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415045922"}},{"title":"windows下进程间通信方式介绍","date":"2017-04-15T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"介绍 Windows 下进程间通信方式，包括文件映射、共享内存等 10 种。阐述各方式特点，如文件映射可共享数据但限于本地；命名管道可跨进程及计算机通信等。开发者需考虑应用环境选择，文末给出多种选择方案及考虑因素。作者李志刚等。 \r","type":"Blog","readingTime":{"text":"18 min read","minutes":17.525,"time":1051500,"words":3505},"slug":"2017/20170415050931","path":"blog/2017/20170415050931","filePath":"blog/2017/20170415050931.mdx","toc":[{"value":"进程与进程通信","url":"#进程与进程通信","depth":1},{"value":"进程通信方法","url":"#进程通信方法","depth":1},{"value":"文件映射","url":"#文件映射","depth":2},{"value":"共享内存","url":"#共享内存","depth":2},{"value":"匿名管道","url":"#匿名管道","depth":2},{"value":"命名管道","url":"#命名管道","depth":2},{"value":"邮件槽","url":"#邮件槽","depth":2},{"value":"剪贴板","url":"#剪贴板","depth":2},{"value":"动态数据交换","url":"#动态数据交换","depth":2},{"value":"对象连接与嵌入","url":"#对象连接与嵌入","depth":2},{"value":"动态连接库","url":"#动态连接库","depth":2},{"value":"远程过程调用","url":"#远程过程调用","depth":2},{"value":"NetBios函数","url":"#netbios函数","depth":2},{"value":"Sockets","url":"#sockets","depth":2},{"value":"WM_COPYDATA消息","url":"#wm_copydata消息","depth":2},{"value":"结束语","url":"#结束语","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"windows下进程间通信方式介绍","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"介绍 Windows 下进程间通信方式，包括文件映射、共享内存等 10 种。阐述各方式特点，如文件映射可共享数据但限于本地；命名管道可跨进程及计算机通信等。开发者需考虑应用环境选择，文末给出多种选择方案及考虑因素。作者李志刚等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415050931"}},{"title":"STL 学习资料","date":"2017-04-15T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"STL 学习资料涵盖多种容器及相关内容，如 STL 介绍、stack 等特殊容器共同点、vector 等容器特点及使用区别、map 及 hash_map、set 等，还提及 bitset 用于处理二进制位有序集，各容器在存储、访问、操作等方面有不同特性。 \r","type":"Blog","readingTime":{"text":"15 min read","minutes":14.215,"time":852900,"words":2843},"slug":"2017/20170415051918","path":"blog/2017/20170415051918","filePath":"blog/2017/20170415051918.mdx","toc":[{"value":"什么是STL？","url":"#什么是stl","depth":2},{"value":"stack,queue,priority_queue的相同点","url":"#stackqueuepriority_queue的相同点","depth":2},{"value":"vector","url":"#vector","depth":2},{"value":"优点：","url":"#优点","depth":3},{"value":"缺点：","url":"#缺点","depth":3},{"value":"list","url":"#list","depth":2},{"value":"deque","url":"#deque","depth":2},{"value":"map","url":"#map","depth":2},{"value":"hash_map","url":"#hash_map","depth":2},{"value":"set,multiset","url":"#setmultiset","depth":2},{"value":"bitset","url":"#bitset","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"STL 学习资料","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"STL 学习资料涵盖多种容器及相关内容，如 STL 介绍、stack 等特殊容器共同点、vector 等容器特点及使用区别、map 及 hash_map、set 等，还提及 bitset 用于处理二进制位有序集，各容器在存储、访问、操作等方面有不同特性。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415051918"}},{"title":"内存对齐 - 求结构体大小","date":"2017-04-15T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"文章介绍内存对齐原因（平台、性能）及规则，通过例子说明结构体大小计算。如 32 位机器上不同结构体示例，还提及","type":"Blog","readingTime":{"text":"4 min read","minutes":3.955,"time":237300,"words":791},"slug":"2017/20170415052657","path":"blog/2017/20170415052657","filePath":"blog/2017/20170415052657.mdx","toc":[{"value":"内存对齐的原因","url":"#内存对齐的原因","depth":2},{"value":"内存对齐规则","url":"#内存对齐规则","depth":2},{"value":"看下面几个例子就清楚了","url":"#看下面几个例子就清楚了","depth":2},{"value":"#pragma pack(n)","url":"#pragma-packn","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"内存对齐 - 求结构体大小","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"文章介绍内存对齐原因（平台、性能）及规则，通过例子说明结构体大小计算。如 32 位机器上不同结构体示例，还提及","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415052657"}},{"title":"设计模式-单例模式","date":"2017-04-15T00:00:00.000Z","tags":["C/C++","Design"],"draft":false,"summary":"单例模式是常用软件设计模式，保证类只有一个实例。通过静态方法获取实例，构造函数私有。多线程时需小心，可用互斥锁。文中用 C++代码展示了单例模式的实现及相关知识点，包括 static 成员变量和静态成员函数等，还给出了单例销毁的示例。 \r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.325,"time":319500,"words":1065},"slug":"2017/20170415053136","path":"blog/2017/20170415053136","filePath":"blog/2017/20170415053136.mdx","toc":[{"value":"涉及到的知识点：","url":"#涉及到的知识点","depth":2},{"value":"static成员变量:","url":"#static成员变量","depth":3},{"value":"类的静态成员函数:","url":"#类的静态成员函数","depth":3},{"value":"单例销毁：","url":"#单例销毁","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"设计模式-单例模式","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"单例模式是常用软件设计模式，保证类只有一个实例。通过静态方法获取实例，构造函数私有。多线程时需小心，可用互斥锁。文中用 C++代码展示了单例模式的实现及相关知识点，包括 static 成员变量和静态成员函数等，还给出了单例销毁的示例。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415053136"}},{"title":"设计模式-简单工厂模式","date":"2017-04-15T00:00:00.000Z","tags":["C/C++","Design"],"draft":false,"summary":"总结：介绍了设计模式中的简单工厂模式，通过工厂类创建不同产品类实例。给出了 Product、Factory 等相关类的代码示例，包括虚析构函数等概念及 main 函数的使用。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.74,"time":164400,"words":548},"slug":"2017/20170415053411","path":"blog/2017/20170415053411","filePath":"blog/2017/20170415053411.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"设计模式-简单工厂模式","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"总结：介绍了设计模式中的简单工厂模式，通过工厂类创建不同产品类实例。给出了 Product、Factory 等相关类的代码示例，包括虚析构函数等概念及 main 函数的使用。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415053411"}},{"title":"WebBrowser控件判断页面加载完毕","date":"2017-04-15T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"文章介绍 WebBrowser 控件判断页面加载完毕的方法。DWebBrowserEvents2 Members 的 DocumentComplete 成员可用于此，但直接处理不行，需做处理。给出具体代码示例，在特定条件下进行页面加载完成的处理。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.6,"time":36000,"words":120},"slug":"2017/20170415053519","path":"blog/2017/20170415053519","filePath":"blog/2017/20170415053519.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WebBrowser控件判断页面加载完毕","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"文章介绍 WebBrowser 控件判断页面加载完毕的方法。DWebBrowserEvents2 Members 的 DocumentComplete 成员可用于此，但直接处理不行，需做处理。给出具体代码示例，在特定条件下进行页面加载完成的处理。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415053519"}},{"title":"静态库（lib）的编写与调用","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"介绍了静态库的编写与调用。先新建 Win32 Console Project 生成 LibAdd.lib，再新增头文件和源文件。调用时新建 Test 工程，包含头文件，指定 LibAdd.lib 目录和名称，在 main 函数中测试，得到所需结果。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.185,"time":71100,"words":237},"slug":"2017/20170415053749","path":"blog/2017/20170415053749","filePath":"blog/2017/20170415053749.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"静态库（lib）的编写与调用","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"介绍了静态库的编写与调用。先新建 Win32 Console Project 生成 LibAdd.lib，再新增头文件和源文件。调用时新建 Test 工程，包含头文件，指定 LibAdd.lib 目录和名称，在 main 函数中测试，得到所需结果。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415053749"}},{"title":"设计模式-抽象工厂模式","date":"2017-04-15T00:00:00.000Z","tags":["Design","C/C++"],"draft":false,"summary":"抽象工厂模式为产品家族提供统一创建接口，可在运行时创建系列产品族。文中以 Button 和 Border 为例，创建 Mac 和 Win 系列工厂，客户可根据需求选择创建。还给出了具体产品类和工厂类代码，以及适用性和优缺点等。 \r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.08,"time":304800,"words":1016},"slug":"2017/20170415055206","path":"blog/2017/20170415055206","filePath":"blog/2017/20170415055206.mdx","toc":[{"value":"适用性","url":"#适用性","depth":2},{"value":"优点","url":"#优点","depth":2},{"value":"缺点","url":"#缺点","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"设计模式-抽象工厂模式","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"抽象工厂模式为产品家族提供统一创建接口，可在运行时创建系列产品族。文中以 Button 和 Border 为例，创建 Mac 和 Win 系列工厂，客户可根据需求选择创建。还给出了具体产品类和工厂类代码，以及适用性和优缺点等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415055206"}},{"title":"visual studio低版本打开高版本建的工程","date":"2017-04-15T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"总结：高版本 visual studio 可直接打开低版本工程需转换，低版本打开高版本工程需改动，如用 vs2003 打开 vs2008 建的工程，需将 tjw.sln 的 Format Version 10.00 改为 8.00，tjw.vcproj 的 Version=\"9.00\"改为\"7.10\"。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.95,"time":57000,"words":190},"slug":"2017/20170415124629","path":"blog/2017/20170415124629","filePath":"blog/2017/20170415124629.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"visual studio低版本打开高版本建的工程","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"总结：高版本 visual studio 可直接打开低版本工程需转换，低版本打开高版本工程需改动，如用 vs2003 打开 vs2008 建的工程，需将 tjw.sln 的 Format Version 10.00 改为 8.00，tjw.vcproj 的 Version=\"9.00\"改为\"7.10\"。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415124629"}},{"title":"内存文件映射-进程间通信","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"介绍内存文件映射用于进程间通信，Microsoft 加入支持可创建内存映射文件无需专门磁盘文件。创建文件映射对象后可像使用任务内存区域，共享数据时传入名称。进程不再需要可调用 CloseHandle 收回存储器，分普通文件和页文件，示例展示进程 1 和进程 2 的操作。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.4,"time":264000,"words":880},"slug":"2017/20170415125217","path":"blog/2017/20170415125217","filePath":"blog/2017/20170415125217.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"内存文件映射-进程间通信","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"介绍内存文件映射用于进程间通信，Microsoft 加入支持可创建内存映射文件无需专门磁盘文件。创建文件映射对象后可像使用任务内存区域，共享数据时传入名称。进程不再需要可调用 CloseHandle 收回存储器，分普通文件和页文件，示例展示进程 1 和进程 2 的操作。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415125217"}},{"title":"怎样在对话框上做一个“应用”按钮","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"文章介绍在对话框上做“应用”按钮的方法。定义 WM_APPLY_TRUE 和 WM_APPLY_FALSE 消息，在 Main 对话框中实现消息映射和响应，还捕获全局消息，根据不同情况使“应用”按钮可用或不可用，用的是 WTL 且基本方法一致。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.235,"time":74100,"words":247},"slug":"2017/20170415125715","path":"blog/2017/20170415125715","filePath":"blog/2017/20170415125715.mdx","toc":[{"value":"定义两个消息：","url":"#定义两个消息","depth":3},{"value":"在Main对话框中实现这两个消息：","url":"#在main对话框中实现这两个消息","depth":3},{"value":"消息映射","url":"#消息映射","depth":4},{"value":"消息响应","url":"#消息响应","depth":4},{"value":"在Main对话框中捕获全局消息：","url":"#在main对话框中捕获全局消息","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"怎样在对话框上做一个“应用”按钮","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"文章介绍在对话框上做“应用”按钮的方法。定义 WM_APPLY_TRUE 和 WM_APPLY_FALSE 消息，在 Main 对话框中实现消息映射和响应，还捕获全局消息，根据不同情况使“应用”按钮可用或不可用，用的是 WTL 且基本方法一致。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415125715"}},{"title":"对char与wchar_t一些疑惑的理解","date":"2017-04-15T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"文章主要探讨 char 与 wchar_t，指出 char 存 ascii 码字符，wchar_t 存汉字等双字节字符。通过示例解释 char 存储汉字的原理及 memcpy_a 函数对 wchar_t 汉字串拷贝的方式，还提到用宽字符函数输出汉字需包含特定头文件和设置 locale。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.49,"time":209400,"words":698},"slug":"2017/20170415130028","path":"blog/2017/20170415130028","filePath":"blog/2017/20170415130028.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"对char与wchar_t一些疑惑的理解","datePublished":"2017-04-15T00:00:00.000Z","dateModified":"2017-04-15T00:00:00.000Z","description":"文章主要探讨 char 与 wchar_t，指出 char 存 ascii 码字符，wchar_t 存汉字等双字节字符。通过示例解释 char 存储汉字的原理及 memcpy_a 函数对 wchar_t 汉字串拷贝的方式，还提到用宽字符函数输出汉字需包含特定头文件和设置 locale。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170415130028"}},{"title":"electron demo","date":"2017-04-14T00:00:00.000Z","tags":["Windows","Web","Node.js"],"draft":false,"summary":"这是一个用 electron 框架做的 demo 程序，调用 showapi 接口数据。入口 main.js 初始化菜单、窗口等，还通过 ipc 与各页面通信，用 ejs 在 html 上展示数据，源码可在[https://code.csdn.net/tujiaw/showapi/tree/master](https://code.csdn.net/tujiaw/showapi/tree/master)查看。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.01,"time":180600,"words":602},"slug":"2017/20170414135022","path":"blog/2017/20170414135022","filePath":"blog/2017/20170414135022.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"electron demo","datePublished":"2017-04-14T00:00:00.000Z","dateModified":"2017-04-14T00:00:00.000Z","description":"这是一个用 electron 框架做的 demo 程序，调用 showapi 接口数据。入口 main.js 初始化菜单、窗口等，还通过 ipc 与各页面通信，用 ejs 在 html 上展示数据，源码可在[https://code.csdn.net/tujiaw/showapi/tree/master](https://code.csdn.net/tujiaw/showapi/tree/master)查看。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170414135022"}},{"title":"简单实现网页登录框中的“记住我”","date":"2017-04-13T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"文章介绍网页登录框“记住我”功能，通过 Cookie 实现。详细阐述 Cookie 和 Session 机制，及登录 html 表单和使用 jquery.cookie.js 读写 Cookie 的代码，在公用电脑勾选有风险，个人电脑可提供方便。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.845,"time":290700,"words":969},"slug":"2017/20170413020154","path":"blog/2017/20170413020154","filePath":"blog/2017/20170413020154.mdx","toc":[{"value":"Cookie机制","url":"#cookie机制","depth":1},{"value":"Session机制","url":"#session机制","depth":1},{"value":"登录html表单","url":"#登录html表单","depth":1},{"value":"使用jquery.cookie.js读写Cookie","url":"#使用jquerycookiejs读写cookie","depth":1}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"简单实现网页登录框中的“记住我”","datePublished":"2017-04-13T00:00:00.000Z","dateModified":"2017-04-13T00:00:00.000Z","description":"文章介绍网页登录框“记住我”功能，通过 Cookie 实现。详细阐述 Cookie 和 Session 机制，及登录 html 表单和使用 jquery.cookie.js 读写 Cookie 的代码，在公用电脑勾选有风险，个人电脑可提供方便。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170413020154"}},{"title":"浏览器同源政策及其规避方法","date":"2017-04-11T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"文章介绍浏览器同源政策，包括含义（1995 年 Netscape 引入，三相同）、目的（保证用户信息安全）、限制范围（Cookie 等三种行为受限）。还详细阐述了规避方法，如 Cookie 通过设置 document.domain 共享，iframe 可用片段标识符等三种方式通信，LocalStorage 可通过 window.postMessage 读写，AJAX 可用 JSONP、WebSocket、CORS 规避限制。 \r","type":"Blog","readingTime":{"text":"13 min read","minutes":12.7,"time":762000,"words":2540},"slug":"2017/20170411020127","path":"blog/2017/20170411020127","filePath":"blog/2017/20170411020127.mdx","toc":[{"value":"概述","url":"#概述","depth":1},{"value":"含义","url":"#含义","depth":2},{"value":"目的","url":"#目的","depth":2},{"value":"限制范围","url":"#限制范围","depth":2},{"value":"Cookie","url":"#cookie","depth":1},{"value":"iframe","url":"#iframe","depth":1},{"value":"片段识别符","url":"#片段识别符","depth":2},{"value":"window.name","url":"#windowname","depth":2},{"value":"window.postMessage","url":"#windowpostmessage","depth":2},{"value":"LocalStorage","url":"#localstorage","depth":2},{"value":"AJAX","url":"#ajax","depth":1},{"value":"JSONP","url":"#jsonp","depth":2},{"value":"WebSocket","url":"#websocket","depth":2},{"value":"CORS","url":"#cors","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"浏览器同源政策及其规避方法","datePublished":"2017-04-11T00:00:00.000Z","dateModified":"2017-04-11T00:00:00.000Z","description":"文章介绍浏览器同源政策，包括含义（1995 年 Netscape 引入，三相同）、目的（保证用户信息安全）、限制范围（Cookie 等三种行为受限）。还详细阐述了规避方法，如 Cookie 通过设置 document.domain 共享，iframe 可用片段标识符等三种方式通信，LocalStorage 可通过 window.postMessage 读写，AJAX 可用 JSONP、WebSocket、CORS 规避限制。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170411020127"}},{"title":"nginx配置nodejs服务二级域名","date":"2017-04-09T00:00:00.000Z","tags":["Node.js","Linux"],"draft":false,"summary":"文章介绍 nginx 配置 nodejs 服务二级域名，先在阿里云中添加 sanjiadian.net 的二级域名 tools、api、chat 解析，然后在 nginx/conf.d 下分别增加 sanjiadian.conf 和 chat.conf 配置文件指向不同端口的 nodejs 服务，最后重启 nginx 。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.385,"time":83100,"words":277},"slug":"2017/20170409071229","path":"blog/2017/20170409071229","filePath":"blog/2017/20170409071229.mdx","toc":[{"value":"增加二级域名","url":"#增加二级域名","depth":2},{"value":"nginx配置主域名","url":"#nginx配置主域名","depth":2},{"value":"nginx配置chat二级域名","url":"#nginx配置chat二级域名","depth":2},{"value":"重启nginx","url":"#重启nginx","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"nginx配置nodejs服务二级域名","datePublished":"2017-04-09T00:00:00.000Z","dateModified":"2017-04-09T00:00:00.000Z","description":"文章介绍 nginx 配置 nodejs 服务二级域名，先在阿里云中添加 sanjiadian.net 的二级域名 tools、api、chat 解析，然后在 nginx/conf.d 下分别增加 sanjiadian.conf 和 chat.conf 配置文件指向不同端口的 nodejs 服务，最后重启 nginx 。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170409071229"}},{"title":"QtCharts源码编译安装","date":"2017-04-02T00:00:00.000Z","tags":["Windows","C/C++","Qt"],"draft":false,"summary":"QtCharts 提供易使用的图表组件，用 Qt Graphics View Framework 可轻松集成。需自行编译安装，步骤包括获取源代码、用 vs2015 x64 编译安装、安装帮助文档及编译运行 demo 程序，各步骤详细且可成功展示图表。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.94,"time":116400,"words":388},"slug":"2017/20170402031622","path":"blog/2017/20170402031622","filePath":"blog/2017/20170402031622.mdx","toc":[{"value":"获取源代码，我用的git工具是TortoiseGit，如目录：C:/project/qtcharts","url":"#获取源代码我用的git工具是tortoisegit如目录cprojectqtcharts","depth":2},{"value":"使用vs2015 x64编译安装（根据自己实际情况）","url":"#使用vs2015-x64编译安装根据自己实际情况","depth":2},{"value":"安装帮助文档","url":"#安装帮助文档","depth":2},{"value":"编译运行qtcharts demo程序","url":"#编译运行qtcharts-demo程序","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QtCharts源码编译安装","datePublished":"2017-04-02T00:00:00.000Z","dateModified":"2017-04-02T00:00:00.000Z","description":"QtCharts 提供易使用的图表组件，用 Qt Graphics View Framework 可轻松集成。需自行编译安装，步骤包括获取源代码、用 vs2015 x64 编译安装、安装帮助文档及编译运行 demo 程序，各步骤详细且可成功展示图表。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170402031622"}},{"title":"QComboBox+QCompleter实现搜索自动匹配","date":"2017-03-23T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"通过 QComboBox 和 QCompleter 实现搜索自动匹配。按 Ctrl+F 打开搜索框，初始化数据并设置匹配规则为 contains，打开后清空显示并设焦点，点击弹出按钮列表框有数据，可通过信号槽实现相关功能。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.45,"time":87000,"words":290},"slug":"2017/20170323062222","path":"blog/2017/20170323062222","filePath":"blog/2017/20170323062222.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QComboBox+QCompleter实现搜索自动匹配","datePublished":"2017-03-23T00:00:00.000Z","dateModified":"2017-03-23T00:00:00.000Z","description":"通过 QComboBox 和 QCompleter 实现搜索自动匹配。按 Ctrl+F 打开搜索框，初始化数据并设置匹配规则为 contains，打开后清空显示并设焦点，点击弹出按钮列表框有数据，可通过信号槽实现相关功能。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170323062222"}},{"title":"windows判断窗口是否置顶、设置取消置顶、设置前景","date":"2017-03-18T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"文章介绍了 Windows 中判断窗口是否置顶、设置取消置顶及设置前景的方法。通过相关函数可实现这些操作，还定义了 WinParameter 类来解决特殊情况下设置失败问题，包含构造和析构函数。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":1.005,"time":60300,"words":201},"slug":"2017/20170318023958","path":"blog/2017/20170318023958","filePath":"blog/2017/20170318023958.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"windows判断窗口是否置顶、设置取消置顶、设置前景","datePublished":"2017-03-18T00:00:00.000Z","dateModified":"2017-03-18T00:00:00.000Z","description":"文章介绍了 Windows 中判断窗口是否置顶、设置取消置顶及设置前景的方法。通过相关函数可实现这些操作，还定义了 WinParameter 类来解决特殊情况下设置失败问题，包含构造和析构函数。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170318023958"}},{"title":"Qt自定义读取qss样式表","date":"2017-03-17T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"介绍 Qt 自定义读取 qss 样式表，一般用 qss 配置控件样式，特殊情况需代码控制。通过代码解析 qss 中的样式属性，提供 init、style、attr 等函数，示例展示了 qss 样式及初始化读取样式的过程。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.31,"time":138600,"words":462},"slug":"2017/20170317065614","path":"blog/2017/20170317065614","filePath":"blog/2017/20170317065614.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt自定义读取qss样式表","datePublished":"2017-03-17T00:00:00.000Z","dateModified":"2017-03-17T00:00:00.000Z","description":"介绍 Qt 自定义读取 qss 样式表，一般用 qss 配置控件样式，特殊情况需代码控制。通过代码解析 qss 中的样式属性，提供 init、style、attr 等函数，示例展示了 qss 样式及初始化读取样式的过程。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170317065614"}},{"title":"QComboBox item文字重叠","date":"2017-03-15T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"2017 年 3 月 15 日的“QComboBox item 文字重叠”文章提到，给 QComboBox 设置行交替颜色后，相邻 item 文字会重叠，解决方法是在 Qt Designer 中把 comboBox 的字体点大小设为实际要展示的文字大小，如从默认 9 改为 12。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.395,"time":23700,"words":79},"slug":"2017/20170315141809","path":"blog/2017/20170315141809","filePath":"blog/2017/20170315141809.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"QComboBox item文字重叠","datePublished":"2017-03-15T00:00:00.000Z","dateModified":"2017-03-15T00:00:00.000Z","description":"2017 年 3 月 15 日的“QComboBox item 文字重叠”文章提到，给 QComboBox 设置行交替颜色后，相邻 item 文字会重叠，解决方法是在 Qt Designer 中把 comboBox 的字体点大小设为实际要展示的文字大小，如从默认 9 改为 12。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170315141809"}},{"title":"C++获取输入法名字，调整输入法候选框位置","date":"2017-03-10T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"文章介绍 C++获取输入法名字及调整输入法候选框位置。可通过窗口布局或 HKL 获取，给出获取名字的函数及调整位置的代码，还包含相关头文件，支持 win7 及以下系统。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.7,"time":42000,"words":140},"slug":"2017/20170310052826","path":"blog/2017/20170310052826","filePath":"blog/2017/20170310052826.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++获取输入法名字，调整输入法候选框位置","datePublished":"2017-03-10T00:00:00.000Z","dateModified":"2017-03-10T00:00:00.000Z","description":"文章介绍 C++获取输入法名字及调整输入法候选框位置。可通过窗口布局或 HKL 获取，给出获取名字的函数及调整位置的代码，还包含相关头文件，支持 win7 及以下系统。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170310052826"}},{"title":"使用nginx配置nodejs服务进行反向代理","date":"2017-02-24T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"文章介绍用 nginx 配置 nodejs 服务做反向代理，域名备案后可通过域名访问。nginx 配置文件位置多样，文中在 /etc/nginx 下，通过在 http 中添加 upstream 及在 server 下配置 location 等步骤完成，最后需 nginx -s reload，若出错可删除 sites-enabled 下临时文件。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.125,"time":67500,"words":225},"slug":"2017/20170224062846","path":"blog/2017/20170224062846","filePath":"blog/2017/20170224062846.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用nginx配置nodejs服务进行反向代理","datePublished":"2017-02-24T00:00:00.000Z","dateModified":"2017-02-24T00:00:00.000Z","description":"文章介绍用 nginx 配置 nodejs 服务做反向代理，域名备案后可通过域名访问。nginx 配置文件位置多样，文中在 /etc/nginx 下，通过在 http 中添加 upstream 及在 server 下配置 location 等步骤完成，最后需 nginx -s reload，若出错可删除 sites-enabled 下临时文件。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170224062846"}},{"title":"Can only update a mounted or mounting component.","date":"2017-02-22T00:00:00.000Z","tags":["Mobile"],"draft":false,"summary":"react native 中出现“Can only update a mounted or mounting component.”警告，因_countdown 方法中每秒递减秒数，组件 unmounted 后 timer 未停止。解决办法是在 componentWillUnmount 中 clearTimeout，修改后的代码片段如上。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.095,"time":125700,"words":419},"slug":"2017/20170222141105","path":"blog/2017/20170222141105","filePath":"blog/2017/20170222141105.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Can only update a mounted or mounting component.","datePublished":"2017-02-22T00:00:00.000Z","dateModified":"2017-02-22T00:00:00.000Z","description":"react native 中出现“Can only update a mounted or mounting component.”警告，因_countdown 方法中每秒递减秒数，组件 unmounted 后 timer 未停止。解决办法是在 componentWillUnmount 中 clearTimeout，修改后的代码片段如上。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170222141105"}},{"title":"flex 网页布局","date":"2017-02-17T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"介绍 flex 网页布局，与 Qt 的布局相似，需注意 flex 属性简写及容器显示设置。文中给出具体 HTML 代码及效果图，展示了 flex 布局在网页中的应用，如各种元素的样式设置等。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.605,"time":96300,"words":321},"slug":"2017/20170217072522","path":"blog/2017/20170217072522","filePath":"blog/2017/20170217072522.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"flex 网页布局","datePublished":"2017-02-17T00:00:00.000Z","dateModified":"2017-02-17T00:00:00.000Z","description":"介绍 flex 网页布局，与 Qt 的布局相似，需注意 flex 属性简写及容器显示设置。文中给出具体 HTML 代码及效果图，展示了 flex 布局在网页中的应用，如各种元素的样式设置等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170217072522"}},{"title":"react native 布局头像标题简介","date":"2017-02-14T00:00:00.000Z","tags":["Mobile"],"draft":false,"summary":"此为 React Native 布局头像标题简介的代码示例。通过`ItemBox`组件展示头像、标题和简介，`App`组件设置相关样式和数据，最后注册组件。整体实现简单的布局展示效果。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.855,"time":51300,"words":171},"slug":"2017/20170214100349","path":"blog/2017/20170214100349","filePath":"blog/2017/20170214100349.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"react native 布局头像标题简介","datePublished":"2017-02-14T00:00:00.000Z","dateModified":"2017-02-14T00:00:00.000Z","description":"此为 React Native 布局头像标题简介的代码示例。通过`ItemBox`组件展示头像、标题和简介，`App`组件设置相关样式和数据，最后注册组件。整体实现简单的布局展示效果。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170214100349"}},{"title":"Windows下使用VS2013编译Qt5.6源码","date":"2017-02-08T00:00:00.000Z","tags":["Windows","Qt"],"draft":false,"summary":"介绍 Windows 下用 VS2013 编译 Qt5.6 源码的步骤，包括下载源码、安装相关工具、ICU 源码编译及环境变量设置等，还提及编译中常见问题及解决办法。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.27,"time":196200,"words":654},"slug":"2017/20170208033139","path":"blog/2017/20170208033139","filePath":"blog/2017/20170208033139.mdx","toc":[{"value":"下载Qt开源源码","url":"#下载qt开源源码","depth":4},{"value":"确保下面工具被安装","url":"#确保下面工具被安装","depth":4},{"value":"ICU源码编译，编译QtWebKit必须的","url":"#icu源码编译编译qtwebkit必须的","depth":4},{"value":"编译前需要注意的","url":"#编译前需要注意的","depth":4},{"value":"我编译中遇到的问题","url":"#我编译中遇到的问题","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Windows下使用VS2013编译Qt5.6源码","datePublished":"2017-02-08T00:00:00.000Z","dateModified":"2017-02-08T00:00:00.000Z","description":"介绍 Windows 下用 VS2013 编译 Qt5.6 源码的步骤，包括下载源码、安装相关工具、ICU 源码编译及环境变量设置等，还提及编译中常见问题及解决办法。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170208033139"}},{"title":"nodejs项目热更新 github webhooks","date":"2017-02-07T00:00:00.000Z","tags":["Node.js"],"draft":false,"summary":"介绍 nodejs 项目热更新 github webhooks，本地代码 git 上传后服务器接收通知并拉取代码重启程序。文中详述在 github 中设置及 nodejs 服务代码、脚本代码，需注意相关配置一致且安装相关组件。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.545,"time":92700,"words":309},"slug":"2017/20170207130112","path":"blog/2017/20170207130112","filePath":"blog/2017/20170207130112.mdx","toc":[{"value":"在github中对项目进行设置","url":"#在github中对项目进行设置","depth":3},{"value":"接收github变更通知","url":"#接收github变更通知","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"nodejs项目热更新 github webhooks","datePublished":"2017-02-07T00:00:00.000Z","dateModified":"2017-02-07T00:00:00.000Z","description":"介绍 nodejs 项目热更新 github webhooks，本地代码 git 上传后服务器接收通知并拉取代码重启程序。文中详述在 github 中设置及 nodejs 服务代码、脚本代码，需注意相关配置一致且安装相关组件。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170207130112"}},{"title":"CSS布局人物简介","date":"2017-02-05T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"这是关于“樱木花道”的 CSS 布局人物简介页面。通过特定 CSS 样式设置了图片、文字等布局，展示了樱木花道在《灌篮高手》中的相关信息，如他是湘北高中篮球队球员等。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.875,"time":52500,"words":175},"slug":"2017/20170205110821","path":"blog/2017/20170205110821","filePath":"blog/2017/20170205110821.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"CSS布局人物简介","datePublished":"2017-02-05T00:00:00.000Z","dateModified":"2017-02-05T00:00:00.000Z","description":"这是关于“樱木花道”的 CSS 布局人物简介页面。通过特定 CSS 样式设置了图片、文字等布局，展示了樱木花道在《灌篮高手》中的相关信息，如他是湘北高中篮球队球员等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170205110821"}},{"title":"Qt5.6支持高分辨率","date":"2017-02-03T00:00:00.000Z","tags":["Qt"],"draft":false,"summary":"Qt5.6 支持高分辨率，创建 QApplication 前加入特定代码即可。高分辨电脑需注意：别混用获取尺寸位置 API，nativeEvent 中 MSG 的 x,y 坐标需除以缩放比获取正确值。\r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.835,"time":50100,"words":167},"slug":"2017/20170203131520","path":"blog/2017/20170203131520","filePath":"blog/2017/20170203131520.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt5.6支持高分辨率","datePublished":"2017-02-03T00:00:00.000Z","dateModified":"2017-02-03T00:00:00.000Z","description":"Qt5.6 支持高分辨率，创建 QApplication 前加入特定代码即可。高分辨电脑需注意：别混用获取尺寸位置 API，nativeEvent 中 MSG 的 x,y 坐标需除以缩放比获取正确值。\r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170203131520"}},{"title":"Windows 7下硬盘安装Ubuntu 10.04简明教程（非Wubi安装，迁移2011-05-28）","date":"2017-02-02T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"介绍 Windows7 下硬盘安装 Ubuntu10.04 教程，需先下载安装 EasyBCD_1.7.2，复制文件并解压，通过 EasyBCD 操作，在 menu.lst 输入内容，重启后选择 NeoGrub Bootloader 进入光盘系统，按步骤安装，成功后可出现 Windows7 引导菜单。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.805,"time":168300,"words":561},"slug":"2017/20170202031335","path":"blog/2017/20170202031335","filePath":"blog/2017/20170202031335.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Windows 7下硬盘安装Ubuntu 10.04简明教程（非Wubi安装，迁移2011-05-28）","datePublished":"2017-02-02T00:00:00.000Z","dateModified":"2017-02-02T00:00:00.000Z","description":"介绍 Windows7 下硬盘安装 Ubuntu10.04 教程，需先下载安装 EasyBCD_1.7.2，复制文件并解压，通过 EasyBCD 操作，在 menu.lst 输入内容，重启后选择 NeoGrub Bootloader 进入光盘系统，按步骤安装，成功后可出现 Windows7 引导菜单。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170202031335"}},{"title":"让程序只有一个应用程序实例在运行","date":"2017-02-02T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"文章介绍让程序只有一个实例运行的方法，开始加代码实现。有三种：一是找先前窗口实例并激活；二是用互斥对象，创建后判断是否已存在；三是用事件对象，创建后判断是否已存在，若已存在则直接返回。（迁移 2011 - 05 - 28） \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.97,"time":58200,"words":194},"slug":"2017/20170202031607","path":"blog/2017/20170202031607","filePath":"blog/2017/20170202031607.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"让程序只有一个应用程序实例在运行","datePublished":"2017-02-02T00:00:00.000Z","dateModified":"2017-02-02T00:00:00.000Z","description":"文章介绍让程序只有一个实例运行的方法，开始加代码实现。有三种：一是找先前窗口实例并激活；二是用互斥对象，创建后判断是否已存在；三是用事件对象，创建后判断是否已存在，若已存在则直接返回。（迁移 2011 - 05 - 28） \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170202031607"}},{"title":"临界区 互斥量 信号量 事件","date":"2017-02-02T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"文章介绍了进程或线程同步互斥的四种控制方法：临界区速度快可串行化访问公共资源；互斥量可跨进程控制资源访问；信号量允许多线程同时访问有限资源；事件可通知线程同步。并分别给出各方法的操作原语及 MFC 类的使用示例，还通过实例展示了临界区和事件的用法。 \r","type":"Blog","readingTime":{"text":"12 min read","minutes":11.27,"time":676200,"words":2254},"slug":"2017/20170202032554","path":"blog/2017/20170202032554","filePath":"blog/2017/20170202032554.mdx","toc":[{"value":"临界区（Critical Section）","url":"#临界区critical-section","depth":3},{"value":"互斥量（Mutex）","url":"#互斥量mutex","depth":3},{"value":"信号量（Semaphores）","url":"#信号量semaphores","depth":3},{"value":"事件（Event）","url":"#事件event","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"临界区 互斥量 信号量 事件","datePublished":"2017-02-02T00:00:00.000Z","dateModified":"2017-02-02T00:00:00.000Z","description":"文章介绍了进程或线程同步互斥的四种控制方法：临界区速度快可串行化访问公共资源；互斥量可跨进程控制资源访问；信号量允许多线程同时访问有限资源；事件可通知线程同步。并分别给出各方法的操作原语及 MFC 类的使用示例，还通过实例展示了临界区和事件的用法。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170202032554"}},{"title":"内存映射文件","date":"2017-02-02T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"总结：内存映射文件是一种内存管理方法，可将文件映射到进程虚拟地址空间，无需文件 I/O 操作和缓冲处理，适合管理大尺寸文件。文中给出 C++代码示例，通过创建文件、映射文件视图等操作实现内存映射。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.06,"time":63600,"words":212},"slug":"2017/20170202032800","path":"blog/2017/20170202032800","filePath":"blog/2017/20170202032800.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"内存映射文件","datePublished":"2017-02-02T00:00:00.000Z","dateModified":"2017-02-02T00:00:00.000Z","description":"总结：内存映射文件是一种内存管理方法，可将文件映射到进程虚拟地址空间，无需文件 I/O 操作和缓冲处理，适合管理大尺寸文件。文中给出 C++代码示例，通过创建文件、映射文件视图等操作实现内存映射。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170202032800"}},{"title":"WTL按钮重绘","date":"2017-02-02T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"介绍了 WTL 按钮重绘的类及用法，需导入头文件，添加按钮控件并设 Ower Draw 属性为 True，在特定消息映射中添加代码，还给出了类的相关函数如 OnDrawItem 等的实现，可实现按钮不同状态下的位图绘制及相关操作。[from](http://www.codeproject.com/KB/wtl/mousetrack.aspx) （迁移 2011 - 05 - 09） \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.69,"time":221400,"words":738},"slug":"2017/20170202033044","path":"blog/2017/20170202033044","filePath":"blog/2017/20170202033044.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL按钮重绘","datePublished":"2017-02-02T00:00:00.000Z","dateModified":"2017-02-02T00:00:00.000Z","description":"介绍了 WTL 按钮重绘的类及用法，需导入头文件，添加按钮控件并设 Ower Draw 属性为 True，在特定消息映射中添加代码，还给出了类的相关函数如 OnDrawItem 等的实现，可实现按钮不同状态下的位图绘制及相关操作。[from](http://www.codeproject.com/KB/wtl/mousetrack.aspx) （迁移 2011 - 05 - 09） \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170202033044"}},{"title":"WTL多页面显示实现方法","date":"2017-02-02T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"文章介绍 WTL 多页面显示实现方法，主对话框有三页面，设属性、成员变量，设置显示区域并创建页面，移动到指定区域，最后根据条件显示指定窗口，隐藏其他窗口，如显示第一页隐藏第二、三页。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.745,"time":44700,"words":149},"slug":"2017/20170202033406","path":"blog/2017/20170202033406","filePath":"blog/2017/20170202033406.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL多页面显示实现方法","datePublished":"2017-02-02T00:00:00.000Z","dateModified":"2017-02-02T00:00:00.000Z","description":"文章介绍 WTL 多页面显示实现方法，主对话框有三页面，设属性、成员变量，设置显示区域并创建页面，移动到指定区域，最后根据条件显示指定窗口，隐藏其他窗口，如显示第一页隐藏第二、三页。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170202033406"}},{"title":"gitbook","date":"2017-02-02T00:00:00.000Z","tags":["Tips"],"draft":false,"summary":"gitbook链接 。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.005,"time":300,"words":1},"slug":"2017/20170202135455","path":"blog/2017/20170202135455","filePath":"blog/2017/20170202135455.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"gitbook","datePublished":"2017-02-02T00:00:00.000Z","dateModified":"2017-02-02T00:00:00.000Z","description":"gitbook链接 。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170202135455"}},{"title":"npm常用命令","date":"2017-01-29T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"2017 年 1 月 29 日的文章“npm 常用命令”，虽为草稿但有相关图片。主要围绕 npm 的常用命令展开，未提及具体命令内容。  \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.03,"time":1800,"words":6},"slug":"2017/20170129120741","path":"blog/2017/20170129120741","filePath":"blog/2017/20170129120741.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"npm常用命令","datePublished":"2017-01-29T00:00:00.000Z","dateModified":"2017-01-29T00:00:00.000Z","description":"2017 年 1 月 29 日的文章“npm 常用命令”，虽为草稿但有相关图片。主要围绕 npm 的常用命令展开，未提及具体命令内容。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170129120741"}},{"title":"32位到64位程序移植","date":"2017-01-26T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"主要讲述 32 位到 64 位程序移植，以输入法为例，需编译 64 位 DLL 且注意内存、函数等方面问题。64 位系统有 SysWow64 兼容 32 位，输入法需两个 IME 分别放 System32 和 SysWow64，启动时系统根据应用程序位数加载相应 IME。 \r","type":"Blog","readingTime":{"text":"7 min read","minutes":6.325,"time":379500,"words":1265},"slug":"2017/20170101153750","path":"blog/2017/20170101153750","filePath":"blog/2017/20170101153750.mdx","toc":[{"value":"准备工作","url":"#准备工作","depth":4},{"value":"编译","url":"#编译","depth":4},{"value":"x64中32位与64位程序兼容问题","url":"#x64中32位与64位程序兼容问题","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"32位到64位程序移植","datePublished":"2017-01-26T00:00:00.000Z","dateModified":"2017-01-26T00:00:00.000Z","description":"主要讲述 32 位到 64 位程序移植，以输入法为例，需编译 64 位 DLL 且注意内存、函数等方面问题。64 位系统有 SysWow64 兼容 32 位，输入法需两个 IME 分别放 System32 和 SysWow64，启动时系统根据应用程序位数加载相应 IME。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170101153750"}},{"title":"WTL 一个很好用的ToolTip（迁移2011-03-13）","date":"2017-01-26T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"介绍了一个老外写的好用 ToolTip，解决两个小问题（鼠标划上立马弹出又消失、提示框停留时间短），给出源码及用法，需写入头文件、继承类等，还可看源码函数了解其他用法。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.47,"time":208200,"words":694},"slug":"2017/20170126060117","path":"blog/2017/20170126060117","filePath":"blog/2017/20170126060117.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL 一个很好用的ToolTip（迁移2011-03-13）","datePublished":"2017-01-26T00:00:00.000Z","dateModified":"2017-01-26T00:00:00.000Z","description":"介绍了一个老外写的好用 ToolTip，解决两个小问题（鼠标划上立马弹出又消失、提示框停留时间短），给出源码及用法，需写入头文件、继承类等，还可看源码函数了解其他用法。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170126060117"}},{"title":"WTL CComboBox 增加所有字体名（迁移2011-03-10）","date":"2017-01-26T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"2017 年 1 月 26 日记录为 CComboBox 控件增加系统字体名的过程。先定义并关联对象，再通过 EnumFontFamiliesEx 及回调函数获取字体名并添加到 CComboBox 中，注意相关参数设置和返回值，还需去掉带@号的字体名。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.76,"time":105600,"words":352},"slug":"2017/20170126061849","path":"blog/2017/20170126061849","filePath":"blog/2017/20170126061849.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL CComboBox 增加所有字体名（迁移2011-03-10）","datePublished":"2017-01-26T00:00:00.000Z","dateModified":"2017-01-26T00:00:00.000Z","description":"2017 年 1 月 26 日记录为 CComboBox 控件增加系统字体名的过程。先定义并关联对象，再通过 EnumFontFamiliesEx 及回调函数获取字体名并添加到 CComboBox 中，注意相关参数设置和返回值，还需去掉带@号的字体名。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170126061849"}},{"title":"DLL的编写与调用，简单示例（迁移2011-03-06）","date":"2017-01-26T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍了 DLL 的编写与调用，包括新建 DLL 类型应用程序（myDll.cpp）及调用（TestDll.cpp）的代码，还提及显式和隐式调用方式及相关函数，如 extern \"C\"、_declspec 等，以及一个 apr 中的例子。 \r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.01,"time":300600,"words":1002},"slug":"2017/20170126073438","path":"blog/2017/20170126073438","filePath":"blog/2017/20170126073438.mdx","toc":[{"value":"新建一个DLL类型的应用程序，如：myDll.cpp","url":"#新建一个dll类型的应用程序如mydllcpp","depth":4},{"value":"新建一个win32控制台应用程序，如：TestDll.cpp","url":"#新建一个win32控制台应用程序如testdllcpp","depth":4},{"value":"上面是DLL的显示调用，看起来比较麻烦但是它只要一个dll文件就可以了；","url":"#上面是dll的显示调用看起来比较麻烦但是它只要一个dll文件就可以了","depth":4},{"value":"测试DLL","url":"#测试dll","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"DLL的编写与调用，简单示例（迁移2011-03-06）","datePublished":"2017-01-26T00:00:00.000Z","dateModified":"2017-01-26T00:00:00.000Z","description":"介绍了 DLL 的编写与调用，包括新建 DLL 类型应用程序（myDll.cpp）及调用（TestDll.cpp）的代码，还提及显式和隐式调用方式及相关函数，如 extern \"C\"、_declspec 等，以及一个 apr 中的例子。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170126073438"}},{"title":"函数外初始化与函数内初始化","date":"2017-01-26T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍函数外初始化与函数内初始化，通过测试代码说明。函数内初始化需注意参数带&，为传递指针引用；函数外初始化参数带&或不带&均可，传进来是同一地址。认为第二种方式符合分配释放原则。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.315,"time":138900,"words":463},"slug":"2017/20170126073811","path":"blog/2017/20170126073811","filePath":"blog/2017/20170126073811.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"函数外初始化与函数内初始化","datePublished":"2017-01-26T00:00:00.000Z","dateModified":"2017-01-26T00:00:00.000Z","description":"介绍函数外初始化与函数内初始化，通过测试代码说明。函数内初始化需注意参数带&，为传递指针引用；函数外初始化参数带&或不带&均可，传进来是同一地址。认为第二种方式符合分配释放原则。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170126073811"}},{"title":"高质量子程序核查表（代码大全2）","date":"2017-01-26T00:00:00.000Z","tags":["Tips"],"draft":false,"summary":"这是高质量子程序核查表，包含大局事项如创建理由等 8 点及参数传递事项如参数表等 8 点，涵盖子程序各方面，从不同角度确保子程序质量，摘自《代码大全 2》。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.37,"time":142200,"words":474},"slug":"2017/20171210125824","path":"blog/2017/20171210125824","filePath":"blog/2017/20171210125824.mdx","toc":[{"value":"大局事项：","url":"#大局事项","depth":3},{"value":"参数传递事项：","url":"#参数传递事项","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"高质量子程序核查表（代码大全2）","datePublished":"2017-01-26T00:00:00.000Z","dateModified":"2017-01-26T00:00:00.000Z","description":"这是高质量子程序核查表，包含大局事项如创建理由等 8 点及参数传递事项如参数表等 8 点，涵盖子程序各方面，从不同角度确保子程序质量，摘自《代码大全 2》。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125824"}},{"title":"WTL安装到VS2008和VS2010中（迁移2011-02-26）","date":"2017-01-23T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"介绍 WTL 安装到 VS2008 和 VS2010 的方法。WTL8.0 支持 VS2005 ，8.1 支持 VS2008 。安装时需注意解压、设置 VC++目录等步骤，若遇错误可参考相关资料解决，VS2010 安装需下载特定文件并按步骤操作。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.535,"time":152100,"words":507},"slug":"2017/20170123053541","path":"blog/2017/20170123053541","filePath":"blog/2017/20170123053541.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL安装到VS2008和VS2010中（迁移2011-02-26）","datePublished":"2017-01-23T00:00:00.000Z","dateModified":"2017-01-23T00:00:00.000Z","description":"介绍 WTL 安装到 VS2008 和 VS2010 的方法。WTL8.0 支持 VS2005 ，8.1 支持 VS2008 。安装时需注意解压、设置 VC++目录等步骤，若遇错误可参考相关资料解决，VS2010 安装需下载特定文件并按步骤操作。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170123053541"}},{"title":"依赖 关联 聚合 组合 泛化（迁移2011-01-17）","date":"2017-01-22T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"文章介绍了 UML 中类的关系，包括依赖、关联、聚合、组合和泛化。依赖是使用关系，关联是拥有关系，聚合和组合是整体 - 部分关系，聚合可分离，组合不可分离，泛化是父类与子类关系。并举例说明不同关系在不同问题域的表现和变化。 \r","type":"Blog","readingTime":{"text":"10 min read","minutes":9.55,"time":573000,"words":1910},"slug":"2017/20170122123702","path":"blog/2017/20170122123702","filePath":"blog/2017/20170122123702.mdx","toc":[{"value":"泛化关系","url":"#泛化关系","depth":3},{"value":"结语","url":"#结语","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"依赖 关联 聚合 组合 泛化（迁移2011-01-17）","datePublished":"2017-01-22T00:00:00.000Z","dateModified":"2017-01-22T00:00:00.000Z","description":"文章介绍了 UML 中类的关系，包括依赖、关联、聚合、组合和泛化。依赖是使用关系，关联是拥有关系，聚合和组合是整体 - 部分关系，聚合可分离，组合不可分离，泛化是父类与子类关系。并举例说明不同关系在不同问题域的表现和变化。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170122123702"}},{"title":"scanf、sscanf中的正则表达式（迁移2011-01-14）","date":"2017-01-22T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍 scanf、sscanf 中的正则表达式，包括定制扫描集、读入地址、丢弃空白符等。通过多个实验展示 sscanf 用正则表达式格式化输入后字符串的变化，如不同条件下的拷贝和过滤等，还提到 msdn 中 sscanf 声明及可直接用正则表达式等内容。 \r","type":"Blog","readingTime":{"text":"19 min read","minutes":18.11,"time":1086600,"words":3622},"slug":"2017/20170122124138","path":"blog/2017/20170122124138","filePath":"blog/2017/20170122124138.mdx","toc":[{"value":"第一篇：","url":"#第一篇","depth":3},{"value":"执行完后str的内容是字符串\"123334\"。[0-9]*是一个非常简单的正则表达式，意思是匹配数字任意次。关于正则表达式的更多内容请参看这个。我们在写程序时经常会碰到需要解析字符串的情况，而正则表达式则是解决此类问题的利器。如果我们能善用c标准库函数就能使用的正则表达式，一定可以做到事半而功倍。","url":"#执行完后str的内容是字符串1233340-9是一个非常简单的正则表达式意思是匹配数字任意次关于正则表达式的更多内容请参看这个我们在写程序时经常会碰到需要解析字符串的情况而正则表达式则是解决此类问题的利器如果我们能善用c标准库函数就能使用的正则表达式一定可以做到事半而功倍","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"scanf、sscanf中的正则表达式（迁移2011-01-14）","datePublished":"2017-01-22T00:00:00.000Z","dateModified":"2017-01-22T00:00:00.000Z","description":"介绍 scanf、sscanf 中的正则表达式，包括定制扫描集、读入地址、丢弃空白符等。通过多个实验展示 sscanf 用正则表达式格式化输入后字符串的变化，如不同条件下的拷贝和过滤等，还提到 msdn 中 sscanf 声明及可直接用正则表达式等内容。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170122124138"}},{"title":"分离WinMain中传进来的字符串（迁移2011-01-14）","date":"2017-01-22T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"文章主要讲分离 WinMain 中传进的字符串，WinMain 可接受外部字符串但获取的是整个，要获取多个需分离源字符串，文中给出 MSDN 介绍的方法，通过相关函数处理并输出结果。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.535,"time":32100,"words":107},"slug":"2017/20170122125950","path":"blog/2017/20170122125950","filePath":"blog/2017/20170122125950.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"分离WinMain中传进来的字符串（迁移2011-01-14）","datePublished":"2017-01-22T00:00:00.000Z","dateModified":"2017-01-22T00:00:00.000Z","description":"文章主要讲分离 WinMain 中传进的字符串，WinMain 可接受外部字符串但获取的是整个，要获取多个需分离源字符串，文中给出 MSDN 介绍的方法，通过相关函数处理并输出结果。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170122125950"}},{"title":"WTL自画按钮与文件对话框（迁移2011-01-14）","date":"2017-01-22T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"文章介绍了 WTL 自画按钮与文件对话框。包含自画按钮类 CBmpEixtBtn 的定义及相关操作，如在 OnInitDialog 中进行子类化；还有文件对话框相关代码，通过 BROWSEINFO 等设置获取选择目录并显示在编辑框中。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.825,"time":49500,"words":165},"slug":"2017/20170122130158","path":"blog/2017/20170122130158","filePath":"blog/2017/20170122130158.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"WTL自画按钮与文件对话框（迁移2011-01-14）","datePublished":"2017-01-22T00:00:00.000Z","dateModified":"2017-01-22T00:00:00.000Z","description":"文章介绍了 WTL 自画按钮与文件对话框。包含自画按钮类 CBmpEixtBtn 的定义及相关操作，如在 OnInitDialog 中进行子类化；还有文件对话框相关代码，通过 BROWSEINFO 等设置获取选择目录并显示在编辑框中。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170122130158"}},{"title":"Win32 API笔记（迁移2011-01-12）","date":"2017-01-22T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"这是 Win32 API 笔记，包含创建非模式对话框、静态文本控件、显示图片等操作示例，还涉及系统托盘、获取屏幕尺寸等内容，以及诸多关于 Win32 API 的细节和用法。 \r","type":"Blog","readingTime":{"text":"8 min read","minutes":7.485,"time":449100,"words":1497},"slug":"2017/20170122131720","path":"blog/2017/20170122131720","filePath":"blog/2017/20170122131720.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Win32 API笔记（迁移2011-01-12）","datePublished":"2017-01-22T00:00:00.000Z","dateModified":"2017-01-22T00:00:00.000Z","description":"这是 Win32 API 笔记，包含创建非模式对话框、静态文本控件、显示图片等操作示例，还涉及系统托盘、获取屏幕尺寸等内容，以及诸多关于 Win32 API 的细节和用法。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170122131720"}},{"title":"gtk改变button的字体大小（迁移2011-01-09 ）","date":"2017-01-22T00:00:00.000Z","tags":["Linux","C/C++"],"draft":false,"summary":"2017 年 1 月 22 日，文章介绍通过取出 GtkButton 里的 label 并更改其字体来改变 button 字体大小，利用 pango 相关代码实现，安装 gtk 后自带 pango。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.66,"time":39600,"words":132},"slug":"2017/20170122133000","path":"blog/2017/20170122133000","filePath":"blog/2017/20170122133000.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"gtk改变button的字体大小（迁移2011-01-09 ）","datePublished":"2017-01-22T00:00:00.000Z","dateModified":"2017-01-22T00:00:00.000Z","description":"2017 年 1 月 22 日，文章介绍通过取出 GtkButton 里的 label 并更改其字体来改变 button 字体大小，利用 pango 相关代码实现，安装 gtk 后自带 pango。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170122133000"}},{"title":"const用法（迁移2011-01-04）","date":"2017-01-22T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"const 可指定语义约束，编译器强制实施。函数参数加 const 有不同含义，返回值前加 const 及类成员函数后加 const 也有特定规则，如函数参数加 const 可限制被指物或指针，类成员函数后加 const 不能给成员变量赋值，可用 mutable 解决。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.815,"time":108900,"words":363},"slug":"2017/20170122133306","path":"blog/2017/20170122133306","filePath":"blog/2017/20170122133306.mdx","toc":[{"value":"vo...","url":"#vo","depth":2},{"value":"函数参数加const","url":"#函数参数加const","depth":3},{"value":"函数返回值前加const","url":"#函数返回值前加const","depth":3},{"value":"类的成员函数后面加const","url":"#类的成员函数后面加const","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"const用法（迁移2011-01-04）","datePublished":"2017-01-22T00:00:00.000Z","dateModified":"2017-01-22T00:00:00.000Z","description":"const 可指定语义约束，编译器强制实施。函数参数加 const 有不同含义，返回值前加 const 及类成员函数后加 const 也有特定规则，如函数参数加 const 可限制被指物或指针，类成员函数后加 const 不能给成员变量赋值，可用 mutable 解决。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170122133306"}},{"title":"SetWindowLongPtr and GetWindowLongPtr 用法 实例（迁移2011-01-28）","date":"2017-01-19T00:00:00.000Z","tags":["Windows"],"draft":false,"summary":"介绍 SetWindowLongPtr 与 GetWindowLongPtr 两种用法，重点阐述第二种在额外存储空间设置和获取值。以简单例子展示，分配堆内存并通过这两个函数操作，注意 32 位和 64 位系统指针字节数对偏移位置的影响。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.075,"time":184500,"words":615},"slug":"2017/20170119145226","path":"blog/2017/20170119145226","filePath":"blog/2017/20170119145226.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"SetWindowLongPtr and GetWindowLongPtr 用法 实例（迁移2011-01-28）","datePublished":"2017-01-19T00:00:00.000Z","dateModified":"2017-01-19T00:00:00.000Z","description":"介绍 SetWindowLongPtr 与 GetWindowLongPtr 两种用法，重点阐述第二种在额外存储空间设置和获取值。以简单例子展示，分配堆内存并通过这两个函数操作，注意 32 位和 64 位系统指针字节数对偏移位置的影响。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170119145226"}},{"title":"类模板之栈（迁移2011-01-19）","date":"2017-01-19T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍类模板之栈，给出`myStack.h`、`myStack.cpp`和`main.cpp`代码。`myStack.h`定义类模板`CMyStack`，`myStack.cpp`实现其成员函数，`main.cpp`创建并使用`CMyStack<int>`对象进行操作，展示栈的基本功能。  \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.15,"time":69000,"words":230},"slug":"2017/20170119145513","path":"blog/2017/20170119145513","filePath":"blog/2017/20170119145513.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"类模板之栈（迁移2011-01-19）","datePublished":"2017-01-19T00:00:00.000Z","dateModified":"2017-01-19T00:00:00.000Z","description":"介绍类模板之栈，给出`myStack.h`、`myStack.cpp`和`main.cpp`代码。`myStack.h`定义类模板`CMyStack`，`myStack.cpp`实现其成员函数，`main.cpp`创建并使用`CMyStack<int>`对象进行操作，展示栈的基本功能。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170119145513"}},{"title":"可变参数（迁移2011-01-18）","date":"2017-01-19T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍了可变参数，C 编译器提供宏处理，有 ANSI 标准形式和与 UNIX System V 兼容形式，通过 va_start、va_arg、va_end 处理参数，还给出具体代码示例，如 demo 函数和 CLogger 类的 Write 函数等。 \r","type":"Blog","readingTime":{"text":"6 min read","minutes":5.945,"time":356700,"words":1189},"slug":"2017/20170119150239","path":"blog/2017/20170119150239","filePath":"blog/2017/20170119150239.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"可变参数（迁移2011-01-18）","datePublished":"2017-01-19T00:00:00.000Z","dateModified":"2017-01-19T00:00:00.000Z","description":"介绍了可变参数，C 编译器提供宏处理，有 ANSI 标准形式和与 UNIX System V 兼容形式，通过 va_start、va_arg、va_end 处理参数，还给出具体代码示例，如 demo 函数和 CLogger 类的 Write 函数等。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170119150239"}},{"title":"libcurl静态库编译需要支持XP","date":"2017-01-16T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍 libcurl 静态库编译需支持 XP 的相关内容，给出 github 地址。详细步骤为打开 curl/winbuild/MakefileBuild.vc 文件添加特定内容，在 VS2013 命令提示工具下 cd 到相应目录运行命令，最终在 curl/builds 目录可看到生成文件。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.675,"time":40500,"words":135},"slug":"2017/20170116102439","path":"blog/2017/20170116102439","filePath":"blog/2017/20170116102439.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"libcurl静态库编译需要支持XP","datePublished":"2017-01-16T00:00:00.000Z","dateModified":"2017-01-16T00:00:00.000Z","description":"介绍 libcurl 静态库编译需支持 XP 的相关内容，给出 github 地址。详细步骤为打开 curl/winbuild/MakefileBuild.vc 文件添加特定内容，在 VS2013 命令提示工具下 cd 到相应目录运行命令，最终在 curl/builds 目录可看到生成文件。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170116102439"}},{"title":"今天开始决定写博客（迁移2010-12-26）","date":"2017-01-15T00:00:00.000Z","tags":["Tools"],"draft":false,"summary":"2017 年 1 月 15 日，作者决定开始写博客记录工作学习历程，虽曾因原因和惰性未写成，但现受汪国真《热爱生命》诗激励，希望多年后能回忆起当初。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.16,"time":69600,"words":232},"slug":"2017/20170115115854","path":"blog/2017/20170115115854","filePath":"blog/2017/20170115115854.mdx","toc":[{"value":"《热爱生命》 ----汪国真","url":"#热爱生命-----汪国真","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"今天开始决定写博客（迁移2010-12-26）","datePublished":"2017-01-15T00:00:00.000Z","dateModified":"2017-01-15T00:00:00.000Z","description":"2017 年 1 月 15 日，作者决定开始写博客记录工作学习历程，虽曾因原因和惰性未写成，但现受汪国真《热爱生命》诗激励，希望多年后能回忆起当初。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170115115854"}},{"title":"const_cast、static_cast、reinterpret_cast、dynamic_cast（迁移2010-12-27）","date":"2017-01-15T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"C++有 const_cast、static_cast、reinterpret_cast、dynamic_cast 等转型。const_cast 剥除 const 修饰符；static_cast 用于类的父子类转换需显式说明；reinterpret_cast 用于指针转换，字节数相同可按位转换；dynamic_cast 用于多态类型向下转型，执行运行期检查。 \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.045,"time":182700,"words":609},"slug":"2017/20170115121650","path":"blog/2017/20170115121650","filePath":"blog/2017/20170115121650.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"const_cast、static_cast、reinterpret_cast、dynamic_cast（迁移2010-12-27）","datePublished":"2017-01-15T00:00:00.000Z","dateModified":"2017-01-15T00:00:00.000Z","description":"C++有 const_cast、static_cast、reinterpret_cast、dynamic_cast 等转型。const_cast 剥除 const 修饰符；static_cast 用于类的父子类转换需显式说明；reinterpret_cast 用于指针转换，字节数相同可按位转换；dynamic_cast 用于多态类型向下转型，执行运行期检查。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170115121650"}},{"title":"宽字符函数与普通C函数（迁移2010-12-28）","date":"2017-01-15T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"文章介绍了宽字符函数与普通 C 函数，如 iswalnum 等与 isalnum 等的对应关系，列举了多种宽字符函数及其对应的普通 C 函数，还提供了更多函数的查看链接。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.135,"time":68100,"words":227},"slug":"2017/20170115122422","path":"blog/2017/20170115122422","filePath":"blog/2017/20170115122422.mdx","toc":[{"value":"iswdigit   isdi...","url":"#iswdigit---isdi","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"宽字符函数与普通C函数（迁移2010-12-28）","datePublished":"2017-01-15T00:00:00.000Z","dateModified":"2017-01-15T00:00:00.000Z","description":"文章介绍了宽字符函数与普通 C 函数，如 iswalnum 等与 isalnum 等的对应关系，列举了多种宽字符函数及其对应的普通 C 函数，还提供了更多函数的查看链接。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170115122422"}},{"title":"拷贝构造与赋值操作(string实例)（迁移2010-12-28）","date":"2017-01-15T00:00:00.000Z","tags":["C/C++"],"draft":false,"summary":"介绍了 C++中 MyString 类的拷贝构造与赋值操作，若未自定义这两个操作，C++会生成缺省操作符，导致内存泄漏等问题，如 str1 和 str2 赋值后指向同一内存，析构时会出错。  \r","type":"Blog","readingTime":{"text":"4 min read","minutes":3.045,"time":182700,"words":609},"slug":"2017/20170115125356","path":"blog/2017/20170115125356","filePath":"blog/2017/20170115125356.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"拷贝构造与赋值操作(string实例)（迁移2010-12-28）","datePublished":"2017-01-15T00:00:00.000Z","dateModified":"2017-01-15T00:00:00.000Z","description":"介绍了 C++中 MyString 类的拷贝构造与赋值操作，若未自定义这两个操作，C++会生成缺省操作符，导致内存泄漏等问题，如 str1 和 str2 赋值后指向同一内存，析构时会出错。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170115125356"}},{"title":"gtk窗口拖动（迁移2010-12-31）","date":"2017-01-15T00:00:00.000Z","tags":["Linux"],"draft":false,"summary":"文章介绍 gtk 窗口拖动相关内容。先加入事件，关联信号与 button 按下事件，实现窗口拖动。还能使窗口不能移出桌面最左边并在标题栏显示位置坐标，通过关联信号与事件及相应实现函数来完成。 \r","type":"Blog","readingTime":{"text":"2 min read","minutes":1.03,"time":61800,"words":206},"slug":"2017/20170115130757","path":"blog/2017/20170115130757","filePath":"blog/2017/20170115130757.mdx","toc":[{"value":"实现按下鼠标左键拖动窗口","url":"#实现按下鼠标左键拖动窗口","depth":3},{"value":"使窗口不能移出桌面最左边,在标题栏显示当前窗口的位置坐标","url":"#使窗口不能移出桌面最左边在标题栏显示当前窗口的位置坐标","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"gtk窗口拖动（迁移2010-12-31）","datePublished":"2017-01-15T00:00:00.000Z","dateModified":"2017-01-15T00:00:00.000Z","description":"文章介绍 gtk 窗口拖动相关内容。先加入事件，关联信号与 button 按下事件，实现窗口拖动。还能使窗口不能移出桌面最左边并在标题栏显示位置坐标，通过关联信号与事件及相应实现函数来完成。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170115130757"}},{"title":"给一组标签设置状态","date":"2017-01-09T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"文章介绍给一组标签设置状态的方法，当鼠标点击标签时，若有“active”类则移除，无则添加。通过 jQuery 代码实现，对多个不同类别的标签进行点击状态设置。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.42,"time":25200,"words":84},"slug":"2017/20170109235224","path":"blog/2017/20170109235224","filePath":"blog/2017/20170109235224.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"给一组标签设置状态","datePublished":"2017-01-09T00:00:00.000Z","dateModified":"2017-01-09T00:00:00.000Z","description":"文章介绍给一组标签设置状态的方法，当鼠标点击标签时，若有“active”类则移除，无则添加。通过 jQuery 代码实现，对多个不同类别的标签进行点击状态设置。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170109235224"}},{"title":"mongoose分页查询","date":"2017-01-08T00:00:00.000Z","tags":["Node.js","MongoDB"],"draft":false,"summary":"介绍了 mongoose 分页查询，PAGE_COUNT 为每页 item 数，page 是当前页面标号。通过 schema.find 结合 skip、limit 和 sort 实现分页查询，代码简洁高效。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.14,"time":8400,"words":28},"slug":"2017/20170108105247","path":"blog/2017/20170108105247","filePath":"blog/2017/20170108105247.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"mongoose分页查询","datePublished":"2017-01-08T00:00:00.000Z","dateModified":"2017-01-08T00:00:00.000Z","description":"介绍了 mongoose 分页查询，PAGE_COUNT 为每页 item 数，page 是当前页面标号。通过 schema.find 结合 skip、limit 和 sort 实现分页查询，代码简洁高效。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170108105247"}},{"title":"android app 微信热门文章精选","date":"2017-01-08T00:00:00.000Z","tags":["Mobile"],"draft":false,"summary":"这是关于 android app 微信热门文章精选的介绍。用 react native 做小软件，通过 showapi 获取文章，展示了 index.android.js 中初始化文章列表等内容，还有 articleList.js 的文章列表显示等，以及 showArticle.js 和 typeList.js 的相关部分。 \r","type":"Blog","readingTime":{"text":"3 min read","minutes":2.2,"time":132000,"words":440},"slug":"2017/20170108125634","path":"blog/2017/20170108125634","filePath":"blog/2017/20170108125634.mdx","toc":[{"value":"index.android.js","url":"#indexandroidjs","depth":4},{"value":"articleList.js","url":"#articlelistjs","depth":4},{"value":"showArticle.js","url":"#showarticlejs","depth":4},{"value":"typeList.js","url":"#typelistjs","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"android app 微信热门文章精选","datePublished":"2017-01-08T00:00:00.000Z","dateModified":"2017-01-08T00:00:00.000Z","description":"这是关于 android app 微信热门文章精选的介绍。用 react native 做小软件，通过 showapi 获取文章，展示了 index.android.js 中初始化文章列表等内容，还有 articleList.js 的文章列表显示等，以及 showArticle.js 和 typeList.js 的相关部分。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170108125634"}},{"title":"android app 笑话","date":"2017-01-08T00:00:00.000Z","tags":["Mobile"],"draft":false,"summary":"2017 年 1 月 8 日的“android app 笑话”，用 react native 开发，通过 showapi 获取多种笑话内容，github 地址及 apk 下载地址已给出，react-native-scrollable-tab-view 组件好用且代码可看 github。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.33,"time":19800,"words":66},"slug":"2017/20170108131556","path":"blog/2017/20170108131556","filePath":"blog/2017/20170108131556.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"android app 笑话","datePublished":"2017-01-08T00:00:00.000Z","dateModified":"2017-01-08T00:00:00.000Z","description":"2017 年 1 月 8 日的“android app 笑话”，用 react native 开发，通过 showapi 获取多种笑话内容，github 地址及 apk 下载地址已给出，react-native-scrollable-tab-view 组件好用且代码可看 github。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170108131556"}},{"title":"DeprecationWarning  Mongoose  mpromise is deprecated","date":"2017-01-08T00:00:00.000Z","tags":["Node.js"],"draft":false,"summary":"2017 年 1 月 8 日的文章提到 Mongoose 的 mpromise 被弃用，发出 DeprecationWarning。去掉此警告的方法是在代码中添加 `mongoose.Promise = global.Promise;` 。  \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.135,"time":8100,"words":27},"slug":"2017/20171210125830","path":"blog/2017/20171210125830","filePath":"blog/2017/20171210125830.mdx","toc":[{"value":"var mongoose = require('mongoose');  mongoose.Promise = global.Promise;  ...","url":"#var-mongoose--requiremongoose--mongoosepromise--globalpromise--","depth":2},{"value":"去掉这个警告的方法：","url":"#去掉这个警告的方法","depth":4}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"DeprecationWarning  Mongoose  mpromise is deprecated","datePublished":"2017-01-08T00:00:00.000Z","dateModified":"2017-01-08T00:00:00.000Z","description":"2017 年 1 月 8 日的文章提到 Mongoose 的 mpromise 被弃用，发出 DeprecationWarning。去掉此警告的方法是在代码中添加 `mongoose.Promise = global.Promise;` 。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20171210125830"}},{"title":"mmbiz.qpic.cn图片防盗链","date":"2017-01-07T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"文章介绍了 mmbiz.qpic.cn 图片防盗链，包括防盗链系统含义（防范盗链，防止他人绕过展示页盗用资源）、实现原理（基于 HTTP 协议的 referer 字段跟踪来源进行处理），以及针对该网站的解决方法（在地址前加特定字符串或在 html head 中加入特定 meta 标签）。 \r","type":"Blog","readingTime":{"text":"5 min read","minutes":4.29,"time":257400,"words":858},"slug":"2017/20170107015326","path":"blog/2017/20170107015326","filePath":"blog/2017/20170107015326.mdx","toc":[{"value":"在确保地址正确的情况下，不能下载相应的资源，均是受到防盗链系统的影响，那么究竟什么是防盗链系统呢？防盗链自然就是防范盗链，所以这里先说一下什么是盗链。   ...","url":"#在确保地址正确的情况下不能下载相应的资源均是受到防盗链系统的影响那么究竟什么是防盗链系统呢防盗链自然就是防范盗链所以这里先说一下什么是盗链---","depth":2},{"value":"什么是防盗链系统","url":"#什么是防盗链系统","depth":3},{"value":"防盗链实现原理","url":"#防盗链实现原理","depth":3},{"value":"针对mmbiz.qpic.cn的解决方法","url":"#针对mmbizqpiccn的解决方法","depth":3}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"mmbiz.qpic.cn图片防盗链","datePublished":"2017-01-07T00:00:00.000Z","dateModified":"2017-01-07T00:00:00.000Z","description":"文章介绍了 mmbiz.qpic.cn 图片防盗链，包括防盗链系统含义（防范盗链，防止他人绕过展示页盗用资源）、实现原理（基于 HTTP 协议的 referer 字段跟踪来源进行处理），以及针对该网站的解决方法（在地址前加特定字符串或在 html head 中加入特定 meta 标签）。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170107015326"}},{"title":"webstorm eap 免费版","date":"2017-01-05T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"2017 年 1 月 5 日的文章，提及 webstorm eap 免费版，标签为 Web，可通过[http://confluence.jetbrains.com/display/WI/WebStorm+EAP](http://confluence.jetbrains.com/display/WI/WebStorm+EAP)获取。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.005,"time":300,"words":1},"slug":"2017/20170105142538","path":"blog/2017/20170105142538","filePath":"blog/2017/20170105142538.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"webstorm eap 免费版","datePublished":"2017-01-05T00:00:00.000Z","dateModified":"2017-01-05T00:00:00.000Z","description":"2017 年 1 月 5 日的文章，提及 webstorm eap 免费版，标签为 Web，可通过[http://confluence.jetbrains.com/display/WI/WebStorm+EAP](http://confluence.jetbrains.com/display/WI/WebStorm+EAP)获取。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170105142538"}},{"title":"网页上传图片失败","date":"2017-01-03T00:00:00.000Z","tags":["Web"],"draft":false,"summary":"2017 年 1 月 3 日，网页上传图片用 chrome 一直失败，推测是安装屏蔽插件所致，换成 IE 后成功，可见插件可能影响网页图片上传。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.165,"time":9900,"words":33},"slug":"2017/20170103142445","path":"blog/2017/20170103142445","filePath":"blog/2017/20170103142445.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"网页上传图片失败","datePublished":"2017-01-03T00:00:00.000Z","dateModified":"2017-01-03T00:00:00.000Z","description":"2017 年 1 月 3 日，网页上传图片用 chrome 一直失败，推测是安装屏蔽插件所致，换成 IE 后成功，可见插件可能影响网页图片上传。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170103142445"}},{"title":"mongodb安装（windows, ubuntu）","date":"2017-01-01T00:00:00.000Z","tags":["Windows","MongoDB","Database"],"draft":false,"summary":"文章介绍 mongodb 在 windows 和 ubuntu 上的安装及相关操作。windows 需官网下载安装，指定路径创建 data/db 目录，安装服务并指定日志和数据库路径，可通过命令启动或停止；ubuntu 直接 apt install mongodb，可用相应命令启动和关闭服务，还介绍了基本命令及跨平台界面管理工具。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.835,"time":50100,"words":167},"slug":"2017/20170101153751","path":"blog/2017/20170101153751","filePath":"blog/2017/20170101153751.mdx","toc":[{"value":"windows安装","url":"#windows安装","depth":2},{"value":"ubuntu安装","url":"#ubuntu安装","depth":2}],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"mongodb安装（windows, ubuntu）","datePublished":"2017-01-01T00:00:00.000Z","dateModified":"2017-01-01T00:00:00.000Z","description":"文章介绍 mongodb 在 windows 和 ubuntu 上的安装及相关操作。windows 需官网下载安装，指定路径创建 data/db 目录，安装服务并指定日志和数据库路径，可通过命令启动或停止；ubuntu 直接 apt install mongodb，可用相应命令启动和关闭服务，还介绍了基本命令及跨平台界面管理工具。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170101153751"}},{"title":"存储git账号信息不用每次都输入","date":"2017-01-01T00:00:00.000Z","tags":["Tools"],"draft":false,"summary":"2017 年 1 月 1 日的文章《存储 git 账号信息不用每次都输入》，可在.git 目录下 config 文件中添加“[credential]\\n    helper = store”来存储账号密码，无需每次输入。  \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.125,"time":7500,"words":25},"slug":"2017/20170101153902","path":"blog/2017/20170101153902","filePath":"blog/2017/20170101153902.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"存储git账号信息不用每次都输入","datePublished":"2017-01-01T00:00:00.000Z","dateModified":"2017-01-01T00:00:00.000Z","description":"2017 年 1 月 1 日的文章《存储 git 账号信息不用每次都输入》，可在.git 目录下 config 文件中添加“[credential]\\n    helper = store”来存储账号密码，无需每次输入。  \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170101153902"}},{"title":"Qt自定义MessageBox","date":"2017-01-01T00:00:00.000Z","tags":["C/C++","Qt"],"draft":false,"summary":"总结：2017 年 1 月 1 日的“Qt 自定义 MessageBox”，需继承自 QDialog，通过 exec 显示窗口，done 关闭窗口并返回值，与 C/C++及 Qt 相关。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.17,"time":10200,"words":34},"slug":"2017/20170101153940","path":"blog/2017/20170101153940","filePath":"blog/2017/20170101153940.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"Qt自定义MessageBox","datePublished":"2017-01-01T00:00:00.000Z","dateModified":"2017-01-01T00:00:00.000Z","description":"总结：2017 年 1 月 1 日的“Qt 自定义 MessageBox”，需继承自 QDialog，通过 exec 显示窗口，done 关闭窗口并返回值，与 C/C++及 Qt 相关。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170101153940"}},{"title":"windows 获取剪切板中的图片大小","date":"2017-01-01T00:00:00.000Z","tags":["Windows","C/C++"],"draft":false,"summary":"本文介绍了在 Windows 中用 C/C++获取剪切板中图片大小的代码。通过判断剪切板格式，打开剪切板，获取数据并转换为 DIB 结构，从而得到图片的宽度和高度，还提供了获取最后错误码的函数。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.65,"time":39000,"words":130},"slug":"2017/20170101154025","path":"blog/2017/20170101154025","filePath":"blog/2017/20170101154025.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"windows 获取剪切板中的图片大小","datePublished":"2017-01-01T00:00:00.000Z","dateModified":"2017-01-01T00:00:00.000Z","description":"本文介绍了在 Windows 中用 C/C++获取剪切板中图片大小的代码。通过判断剪切板格式，打开剪切板，获取数据并转换为 DIB 结构，从而得到图片的宽度和高度，还提供了获取最后错误码的函数。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170101154025"}},{"title":"linux git ssh配置","date":"2017-01-01T00:00:00.000Z","tags":["Tools"],"draft":false,"summary":"介绍了 linux git ssh 配置步骤，先设置用户信息，再进入 ~/.ssh 目录生成密钥对，拷贝 id_rsa.pub 内容添加到 github，最后通过 ssh -T git@github.com 验证，即可使用 git clone 命令。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.48,"time":28800,"words":96},"slug":"2017/20170101154930","path":"blog/2017/20170101154930","filePath":"blog/2017/20170101154930.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"linux git ssh配置","datePublished":"2017-01-01T00:00:00.000Z","dateModified":"2017-01-01T00:00:00.000Z","description":"介绍了 linux git ssh 配置步骤，先设置用户信息，再进入 ~/.ssh 目录生成密钥对，拷贝 id_rsa.pub 内容添加到 github，最后通过 ssh -T git@github.com 验证，即可使用 git clone 命令。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170101154930"}},{"title":"ubuntu上安装最新版nodejs","date":"2017-01-01T00:00:00.000Z","tags":["Node.js"],"draft":false,"summary":"2017 年 1 月 1 日在 ubuntu 上安装最新版 nodejs，当前版本为 v6.9.2。通过 curl 下载、tar 解压、configure 配置、make 编译、make install 安装等步骤完成安装。 \r","type":"Blog","readingTime":{"text":"1 min read","minutes":0.1,"time":6000,"words":20},"slug":"2017/20170101155326","path":"blog/2017/20170101155326","filePath":"blog/2017/20170101155326.mdx","toc":[],"structuredData":{"@context":"https://schema.org","@type":"BlogPosting","headline":"ubuntu上安装最新版nodejs","datePublished":"2017-01-01T00:00:00.000Z","dateModified":"2017-01-01T00:00:00.000Z","description":"2017 年 1 月 1 日在 ubuntu 上安装最新版 nodejs，当前版本为 v6.9.2。通过 curl 下载、tar 解压、configure 配置、make 编译、make install 安装等步骤完成安装。 \r","image":"/static/images/twitter-card.png","url":"https://tailwind-nextjs-starter-blog.vercel.app/blog/2017/20170101155326"}}]